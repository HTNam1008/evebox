
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Province
 * 
 */
export type Province = $Result.DefaultSelection<Prisma.$ProvincePayload>
/**
 * Model UserProvince
 * 
 */
export type UserProvince = $Result.DefaultSelection<Prisma.$UserProvincePayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Otp
 * 
 */
export type Otp = $Result.DefaultSelection<Prisma.$OtpPayload>
/**
 * Model Categories
 * 
 */
export type Categories = $Result.DefaultSelection<Prisma.$CategoriesPayload>
/**
 * Model EventCategories
 * 
 */
export type EventCategories = $Result.DefaultSelection<Prisma.$EventCategoriesPayload>
/**
 * Model Events
 * 
 */
export type Events = $Result.DefaultSelection<Prisma.$EventsPayload>
/**
 * Model Images
 * 
 */
export type Images = $Result.DefaultSelection<Prisma.$ImagesPayload>
/**
 * Model districts
 * 
 */
export type districts = $Result.DefaultSelection<Prisma.$districtsPayload>
/**
 * Model locations
 * 
 */
export type locations = $Result.DefaultSelection<Prisma.$locationsPayload>
/**
 * Model Row
 * 
 */
export type Row = $Result.DefaultSelection<Prisma.$RowPayload>
/**
 * Model Seat
 * 
 */
export type Seat = $Result.DefaultSelection<Prisma.$SeatPayload>
/**
 * Model Seatmap
 * 
 */
export type Seatmap = $Result.DefaultSelection<Prisma.$SeatmapPayload>
/**
 * Model Section
 * 
 */
export type Section = $Result.DefaultSelection<Prisma.$SectionPayload>
/**
 * Model Showing
 * 
 */
export type Showing = $Result.DefaultSelection<Prisma.$ShowingPayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model TicketType
 * 
 */
export type TicketType = $Result.DefaultSelection<Prisma.$TicketTypePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const OTPType: {
  FORGOT_PASSWORD: 'FORGOT_PASSWORD',
  REGISTER: 'REGISTER'
};

export type OTPType = (typeof OTPType)[keyof typeof OTPType]

}

export type OTPType = $Enums.OTPType

export const OTPType: typeof $Enums.OTPType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.province`: Exposes CRUD operations for the **Province** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Provinces
    * const provinces = await prisma.province.findMany()
    * ```
    */
  get province(): Prisma.ProvinceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProvince`: Exposes CRUD operations for the **UserProvince** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProvinces
    * const userProvinces = await prisma.userProvince.findMany()
    * ```
    */
  get userProvince(): Prisma.UserProvinceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.otp`: Exposes CRUD operations for the **Otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otp.findMany()
    * ```
    */
  get otp(): Prisma.OtpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categories`: Exposes CRUD operations for the **Categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.categories.findMany()
    * ```
    */
  get categories(): Prisma.CategoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventCategories`: Exposes CRUD operations for the **EventCategories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventCategories
    * const eventCategories = await prisma.eventCategories.findMany()
    * ```
    */
  get eventCategories(): Prisma.EventCategoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.events`: Exposes CRUD operations for the **Events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.events.findMany()
    * ```
    */
  get events(): Prisma.EventsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.images`: Exposes CRUD operations for the **Images** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.images.findMany()
    * ```
    */
  get images(): Prisma.ImagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.districts`: Exposes CRUD operations for the **districts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Districts
    * const districts = await prisma.districts.findMany()
    * ```
    */
  get districts(): Prisma.districtsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.locations`: Exposes CRUD operations for the **locations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.locations.findMany()
    * ```
    */
  get locations(): Prisma.locationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.row`: Exposes CRUD operations for the **Row** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rows
    * const rows = await prisma.row.findMany()
    * ```
    */
  get row(): Prisma.RowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seat`: Exposes CRUD operations for the **Seat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seats
    * const seats = await prisma.seat.findMany()
    * ```
    */
  get seat(): Prisma.SeatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seatmap`: Exposes CRUD operations for the **Seatmap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seatmaps
    * const seatmaps = await prisma.seatmap.findMany()
    * ```
    */
  get seatmap(): Prisma.SeatmapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.section`: Exposes CRUD operations for the **Section** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sections
    * const sections = await prisma.section.findMany()
    * ```
    */
  get section(): Prisma.SectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.showing`: Exposes CRUD operations for the **Showing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Showings
    * const showings = await prisma.showing.findMany()
    * ```
    */
  get showing(): Prisma.ShowingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketType`: Exposes CRUD operations for the **TicketType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketTypes
    * const ticketTypes = await prisma.ticketType.findMany()
    * ```
    */
  get ticketType(): Prisma.TicketTypeDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.4.1
   * Query Engine version: a9055b89e58b4b5bfb59600785423b1db3d0e75d
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    Province: 'Province',
    UserProvince: 'UserProvince',
    RefreshToken: 'RefreshToken',
    Otp: 'Otp',
    Categories: 'Categories',
    EventCategories: 'EventCategories',
    Events: 'Events',
    Images: 'Images',
    districts: 'districts',
    locations: 'locations',
    Row: 'Row',
    Seat: 'Seat',
    Seatmap: 'Seatmap',
    Section: 'Section',
    Showing: 'Showing',
    Ticket: 'Ticket',
    TicketType: 'TicketType'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "role" | "province" | "userProvince" | "refreshToken" | "otp" | "categories" | "eventCategories" | "events" | "images" | "districts" | "locations" | "row" | "seat" | "seatmap" | "section" | "showing" | "ticket" | "ticketType"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Province: {
        payload: Prisma.$ProvincePayload<ExtArgs>
        fields: Prisma.ProvinceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProvinceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProvinceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          findFirst: {
            args: Prisma.ProvinceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProvinceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          findMany: {
            args: Prisma.ProvinceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>[]
          }
          create: {
            args: Prisma.ProvinceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          createMany: {
            args: Prisma.ProvinceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProvinceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>[]
          }
          delete: {
            args: Prisma.ProvinceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          update: {
            args: Prisma.ProvinceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          deleteMany: {
            args: Prisma.ProvinceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProvinceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProvinceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>[]
          }
          upsert: {
            args: Prisma.ProvinceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          aggregate: {
            args: Prisma.ProvinceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvince>
          }
          groupBy: {
            args: Prisma.ProvinceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProvinceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProvinceCountArgs<ExtArgs>
            result: $Utils.Optional<ProvinceCountAggregateOutputType> | number
          }
        }
      }
      UserProvince: {
        payload: Prisma.$UserProvincePayload<ExtArgs>
        fields: Prisma.UserProvinceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProvinceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProvincePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProvinceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProvincePayload>
          }
          findFirst: {
            args: Prisma.UserProvinceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProvincePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProvinceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProvincePayload>
          }
          findMany: {
            args: Prisma.UserProvinceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProvincePayload>[]
          }
          create: {
            args: Prisma.UserProvinceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProvincePayload>
          }
          createMany: {
            args: Prisma.UserProvinceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProvinceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProvincePayload>[]
          }
          delete: {
            args: Prisma.UserProvinceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProvincePayload>
          }
          update: {
            args: Prisma.UserProvinceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProvincePayload>
          }
          deleteMany: {
            args: Prisma.UserProvinceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProvinceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProvinceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProvincePayload>[]
          }
          upsert: {
            args: Prisma.UserProvinceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProvincePayload>
          }
          aggregate: {
            args: Prisma.UserProvinceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProvince>
          }
          groupBy: {
            args: Prisma.UserProvinceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProvinceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProvinceCountArgs<ExtArgs>
            result: $Utils.Optional<UserProvinceCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Otp: {
        payload: Prisma.$OtpPayload<ExtArgs>
        fields: Prisma.OtpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findFirst: {
            args: Prisma.OtpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findMany: {
            args: Prisma.OtpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          create: {
            args: Prisma.OtpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          createMany: {
            args: Prisma.OtpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OtpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          delete: {
            args: Prisma.OtpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          update: {
            args: Prisma.OtpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          deleteMany: {
            args: Prisma.OtpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OtpUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          upsert: {
            args: Prisma.OtpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          aggregate: {
            args: Prisma.OtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtp>
          }
          groupBy: {
            args: Prisma.OtpGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtpCountArgs<ExtArgs>
            result: $Utils.Optional<OtpCountAggregateOutputType> | number
          }
        }
      }
      Categories: {
        payload: Prisma.$CategoriesPayload<ExtArgs>
        fields: Prisma.CategoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          findFirst: {
            args: Prisma.CategoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          findMany: {
            args: Prisma.CategoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>[]
          }
          create: {
            args: Prisma.CategoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          createMany: {
            args: Prisma.CategoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>[]
          }
          delete: {
            args: Prisma.CategoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          update: {
            args: Prisma.CategoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          deleteMany: {
            args: Prisma.CategoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>[]
          }
          upsert: {
            args: Prisma.CategoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          aggregate: {
            args: Prisma.CategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategories>
          }
          groupBy: {
            args: Prisma.CategoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoriesCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriesCountAggregateOutputType> | number
          }
        }
      }
      EventCategories: {
        payload: Prisma.$EventCategoriesPayload<ExtArgs>
        fields: Prisma.EventCategoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventCategoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventCategoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoriesPayload>
          }
          findFirst: {
            args: Prisma.EventCategoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventCategoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoriesPayload>
          }
          findMany: {
            args: Prisma.EventCategoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoriesPayload>[]
          }
          create: {
            args: Prisma.EventCategoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoriesPayload>
          }
          createMany: {
            args: Prisma.EventCategoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCategoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoriesPayload>[]
          }
          delete: {
            args: Prisma.EventCategoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoriesPayload>
          }
          update: {
            args: Prisma.EventCategoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoriesPayload>
          }
          deleteMany: {
            args: Prisma.EventCategoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventCategoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventCategoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoriesPayload>[]
          }
          upsert: {
            args: Prisma.EventCategoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoriesPayload>
          }
          aggregate: {
            args: Prisma.EventCategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventCategories>
          }
          groupBy: {
            args: Prisma.EventCategoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventCategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCategoriesCountArgs<ExtArgs>
            result: $Utils.Optional<EventCategoriesCountAggregateOutputType> | number
          }
        }
      }
      Events: {
        payload: Prisma.$EventsPayload<ExtArgs>
        fields: Prisma.EventsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          findFirst: {
            args: Prisma.EventsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          findMany: {
            args: Prisma.EventsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>[]
          }
          create: {
            args: Prisma.EventsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          createMany: {
            args: Prisma.EventsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>[]
          }
          delete: {
            args: Prisma.EventsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          update: {
            args: Prisma.EventsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          deleteMany: {
            args: Prisma.EventsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>[]
          }
          upsert: {
            args: Prisma.EventsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          aggregate: {
            args: Prisma.EventsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvents>
          }
          groupBy: {
            args: Prisma.EventsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventsCountArgs<ExtArgs>
            result: $Utils.Optional<EventsCountAggregateOutputType> | number
          }
        }
      }
      Images: {
        payload: Prisma.$ImagesPayload<ExtArgs>
        fields: Prisma.ImagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload>
          }
          findFirst: {
            args: Prisma.ImagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload>
          }
          findMany: {
            args: Prisma.ImagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload>[]
          }
          create: {
            args: Prisma.ImagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload>
          }
          createMany: {
            args: Prisma.ImagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload>[]
          }
          delete: {
            args: Prisma.ImagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload>
          }
          update: {
            args: Prisma.ImagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload>
          }
          deleteMany: {
            args: Prisma.ImagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload>[]
          }
          upsert: {
            args: Prisma.ImagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload>
          }
          aggregate: {
            args: Prisma.ImagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImages>
          }
          groupBy: {
            args: Prisma.ImagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImagesCountArgs<ExtArgs>
            result: $Utils.Optional<ImagesCountAggregateOutputType> | number
          }
        }
      }
      districts: {
        payload: Prisma.$districtsPayload<ExtArgs>
        fields: Prisma.districtsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.districtsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.districtsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>
          }
          findFirst: {
            args: Prisma.districtsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.districtsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>
          }
          findMany: {
            args: Prisma.districtsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>[]
          }
          create: {
            args: Prisma.districtsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>
          }
          createMany: {
            args: Prisma.districtsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.districtsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>[]
          }
          delete: {
            args: Prisma.districtsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>
          }
          update: {
            args: Prisma.districtsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>
          }
          deleteMany: {
            args: Prisma.districtsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.districtsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.districtsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>[]
          }
          upsert: {
            args: Prisma.districtsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>
          }
          aggregate: {
            args: Prisma.DistrictsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDistricts>
          }
          groupBy: {
            args: Prisma.districtsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DistrictsGroupByOutputType>[]
          }
          count: {
            args: Prisma.districtsCountArgs<ExtArgs>
            result: $Utils.Optional<DistrictsCountAggregateOutputType> | number
          }
        }
      }
      locations: {
        payload: Prisma.$locationsPayload<ExtArgs>
        fields: Prisma.locationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.locationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.locationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          findFirst: {
            args: Prisma.locationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.locationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          findMany: {
            args: Prisma.locationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>[]
          }
          create: {
            args: Prisma.locationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          createMany: {
            args: Prisma.locationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.locationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>[]
          }
          delete: {
            args: Prisma.locationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          update: {
            args: Prisma.locationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          deleteMany: {
            args: Prisma.locationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.locationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.locationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>[]
          }
          upsert: {
            args: Prisma.locationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          aggregate: {
            args: Prisma.LocationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocations>
          }
          groupBy: {
            args: Prisma.locationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.locationsCountArgs<ExtArgs>
            result: $Utils.Optional<LocationsCountAggregateOutputType> | number
          }
        }
      }
      Row: {
        payload: Prisma.$RowPayload<ExtArgs>
        fields: Prisma.RowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload>
          }
          findFirst: {
            args: Prisma.RowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload>
          }
          findMany: {
            args: Prisma.RowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload>[]
          }
          create: {
            args: Prisma.RowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload>
          }
          createMany: {
            args: Prisma.RowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload>[]
          }
          delete: {
            args: Prisma.RowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload>
          }
          update: {
            args: Prisma.RowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload>
          }
          deleteMany: {
            args: Prisma.RowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload>[]
          }
          upsert: {
            args: Prisma.RowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RowPayload>
          }
          aggregate: {
            args: Prisma.RowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRow>
          }
          groupBy: {
            args: Prisma.RowGroupByArgs<ExtArgs>
            result: $Utils.Optional<RowGroupByOutputType>[]
          }
          count: {
            args: Prisma.RowCountArgs<ExtArgs>
            result: $Utils.Optional<RowCountAggregateOutputType> | number
          }
        }
      }
      Seat: {
        payload: Prisma.$SeatPayload<ExtArgs>
        fields: Prisma.SeatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          findFirst: {
            args: Prisma.SeatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          findMany: {
            args: Prisma.SeatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>[]
          }
          create: {
            args: Prisma.SeatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          createMany: {
            args: Prisma.SeatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>[]
          }
          delete: {
            args: Prisma.SeatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          update: {
            args: Prisma.SeatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          deleteMany: {
            args: Prisma.SeatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>[]
          }
          upsert: {
            args: Prisma.SeatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          aggregate: {
            args: Prisma.SeatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeat>
          }
          groupBy: {
            args: Prisma.SeatGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeatGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeatCountArgs<ExtArgs>
            result: $Utils.Optional<SeatCountAggregateOutputType> | number
          }
        }
      }
      Seatmap: {
        payload: Prisma.$SeatmapPayload<ExtArgs>
        fields: Prisma.SeatmapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeatmapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatmapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeatmapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatmapPayload>
          }
          findFirst: {
            args: Prisma.SeatmapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatmapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeatmapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatmapPayload>
          }
          findMany: {
            args: Prisma.SeatmapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatmapPayload>[]
          }
          create: {
            args: Prisma.SeatmapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatmapPayload>
          }
          createMany: {
            args: Prisma.SeatmapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeatmapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatmapPayload>[]
          }
          delete: {
            args: Prisma.SeatmapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatmapPayload>
          }
          update: {
            args: Prisma.SeatmapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatmapPayload>
          }
          deleteMany: {
            args: Prisma.SeatmapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeatmapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeatmapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatmapPayload>[]
          }
          upsert: {
            args: Prisma.SeatmapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatmapPayload>
          }
          aggregate: {
            args: Prisma.SeatmapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeatmap>
          }
          groupBy: {
            args: Prisma.SeatmapGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeatmapGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeatmapCountArgs<ExtArgs>
            result: $Utils.Optional<SeatmapCountAggregateOutputType> | number
          }
        }
      }
      Section: {
        payload: Prisma.$SectionPayload<ExtArgs>
        fields: Prisma.SectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findFirst: {
            args: Prisma.SectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findMany: {
            args: Prisma.SectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          create: {
            args: Prisma.SectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          createMany: {
            args: Prisma.SectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          delete: {
            args: Prisma.SectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          update: {
            args: Prisma.SectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          deleteMany: {
            args: Prisma.SectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          upsert: {
            args: Prisma.SectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          aggregate: {
            args: Prisma.SectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSection>
          }
          groupBy: {
            args: Prisma.SectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SectionCountArgs<ExtArgs>
            result: $Utils.Optional<SectionCountAggregateOutputType> | number
          }
        }
      }
      Showing: {
        payload: Prisma.$ShowingPayload<ExtArgs>
        fields: Prisma.ShowingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShowingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShowingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload>
          }
          findFirst: {
            args: Prisma.ShowingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShowingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload>
          }
          findMany: {
            args: Prisma.ShowingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload>[]
          }
          create: {
            args: Prisma.ShowingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload>
          }
          createMany: {
            args: Prisma.ShowingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShowingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload>[]
          }
          delete: {
            args: Prisma.ShowingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload>
          }
          update: {
            args: Prisma.ShowingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload>
          }
          deleteMany: {
            args: Prisma.ShowingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShowingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShowingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload>[]
          }
          upsert: {
            args: Prisma.ShowingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload>
          }
          aggregate: {
            args: Prisma.ShowingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShowing>
          }
          groupBy: {
            args: Prisma.ShowingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShowingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShowingCountArgs<ExtArgs>
            result: $Utils.Optional<ShowingCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      TicketType: {
        payload: Prisma.$TicketTypePayload<ExtArgs>
        fields: Prisma.TicketTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTypePayload>
          }
          findFirst: {
            args: Prisma.TicketTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTypePayload>
          }
          findMany: {
            args: Prisma.TicketTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTypePayload>[]
          }
          create: {
            args: Prisma.TicketTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTypePayload>
          }
          createMany: {
            args: Prisma.TicketTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTypePayload>[]
          }
          delete: {
            args: Prisma.TicketTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTypePayload>
          }
          update: {
            args: Prisma.TicketTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTypePayload>
          }
          deleteMany: {
            args: Prisma.TicketTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTypePayload>[]
          }
          upsert: {
            args: Prisma.TicketTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTypePayload>
          }
          aggregate: {
            args: Prisma.TicketTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketType>
          }
          groupBy: {
            args: Prisma.TicketTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketTypeCountArgs<ExtArgs>
            result: $Utils.Optional<TicketTypeCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    role?: RoleOmit
    province?: ProvinceOmit
    userProvince?: UserProvinceOmit
    refreshToken?: RefreshTokenOmit
    otp?: OtpOmit
    categories?: CategoriesOmit
    eventCategories?: EventCategoriesOmit
    events?: EventsOmit
    images?: ImagesOmit
    districts?: districtsOmit
    locations?: locationsOmit
    row?: RowOmit
    seat?: SeatOmit
    seatmap?: SeatmapOmit
    section?: SectionOmit
    showing?: ShowingOmit
    ticket?: TicketOmit
    ticketType?: TicketTypeOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Events: number
    refreshTokens: number
    userProvince: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Events?: boolean | UserCountOutputTypeCountEventsArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    userProvince?: boolean | UserCountOutputTypeCountUserProvinceArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserProvinceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProvinceWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type ProvinceCountOutputType
   */

  export type ProvinceCountOutputType = {
    districts: number
    userProvince: number
  }

  export type ProvinceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    districts?: boolean | ProvinceCountOutputTypeCountDistrictsArgs
    userProvince?: boolean | ProvinceCountOutputTypeCountUserProvinceArgs
  }

  // Custom InputTypes
  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvinceCountOutputType
     */
    select?: ProvinceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountDistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: districtsWhereInput
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountUserProvinceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProvinceWhereInput
  }


  /**
   * Count Type CategoriesCountOutputType
   */

  export type CategoriesCountOutputType = {
    EventCategories: number
  }

  export type CategoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EventCategories?: boolean | CategoriesCountOutputTypeCountEventCategoriesArgs
  }

  // Custom InputTypes
  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesCountOutputType
     */
    select?: CategoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountEventCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventCategoriesWhereInput
  }


  /**
   * Count Type EventsCountOutputType
   */

  export type EventsCountOutputType = {
    EventCategories: number
    Showing: number
  }

  export type EventsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EventCategories?: boolean | EventsCountOutputTypeCountEventCategoriesArgs
    Showing?: boolean | EventsCountOutputTypeCountShowingArgs
  }

  // Custom InputTypes
  /**
   * EventsCountOutputType without action
   */
  export type EventsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventsCountOutputType
     */
    select?: EventsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventsCountOutputType without action
   */
  export type EventsCountOutputTypeCountEventCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventCategoriesWhereInput
  }

  /**
   * EventsCountOutputType without action
   */
  export type EventsCountOutputTypeCountShowingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShowingWhereInput
  }


  /**
   * Count Type ImagesCountOutputType
   */

  export type ImagesCountOutputType = {
    Events_Events_imgLogoIdToImages: number
    Events_Events_imgPosterIdToImages: number
  }

  export type ImagesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Events_Events_imgLogoIdToImages?: boolean | ImagesCountOutputTypeCountEvents_Events_imgLogoIdToImagesArgs
    Events_Events_imgPosterIdToImages?: boolean | ImagesCountOutputTypeCountEvents_Events_imgPosterIdToImagesArgs
  }

  // Custom InputTypes
  /**
   * ImagesCountOutputType without action
   */
  export type ImagesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagesCountOutputType
     */
    select?: ImagesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ImagesCountOutputType without action
   */
  export type ImagesCountOutputTypeCountEvents_Events_imgLogoIdToImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventsWhereInput
  }

  /**
   * ImagesCountOutputType without action
   */
  export type ImagesCountOutputTypeCountEvents_Events_imgPosterIdToImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventsWhereInput
  }


  /**
   * Count Type DistrictsCountOutputType
   */

  export type DistrictsCountOutputType = {
    locations: number
  }

  export type DistrictsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | DistrictsCountOutputTypeCountLocationsArgs
  }

  // Custom InputTypes
  /**
   * DistrictsCountOutputType without action
   */
  export type DistrictsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistrictsCountOutputType
     */
    select?: DistrictsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DistrictsCountOutputType without action
   */
  export type DistrictsCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: locationsWhereInput
  }


  /**
   * Count Type LocationsCountOutputType
   */

  export type LocationsCountOutputType = {
    Events: number
  }

  export type LocationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Events?: boolean | LocationsCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * LocationsCountOutputType without action
   */
  export type LocationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationsCountOutputType
     */
    select?: LocationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationsCountOutputType without action
   */
  export type LocationsCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventsWhereInput
  }


  /**
   * Count Type RowCountOutputType
   */

  export type RowCountOutputType = {
    Seat: number
  }

  export type RowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Seat?: boolean | RowCountOutputTypeCountSeatArgs
  }

  // Custom InputTypes
  /**
   * RowCountOutputType without action
   */
  export type RowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RowCountOutputType
     */
    select?: RowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RowCountOutputType without action
   */
  export type RowCountOutputTypeCountSeatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatWhereInput
  }


  /**
   * Count Type SeatCountOutputType
   */

  export type SeatCountOutputType = {
    Ticket: number
  }

  export type SeatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ticket?: boolean | SeatCountOutputTypeCountTicketArgs
  }

  // Custom InputTypes
  /**
   * SeatCountOutputType without action
   */
  export type SeatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatCountOutputType
     */
    select?: SeatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeatCountOutputType without action
   */
  export type SeatCountOutputTypeCountTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Count Type SeatmapCountOutputType
   */

  export type SeatmapCountOutputType = {
    Section: number
    Showing: number
  }

  export type SeatmapCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Section?: boolean | SeatmapCountOutputTypeCountSectionArgs
    Showing?: boolean | SeatmapCountOutputTypeCountShowingArgs
  }

  // Custom InputTypes
  /**
   * SeatmapCountOutputType without action
   */
  export type SeatmapCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatmapCountOutputType
     */
    select?: SeatmapCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeatmapCountOutputType without action
   */
  export type SeatmapCountOutputTypeCountSectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
  }

  /**
   * SeatmapCountOutputType without action
   */
  export type SeatmapCountOutputTypeCountShowingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShowingWhereInput
  }


  /**
   * Count Type SectionCountOutputType
   */

  export type SectionCountOutputType = {
    Row: number
  }

  export type SectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Row?: boolean | SectionCountOutputTypeCountRowArgs
  }

  // Custom InputTypes
  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionCountOutputType
     */
    select?: SectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountRowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RowWhereInput
  }


  /**
   * Count Type ShowingCountOutputType
   */

  export type ShowingCountOutputType = {
    Ticket: number
    TicketType: number
  }

  export type ShowingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ticket?: boolean | ShowingCountOutputTypeCountTicketArgs
    TicketType?: boolean | ShowingCountOutputTypeCountTicketTypeArgs
  }

  // Custom InputTypes
  /**
   * ShowingCountOutputType without action
   */
  export type ShowingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowingCountOutputType
     */
    select?: ShowingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShowingCountOutputType without action
   */
  export type ShowingCountOutputTypeCountTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * ShowingCountOutputType without action
   */
  export type ShowingCountOutputTypeCountTicketTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketTypeWhereInput
  }


  /**
   * Count Type TicketTypeCountOutputType
   */

  export type TicketTypeCountOutputType = {
    Ticket: number
  }

  export type TicketTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ticket?: boolean | TicketTypeCountOutputTypeCountTicketArgs
  }

  // Custom InputTypes
  /**
   * TicketTypeCountOutputType without action
   */
  export type TicketTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTypeCountOutputType
     */
    select?: TicketTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketTypeCountOutputType without action
   */
  export type TicketTypeCountOutputTypeCountTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    role_id: number | null
  }

  export type UserSumAggregateOutputType = {
    role_id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    role_id: number | null
    created_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    role_id: number | null
    created_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    password: number
    role_id: number
    created_at: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    role_id?: true
  }

  export type UserSumAggregateInputType = {
    role_id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    role_id?: true
    created_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    role_id?: true
    created_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    role_id?: true
    created_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string
    password: string
    role_id: number | null
    created_at: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role_id?: boolean
    created_at?: boolean
    Events?: boolean | User$EventsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    userProvince?: boolean | User$userProvinceArgs<ExtArgs>
    role?: boolean | User$roleArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role_id?: boolean
    created_at?: boolean
    role?: boolean | User$roleArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role_id?: boolean
    created_at?: boolean
    role?: boolean | User$roleArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role_id?: boolean
    created_at?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "password" | "role_id" | "created_at", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Events?: boolean | User$EventsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    userProvince?: boolean | User$userProvinceArgs<ExtArgs>
    role?: boolean | User$roleArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | User$roleArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | User$roleArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      Events: Prisma.$EventsPayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      userProvince: Prisma.$UserProvincePayload<ExtArgs>[]
      role: Prisma.$RolePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string
      password: string
      role_id: number | null
      created_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Events<T extends User$EventsArgs<ExtArgs> = {}>(args?: Subset<T, User$EventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    userProvince<T extends User$userProvinceArgs<ExtArgs> = {}>(args?: Subset<T, User$userProvinceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProvincePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    role<T extends User$roleArgs<ExtArgs> = {}>(args?: Subset<T, User$roleArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role_id: FieldRef<"User", 'Int'>
    readonly created_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.Events
   */
  export type User$EventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    where?: EventsWhereInput
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    cursor?: EventsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.userProvince
   */
  export type User$userProvinceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProvince
     */
    select?: UserProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProvince
     */
    omit?: UserProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProvinceInclude<ExtArgs> | null
    where?: UserProvinceWhereInput
    orderBy?: UserProvinceOrderByWithRelationInput | UserProvinceOrderByWithRelationInput[]
    cursor?: UserProvinceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProvinceScalarFieldEnum | UserProvinceScalarFieldEnum[]
  }

  /**
   * User.role
   */
  export type User$roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    role_name: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    role_name: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    role_name: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    role_name?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    role_name?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    role_name?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    role_name: string
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_name?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_name?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_name?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    role_name?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role_name", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      role_name: string
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly role_name: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Province
   */

  export type AggregateProvince = {
    _count: ProvinceCountAggregateOutputType | null
    _avg: ProvinceAvgAggregateOutputType | null
    _sum: ProvinceSumAggregateOutputType | null
    _min: ProvinceMinAggregateOutputType | null
    _max: ProvinceMaxAggregateOutputType | null
  }

  export type ProvinceAvgAggregateOutputType = {
    id: number | null
  }

  export type ProvinceSumAggregateOutputType = {
    id: number | null
  }

  export type ProvinceMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
  }

  export type ProvinceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
  }

  export type ProvinceCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    _all: number
  }


  export type ProvinceAvgAggregateInputType = {
    id?: true
  }

  export type ProvinceSumAggregateInputType = {
    id?: true
  }

  export type ProvinceMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
  }

  export type ProvinceMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
  }

  export type ProvinceCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    _all?: true
  }

  export type ProvinceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Province to aggregate.
     */
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     */
    orderBy?: ProvinceOrderByWithRelationInput | ProvinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Provinces
    **/
    _count?: true | ProvinceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProvinceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProvinceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvinceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvinceMaxAggregateInputType
  }

  export type GetProvinceAggregateType<T extends ProvinceAggregateArgs> = {
        [P in keyof T & keyof AggregateProvince]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvince[P]>
      : GetScalarType<T[P], AggregateProvince[P]>
  }




  export type ProvinceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProvinceWhereInput
    orderBy?: ProvinceOrderByWithAggregationInput | ProvinceOrderByWithAggregationInput[]
    by: ProvinceScalarFieldEnum[] | ProvinceScalarFieldEnum
    having?: ProvinceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvinceCountAggregateInputType | true
    _avg?: ProvinceAvgAggregateInputType
    _sum?: ProvinceSumAggregateInputType
    _min?: ProvinceMinAggregateInputType
    _max?: ProvinceMaxAggregateInputType
  }

  export type ProvinceGroupByOutputType = {
    id: number
    name: string
    created_at: Date
    _count: ProvinceCountAggregateOutputType | null
    _avg: ProvinceAvgAggregateOutputType | null
    _sum: ProvinceSumAggregateOutputType | null
    _min: ProvinceMinAggregateOutputType | null
    _max: ProvinceMaxAggregateOutputType | null
  }

  type GetProvinceGroupByPayload<T extends ProvinceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProvinceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProvinceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProvinceGroupByOutputType[P]>
            : GetScalarType<T[P], ProvinceGroupByOutputType[P]>
        }
      >
    >


  export type ProvinceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    districts?: boolean | Province$districtsArgs<ExtArgs>
    userProvince?: boolean | Province$userProvinceArgs<ExtArgs>
    _count?: boolean | ProvinceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["province"]>

  export type ProvinceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["province"]>

  export type ProvinceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["province"]>

  export type ProvinceSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
  }

  export type ProvinceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "created_at", ExtArgs["result"]["province"]>
  export type ProvinceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    districts?: boolean | Province$districtsArgs<ExtArgs>
    userProvince?: boolean | Province$userProvinceArgs<ExtArgs>
    _count?: boolean | ProvinceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProvinceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProvinceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProvincePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Province"
    objects: {
      districts: Prisma.$districtsPayload<ExtArgs>[]
      userProvince: Prisma.$UserProvincePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      created_at: Date
    }, ExtArgs["result"]["province"]>
    composites: {}
  }

  type ProvinceGetPayload<S extends boolean | null | undefined | ProvinceDefaultArgs> = $Result.GetResult<Prisma.$ProvincePayload, S>

  type ProvinceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProvinceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProvinceCountAggregateInputType | true
    }

  export interface ProvinceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Province'], meta: { name: 'Province' } }
    /**
     * Find zero or one Province that matches the filter.
     * @param {ProvinceFindUniqueArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProvinceFindUniqueArgs>(args: SelectSubset<T, ProvinceFindUniqueArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Province that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProvinceFindUniqueOrThrowArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProvinceFindUniqueOrThrowArgs>(args: SelectSubset<T, ProvinceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Province that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceFindFirstArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProvinceFindFirstArgs>(args?: SelectSubset<T, ProvinceFindFirstArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Province that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceFindFirstOrThrowArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProvinceFindFirstOrThrowArgs>(args?: SelectSubset<T, ProvinceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Provinces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Provinces
     * const provinces = await prisma.province.findMany()
     * 
     * // Get first 10 Provinces
     * const provinces = await prisma.province.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const provinceWithIdOnly = await prisma.province.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProvinceFindManyArgs>(args?: SelectSubset<T, ProvinceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Province.
     * @param {ProvinceCreateArgs} args - Arguments to create a Province.
     * @example
     * // Create one Province
     * const Province = await prisma.province.create({
     *   data: {
     *     // ... data to create a Province
     *   }
     * })
     * 
     */
    create<T extends ProvinceCreateArgs>(args: SelectSubset<T, ProvinceCreateArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Provinces.
     * @param {ProvinceCreateManyArgs} args - Arguments to create many Provinces.
     * @example
     * // Create many Provinces
     * const province = await prisma.province.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProvinceCreateManyArgs>(args?: SelectSubset<T, ProvinceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Provinces and returns the data saved in the database.
     * @param {ProvinceCreateManyAndReturnArgs} args - Arguments to create many Provinces.
     * @example
     * // Create many Provinces
     * const province = await prisma.province.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Provinces and only return the `id`
     * const provinceWithIdOnly = await prisma.province.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProvinceCreateManyAndReturnArgs>(args?: SelectSubset<T, ProvinceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Province.
     * @param {ProvinceDeleteArgs} args - Arguments to delete one Province.
     * @example
     * // Delete one Province
     * const Province = await prisma.province.delete({
     *   where: {
     *     // ... filter to delete one Province
     *   }
     * })
     * 
     */
    delete<T extends ProvinceDeleteArgs>(args: SelectSubset<T, ProvinceDeleteArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Province.
     * @param {ProvinceUpdateArgs} args - Arguments to update one Province.
     * @example
     * // Update one Province
     * const province = await prisma.province.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProvinceUpdateArgs>(args: SelectSubset<T, ProvinceUpdateArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Provinces.
     * @param {ProvinceDeleteManyArgs} args - Arguments to filter Provinces to delete.
     * @example
     * // Delete a few Provinces
     * const { count } = await prisma.province.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProvinceDeleteManyArgs>(args?: SelectSubset<T, ProvinceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provinces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Provinces
     * const province = await prisma.province.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProvinceUpdateManyArgs>(args: SelectSubset<T, ProvinceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provinces and returns the data updated in the database.
     * @param {ProvinceUpdateManyAndReturnArgs} args - Arguments to update many Provinces.
     * @example
     * // Update many Provinces
     * const province = await prisma.province.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Provinces and only return the `id`
     * const provinceWithIdOnly = await prisma.province.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProvinceUpdateManyAndReturnArgs>(args: SelectSubset<T, ProvinceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Province.
     * @param {ProvinceUpsertArgs} args - Arguments to update or create a Province.
     * @example
     * // Update or create a Province
     * const province = await prisma.province.upsert({
     *   create: {
     *     // ... data to create a Province
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Province we want to update
     *   }
     * })
     */
    upsert<T extends ProvinceUpsertArgs>(args: SelectSubset<T, ProvinceUpsertArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Provinces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceCountArgs} args - Arguments to filter Provinces to count.
     * @example
     * // Count the number of Provinces
     * const count = await prisma.province.count({
     *   where: {
     *     // ... the filter for the Provinces we want to count
     *   }
     * })
    **/
    count<T extends ProvinceCountArgs>(
      args?: Subset<T, ProvinceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvinceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Province.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvinceAggregateArgs>(args: Subset<T, ProvinceAggregateArgs>): Prisma.PrismaPromise<GetProvinceAggregateType<T>>

    /**
     * Group by Province.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProvinceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProvinceGroupByArgs['orderBy'] }
        : { orderBy?: ProvinceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProvinceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvinceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Province model
   */
  readonly fields: ProvinceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Province.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProvinceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    districts<T extends Province$districtsArgs<ExtArgs> = {}>(args?: Subset<T, Province$districtsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    userProvince<T extends Province$userProvinceArgs<ExtArgs> = {}>(args?: Subset<T, Province$userProvinceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProvincePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Province model
   */ 
  interface ProvinceFieldRefs {
    readonly id: FieldRef<"Province", 'Int'>
    readonly name: FieldRef<"Province", 'String'>
    readonly created_at: FieldRef<"Province", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Province findUnique
   */
  export type ProvinceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter, which Province to fetch.
     */
    where: ProvinceWhereUniqueInput
  }

  /**
   * Province findUniqueOrThrow
   */
  export type ProvinceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter, which Province to fetch.
     */
    where: ProvinceWhereUniqueInput
  }

  /**
   * Province findFirst
   */
  export type ProvinceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter, which Province to fetch.
     */
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     */
    orderBy?: ProvinceOrderByWithRelationInput | ProvinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Provinces.
     */
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Provinces.
     */
    distinct?: ProvinceScalarFieldEnum | ProvinceScalarFieldEnum[]
  }

  /**
   * Province findFirstOrThrow
   */
  export type ProvinceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter, which Province to fetch.
     */
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     */
    orderBy?: ProvinceOrderByWithRelationInput | ProvinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Provinces.
     */
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Provinces.
     */
    distinct?: ProvinceScalarFieldEnum | ProvinceScalarFieldEnum[]
  }

  /**
   * Province findMany
   */
  export type ProvinceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter, which Provinces to fetch.
     */
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     */
    orderBy?: ProvinceOrderByWithRelationInput | ProvinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Provinces.
     */
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     */
    skip?: number
    distinct?: ProvinceScalarFieldEnum | ProvinceScalarFieldEnum[]
  }

  /**
   * Province create
   */
  export type ProvinceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * The data needed to create a Province.
     */
    data: XOR<ProvinceCreateInput, ProvinceUncheckedCreateInput>
  }

  /**
   * Province createMany
   */
  export type ProvinceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Provinces.
     */
    data: ProvinceCreateManyInput | ProvinceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Province createManyAndReturn
   */
  export type ProvinceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * The data used to create many Provinces.
     */
    data: ProvinceCreateManyInput | ProvinceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Province update
   */
  export type ProvinceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * The data needed to update a Province.
     */
    data: XOR<ProvinceUpdateInput, ProvinceUncheckedUpdateInput>
    /**
     * Choose, which Province to update.
     */
    where: ProvinceWhereUniqueInput
  }

  /**
   * Province updateMany
   */
  export type ProvinceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Provinces.
     */
    data: XOR<ProvinceUpdateManyMutationInput, ProvinceUncheckedUpdateManyInput>
    /**
     * Filter which Provinces to update
     */
    where?: ProvinceWhereInput
    /**
     * Limit how many Provinces to update.
     */
    limit?: number
  }

  /**
   * Province updateManyAndReturn
   */
  export type ProvinceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * The data used to update Provinces.
     */
    data: XOR<ProvinceUpdateManyMutationInput, ProvinceUncheckedUpdateManyInput>
    /**
     * Filter which Provinces to update
     */
    where?: ProvinceWhereInput
    /**
     * Limit how many Provinces to update.
     */
    limit?: number
  }

  /**
   * Province upsert
   */
  export type ProvinceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * The filter to search for the Province to update in case it exists.
     */
    where: ProvinceWhereUniqueInput
    /**
     * In case the Province found by the `where` argument doesn't exist, create a new Province with this data.
     */
    create: XOR<ProvinceCreateInput, ProvinceUncheckedCreateInput>
    /**
     * In case the Province was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProvinceUpdateInput, ProvinceUncheckedUpdateInput>
  }

  /**
   * Province delete
   */
  export type ProvinceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter which Province to delete.
     */
    where: ProvinceWhereUniqueInput
  }

  /**
   * Province deleteMany
   */
  export type ProvinceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Provinces to delete
     */
    where?: ProvinceWhereInput
    /**
     * Limit how many Provinces to delete.
     */
    limit?: number
  }

  /**
   * Province.districts
   */
  export type Province$districtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the districts
     */
    omit?: districtsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    where?: districtsWhereInput
    orderBy?: districtsOrderByWithRelationInput | districtsOrderByWithRelationInput[]
    cursor?: districtsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DistrictsScalarFieldEnum | DistrictsScalarFieldEnum[]
  }

  /**
   * Province.userProvince
   */
  export type Province$userProvinceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProvince
     */
    select?: UserProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProvince
     */
    omit?: UserProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProvinceInclude<ExtArgs> | null
    where?: UserProvinceWhereInput
    orderBy?: UserProvinceOrderByWithRelationInput | UserProvinceOrderByWithRelationInput[]
    cursor?: UserProvinceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProvinceScalarFieldEnum | UserProvinceScalarFieldEnum[]
  }

  /**
   * Province without action
   */
  export type ProvinceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
  }


  /**
   * Model UserProvince
   */

  export type AggregateUserProvince = {
    _count: UserProvinceCountAggregateOutputType | null
    _avg: UserProvinceAvgAggregateOutputType | null
    _sum: UserProvinceSumAggregateOutputType | null
    _min: UserProvinceMinAggregateOutputType | null
    _max: UserProvinceMaxAggregateOutputType | null
  }

  export type UserProvinceAvgAggregateOutputType = {
    provinceId: number | null
  }

  export type UserProvinceSumAggregateOutputType = {
    provinceId: number | null
  }

  export type UserProvinceMinAggregateOutputType = {
    userId: string | null
    provinceId: number | null
  }

  export type UserProvinceMaxAggregateOutputType = {
    userId: string | null
    provinceId: number | null
  }

  export type UserProvinceCountAggregateOutputType = {
    userId: number
    provinceId: number
    _all: number
  }


  export type UserProvinceAvgAggregateInputType = {
    provinceId?: true
  }

  export type UserProvinceSumAggregateInputType = {
    provinceId?: true
  }

  export type UserProvinceMinAggregateInputType = {
    userId?: true
    provinceId?: true
  }

  export type UserProvinceMaxAggregateInputType = {
    userId?: true
    provinceId?: true
  }

  export type UserProvinceCountAggregateInputType = {
    userId?: true
    provinceId?: true
    _all?: true
  }

  export type UserProvinceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProvince to aggregate.
     */
    where?: UserProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProvinces to fetch.
     */
    orderBy?: UserProvinceOrderByWithRelationInput | UserProvinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProvinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProvinces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProvinces
    **/
    _count?: true | UserProvinceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProvinceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProvinceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProvinceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProvinceMaxAggregateInputType
  }

  export type GetUserProvinceAggregateType<T extends UserProvinceAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProvince]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProvince[P]>
      : GetScalarType<T[P], AggregateUserProvince[P]>
  }




  export type UserProvinceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProvinceWhereInput
    orderBy?: UserProvinceOrderByWithAggregationInput | UserProvinceOrderByWithAggregationInput[]
    by: UserProvinceScalarFieldEnum[] | UserProvinceScalarFieldEnum
    having?: UserProvinceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProvinceCountAggregateInputType | true
    _avg?: UserProvinceAvgAggregateInputType
    _sum?: UserProvinceSumAggregateInputType
    _min?: UserProvinceMinAggregateInputType
    _max?: UserProvinceMaxAggregateInputType
  }

  export type UserProvinceGroupByOutputType = {
    userId: string
    provinceId: number
    _count: UserProvinceCountAggregateOutputType | null
    _avg: UserProvinceAvgAggregateOutputType | null
    _sum: UserProvinceSumAggregateOutputType | null
    _min: UserProvinceMinAggregateOutputType | null
    _max: UserProvinceMaxAggregateOutputType | null
  }

  type GetUserProvinceGroupByPayload<T extends UserProvinceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProvinceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProvinceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProvinceGroupByOutputType[P]>
            : GetScalarType<T[P], UserProvinceGroupByOutputType[P]>
        }
      >
    >


  export type UserProvinceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    provinceId?: boolean
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProvince"]>

  export type UserProvinceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    provinceId?: boolean
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProvince"]>

  export type UserProvinceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    provinceId?: boolean
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProvince"]>

  export type UserProvinceSelectScalar = {
    userId?: boolean
    provinceId?: boolean
  }

  export type UserProvinceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "provinceId", ExtArgs["result"]["userProvince"]>
  export type UserProvinceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProvinceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProvinceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserProvincePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProvince"
    objects: {
      province: Prisma.$ProvincePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      provinceId: number
    }, ExtArgs["result"]["userProvince"]>
    composites: {}
  }

  type UserProvinceGetPayload<S extends boolean | null | undefined | UserProvinceDefaultArgs> = $Result.GetResult<Prisma.$UserProvincePayload, S>

  type UserProvinceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProvinceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProvinceCountAggregateInputType | true
    }

  export interface UserProvinceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProvince'], meta: { name: 'UserProvince' } }
    /**
     * Find zero or one UserProvince that matches the filter.
     * @param {UserProvinceFindUniqueArgs} args - Arguments to find a UserProvince
     * @example
     * // Get one UserProvince
     * const userProvince = await prisma.userProvince.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProvinceFindUniqueArgs>(args: SelectSubset<T, UserProvinceFindUniqueArgs<ExtArgs>>): Prisma__UserProvinceClient<$Result.GetResult<Prisma.$UserProvincePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserProvince that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProvinceFindUniqueOrThrowArgs} args - Arguments to find a UserProvince
     * @example
     * // Get one UserProvince
     * const userProvince = await prisma.userProvince.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProvinceFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProvinceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProvinceClient<$Result.GetResult<Prisma.$UserProvincePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserProvince that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProvinceFindFirstArgs} args - Arguments to find a UserProvince
     * @example
     * // Get one UserProvince
     * const userProvince = await prisma.userProvince.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProvinceFindFirstArgs>(args?: SelectSubset<T, UserProvinceFindFirstArgs<ExtArgs>>): Prisma__UserProvinceClient<$Result.GetResult<Prisma.$UserProvincePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserProvince that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProvinceFindFirstOrThrowArgs} args - Arguments to find a UserProvince
     * @example
     * // Get one UserProvince
     * const userProvince = await prisma.userProvince.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProvinceFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProvinceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProvinceClient<$Result.GetResult<Prisma.$UserProvincePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserProvinces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProvinceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProvinces
     * const userProvinces = await prisma.userProvince.findMany()
     * 
     * // Get first 10 UserProvinces
     * const userProvinces = await prisma.userProvince.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userProvinceWithUserIdOnly = await prisma.userProvince.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserProvinceFindManyArgs>(args?: SelectSubset<T, UserProvinceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProvincePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserProvince.
     * @param {UserProvinceCreateArgs} args - Arguments to create a UserProvince.
     * @example
     * // Create one UserProvince
     * const UserProvince = await prisma.userProvince.create({
     *   data: {
     *     // ... data to create a UserProvince
     *   }
     * })
     * 
     */
    create<T extends UserProvinceCreateArgs>(args: SelectSubset<T, UserProvinceCreateArgs<ExtArgs>>): Prisma__UserProvinceClient<$Result.GetResult<Prisma.$UserProvincePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserProvinces.
     * @param {UserProvinceCreateManyArgs} args - Arguments to create many UserProvinces.
     * @example
     * // Create many UserProvinces
     * const userProvince = await prisma.userProvince.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProvinceCreateManyArgs>(args?: SelectSubset<T, UserProvinceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProvinces and returns the data saved in the database.
     * @param {UserProvinceCreateManyAndReturnArgs} args - Arguments to create many UserProvinces.
     * @example
     * // Create many UserProvinces
     * const userProvince = await prisma.userProvince.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProvinces and only return the `userId`
     * const userProvinceWithUserIdOnly = await prisma.userProvince.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProvinceCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProvinceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProvincePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UserProvince.
     * @param {UserProvinceDeleteArgs} args - Arguments to delete one UserProvince.
     * @example
     * // Delete one UserProvince
     * const UserProvince = await prisma.userProvince.delete({
     *   where: {
     *     // ... filter to delete one UserProvince
     *   }
     * })
     * 
     */
    delete<T extends UserProvinceDeleteArgs>(args: SelectSubset<T, UserProvinceDeleteArgs<ExtArgs>>): Prisma__UserProvinceClient<$Result.GetResult<Prisma.$UserProvincePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserProvince.
     * @param {UserProvinceUpdateArgs} args - Arguments to update one UserProvince.
     * @example
     * // Update one UserProvince
     * const userProvince = await prisma.userProvince.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProvinceUpdateArgs>(args: SelectSubset<T, UserProvinceUpdateArgs<ExtArgs>>): Prisma__UserProvinceClient<$Result.GetResult<Prisma.$UserProvincePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserProvinces.
     * @param {UserProvinceDeleteManyArgs} args - Arguments to filter UserProvinces to delete.
     * @example
     * // Delete a few UserProvinces
     * const { count } = await prisma.userProvince.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProvinceDeleteManyArgs>(args?: SelectSubset<T, UserProvinceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProvinces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProvinceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProvinces
     * const userProvince = await prisma.userProvince.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProvinceUpdateManyArgs>(args: SelectSubset<T, UserProvinceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProvinces and returns the data updated in the database.
     * @param {UserProvinceUpdateManyAndReturnArgs} args - Arguments to update many UserProvinces.
     * @example
     * // Update many UserProvinces
     * const userProvince = await prisma.userProvince.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProvinces and only return the `userId`
     * const userProvinceWithUserIdOnly = await prisma.userProvince.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProvinceUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProvinceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProvincePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UserProvince.
     * @param {UserProvinceUpsertArgs} args - Arguments to update or create a UserProvince.
     * @example
     * // Update or create a UserProvince
     * const userProvince = await prisma.userProvince.upsert({
     *   create: {
     *     // ... data to create a UserProvince
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProvince we want to update
     *   }
     * })
     */
    upsert<T extends UserProvinceUpsertArgs>(args: SelectSubset<T, UserProvinceUpsertArgs<ExtArgs>>): Prisma__UserProvinceClient<$Result.GetResult<Prisma.$UserProvincePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserProvinces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProvinceCountArgs} args - Arguments to filter UserProvinces to count.
     * @example
     * // Count the number of UserProvinces
     * const count = await prisma.userProvince.count({
     *   where: {
     *     // ... the filter for the UserProvinces we want to count
     *   }
     * })
    **/
    count<T extends UserProvinceCountArgs>(
      args?: Subset<T, UserProvinceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProvinceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProvince.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProvinceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProvinceAggregateArgs>(args: Subset<T, UserProvinceAggregateArgs>): Prisma.PrismaPromise<GetUserProvinceAggregateType<T>>

    /**
     * Group by UserProvince.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProvinceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProvinceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProvinceGroupByArgs['orderBy'] }
        : { orderBy?: UserProvinceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProvinceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProvinceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProvince model
   */
  readonly fields: UserProvinceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProvince.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProvinceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    province<T extends ProvinceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvinceDefaultArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProvince model
   */ 
  interface UserProvinceFieldRefs {
    readonly userId: FieldRef<"UserProvince", 'String'>
    readonly provinceId: FieldRef<"UserProvince", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserProvince findUnique
   */
  export type UserProvinceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProvince
     */
    select?: UserProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProvince
     */
    omit?: UserProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProvinceInclude<ExtArgs> | null
    /**
     * Filter, which UserProvince to fetch.
     */
    where: UserProvinceWhereUniqueInput
  }

  /**
   * UserProvince findUniqueOrThrow
   */
  export type UserProvinceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProvince
     */
    select?: UserProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProvince
     */
    omit?: UserProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProvinceInclude<ExtArgs> | null
    /**
     * Filter, which UserProvince to fetch.
     */
    where: UserProvinceWhereUniqueInput
  }

  /**
   * UserProvince findFirst
   */
  export type UserProvinceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProvince
     */
    select?: UserProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProvince
     */
    omit?: UserProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProvinceInclude<ExtArgs> | null
    /**
     * Filter, which UserProvince to fetch.
     */
    where?: UserProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProvinces to fetch.
     */
    orderBy?: UserProvinceOrderByWithRelationInput | UserProvinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProvinces.
     */
    cursor?: UserProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProvinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProvinces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProvinces.
     */
    distinct?: UserProvinceScalarFieldEnum | UserProvinceScalarFieldEnum[]
  }

  /**
   * UserProvince findFirstOrThrow
   */
  export type UserProvinceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProvince
     */
    select?: UserProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProvince
     */
    omit?: UserProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProvinceInclude<ExtArgs> | null
    /**
     * Filter, which UserProvince to fetch.
     */
    where?: UserProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProvinces to fetch.
     */
    orderBy?: UserProvinceOrderByWithRelationInput | UserProvinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProvinces.
     */
    cursor?: UserProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProvinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProvinces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProvinces.
     */
    distinct?: UserProvinceScalarFieldEnum | UserProvinceScalarFieldEnum[]
  }

  /**
   * UserProvince findMany
   */
  export type UserProvinceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProvince
     */
    select?: UserProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProvince
     */
    omit?: UserProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProvinceInclude<ExtArgs> | null
    /**
     * Filter, which UserProvinces to fetch.
     */
    where?: UserProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProvinces to fetch.
     */
    orderBy?: UserProvinceOrderByWithRelationInput | UserProvinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProvinces.
     */
    cursor?: UserProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProvinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProvinces.
     */
    skip?: number
    distinct?: UserProvinceScalarFieldEnum | UserProvinceScalarFieldEnum[]
  }

  /**
   * UserProvince create
   */
  export type UserProvinceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProvince
     */
    select?: UserProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProvince
     */
    omit?: UserProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProvinceInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProvince.
     */
    data: XOR<UserProvinceCreateInput, UserProvinceUncheckedCreateInput>
  }

  /**
   * UserProvince createMany
   */
  export type UserProvinceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProvinces.
     */
    data: UserProvinceCreateManyInput | UserProvinceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProvince createManyAndReturn
   */
  export type UserProvinceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProvince
     */
    select?: UserProvinceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProvince
     */
    omit?: UserProvinceOmit<ExtArgs> | null
    /**
     * The data used to create many UserProvinces.
     */
    data: UserProvinceCreateManyInput | UserProvinceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProvinceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProvince update
   */
  export type UserProvinceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProvince
     */
    select?: UserProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProvince
     */
    omit?: UserProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProvinceInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProvince.
     */
    data: XOR<UserProvinceUpdateInput, UserProvinceUncheckedUpdateInput>
    /**
     * Choose, which UserProvince to update.
     */
    where: UserProvinceWhereUniqueInput
  }

  /**
   * UserProvince updateMany
   */
  export type UserProvinceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProvinces.
     */
    data: XOR<UserProvinceUpdateManyMutationInput, UserProvinceUncheckedUpdateManyInput>
    /**
     * Filter which UserProvinces to update
     */
    where?: UserProvinceWhereInput
    /**
     * Limit how many UserProvinces to update.
     */
    limit?: number
  }

  /**
   * UserProvince updateManyAndReturn
   */
  export type UserProvinceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProvince
     */
    select?: UserProvinceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProvince
     */
    omit?: UserProvinceOmit<ExtArgs> | null
    /**
     * The data used to update UserProvinces.
     */
    data: XOR<UserProvinceUpdateManyMutationInput, UserProvinceUncheckedUpdateManyInput>
    /**
     * Filter which UserProvinces to update
     */
    where?: UserProvinceWhereInput
    /**
     * Limit how many UserProvinces to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProvinceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProvince upsert
   */
  export type UserProvinceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProvince
     */
    select?: UserProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProvince
     */
    omit?: UserProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProvinceInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProvince to update in case it exists.
     */
    where: UserProvinceWhereUniqueInput
    /**
     * In case the UserProvince found by the `where` argument doesn't exist, create a new UserProvince with this data.
     */
    create: XOR<UserProvinceCreateInput, UserProvinceUncheckedCreateInput>
    /**
     * In case the UserProvince was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProvinceUpdateInput, UserProvinceUncheckedUpdateInput>
  }

  /**
   * UserProvince delete
   */
  export type UserProvinceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProvince
     */
    select?: UserProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProvince
     */
    omit?: UserProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProvinceInclude<ExtArgs> | null
    /**
     * Filter which UserProvince to delete.
     */
    where: UserProvinceWhereUniqueInput
  }

  /**
   * UserProvince deleteMany
   */
  export type UserProvinceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProvinces to delete
     */
    where?: UserProvinceWhereInput
    /**
     * Limit how many UserProvinces to delete.
     */
    limit?: number
  }

  /**
   * UserProvince without action
   */
  export type UserProvinceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProvince
     */
    select?: UserProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProvince
     */
    omit?: UserProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProvinceInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenAvgAggregateOutputType = {
    id: number | null
  }

  export type RefreshTokenSumAggregateOutputType = {
    id: number | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: number | null
    token: string | null
    email: string | null
    revoked: boolean | null
    expiresAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: number | null
    token: string | null
    email: string | null
    revoked: boolean | null
    expiresAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    token: number
    email: number
    revoked: number
    expiresAt: number
    _all: number
  }


  export type RefreshTokenAvgAggregateInputType = {
    id?: true
  }

  export type RefreshTokenSumAggregateInputType = {
    id?: true
  }

  export type RefreshTokenMinAggregateInputType = {
    id?: true
    token?: true
    email?: true
    revoked?: true
    expiresAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    token?: true
    email?: true
    revoked?: true
    expiresAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    token?: true
    email?: true
    revoked?: true
    expiresAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefreshTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefreshTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _avg?: RefreshTokenAvgAggregateInputType
    _sum?: RefreshTokenSumAggregateInputType
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: number
    token: string
    email: string
    revoked: boolean
    expiresAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    email?: boolean
    revoked?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    email?: boolean
    revoked?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    email?: boolean
    revoked?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    token?: boolean
    email?: boolean
    revoked?: boolean
    expiresAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "email" | "revoked" | "expiresAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      email: string
      revoked: boolean
      expiresAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */ 
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'Int'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly email: FieldRef<"RefreshToken", 'String'>
    readonly revoked: FieldRef<"RefreshToken", 'Boolean'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Otp
   */

  export type AggregateOtp = {
    _count: OtpCountAggregateOutputType | null
    _avg: OtpAvgAggregateOutputType | null
    _sum: OtpSumAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  export type OtpAvgAggregateOutputType = {
    attempts: number | null
  }

  export type OtpSumAggregateOutputType = {
    attempts: number | null
  }

  export type OtpMinAggregateOutputType = {
    id: string | null
    email: string | null
    otp: string | null
    type: $Enums.OTPType | null
    expiresAt: Date | null
    isUsed: boolean | null
    createdAt: Date | null
    attempts: number | null
    requestToken: string | null
  }

  export type OtpMaxAggregateOutputType = {
    id: string | null
    email: string | null
    otp: string | null
    type: $Enums.OTPType | null
    expiresAt: Date | null
    isUsed: boolean | null
    createdAt: Date | null
    attempts: number | null
    requestToken: string | null
  }

  export type OtpCountAggregateOutputType = {
    id: number
    email: number
    otp: number
    type: number
    expiresAt: number
    isUsed: number
    createdAt: number
    attempts: number
    requestToken: number
    _all: number
  }


  export type OtpAvgAggregateInputType = {
    attempts?: true
  }

  export type OtpSumAggregateInputType = {
    attempts?: true
  }

  export type OtpMinAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    type?: true
    expiresAt?: true
    isUsed?: true
    createdAt?: true
    attempts?: true
    requestToken?: true
  }

  export type OtpMaxAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    type?: true
    expiresAt?: true
    isUsed?: true
    createdAt?: true
    attempts?: true
    requestToken?: true
  }

  export type OtpCountAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    type?: true
    expiresAt?: true
    isUsed?: true
    createdAt?: true
    attempts?: true
    requestToken?: true
    _all?: true
  }

  export type OtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otp to aggregate.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Otps
    **/
    _count?: true | OtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OtpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OtpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpMaxAggregateInputType
  }

  export type GetOtpAggregateType<T extends OtpAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp[P]>
      : GetScalarType<T[P], AggregateOtp[P]>
  }




  export type OtpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
    orderBy?: OtpOrderByWithAggregationInput | OtpOrderByWithAggregationInput[]
    by: OtpScalarFieldEnum[] | OtpScalarFieldEnum
    having?: OtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCountAggregateInputType | true
    _avg?: OtpAvgAggregateInputType
    _sum?: OtpSumAggregateInputType
    _min?: OtpMinAggregateInputType
    _max?: OtpMaxAggregateInputType
  }

  export type OtpGroupByOutputType = {
    id: string
    email: string
    otp: string
    type: $Enums.OTPType
    expiresAt: Date
    isUsed: boolean
    createdAt: Date
    attempts: number
    requestToken: string
    _count: OtpCountAggregateOutputType | null
    _avg: OtpAvgAggregateOutputType | null
    _sum: OtpSumAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  type GetOtpGroupByPayload<T extends OtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpGroupByOutputType[P]>
            : GetScalarType<T[P], OtpGroupByOutputType[P]>
        }
      >
    >


  export type OtpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    type?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    createdAt?: boolean
    attempts?: boolean
    requestToken?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    type?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    createdAt?: boolean
    attempts?: boolean
    requestToken?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    type?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    createdAt?: boolean
    attempts?: boolean
    requestToken?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectScalar = {
    id?: boolean
    email?: boolean
    otp?: boolean
    type?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    createdAt?: boolean
    attempts?: boolean
    requestToken?: boolean
  }

  export type OtpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "otp" | "type" | "expiresAt" | "isUsed" | "createdAt" | "attempts" | "requestToken", ExtArgs["result"]["otp"]>

  export type $OtpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Otp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      otp: string
      type: $Enums.OTPType
      expiresAt: Date
      isUsed: boolean
      createdAt: Date
      attempts: number
      requestToken: string
    }, ExtArgs["result"]["otp"]>
    composites: {}
  }

  type OtpGetPayload<S extends boolean | null | undefined | OtpDefaultArgs> = $Result.GetResult<Prisma.$OtpPayload, S>

  type OtpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OtpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OtpCountAggregateInputType | true
    }

  export interface OtpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Otp'], meta: { name: 'Otp' } }
    /**
     * Find zero or one Otp that matches the filter.
     * @param {OtpFindUniqueArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtpFindUniqueArgs>(args: SelectSubset<T, OtpFindUniqueArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Otp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OtpFindUniqueOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtpFindUniqueOrThrowArgs>(args: SelectSubset<T, OtpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtpFindFirstArgs>(args?: SelectSubset<T, OtpFindFirstArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Otp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtpFindFirstOrThrowArgs>(args?: SelectSubset<T, OtpFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otp.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpWithIdOnly = await prisma.otp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtpFindManyArgs>(args?: SelectSubset<T, OtpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Otp.
     * @param {OtpCreateArgs} args - Arguments to create a Otp.
     * @example
     * // Create one Otp
     * const Otp = await prisma.otp.create({
     *   data: {
     *     // ... data to create a Otp
     *   }
     * })
     * 
     */
    create<T extends OtpCreateArgs>(args: SelectSubset<T, OtpCreateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Otps.
     * @param {OtpCreateManyArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtpCreateManyArgs>(args?: SelectSubset<T, OtpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Otps and returns the data saved in the database.
     * @param {OtpCreateManyAndReturnArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Otps and only return the `id`
     * const otpWithIdOnly = await prisma.otp.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OtpCreateManyAndReturnArgs>(args?: SelectSubset<T, OtpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Otp.
     * @param {OtpDeleteArgs} args - Arguments to delete one Otp.
     * @example
     * // Delete one Otp
     * const Otp = await prisma.otp.delete({
     *   where: {
     *     // ... filter to delete one Otp
     *   }
     * })
     * 
     */
    delete<T extends OtpDeleteArgs>(args: SelectSubset<T, OtpDeleteArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Otp.
     * @param {OtpUpdateArgs} args - Arguments to update one Otp.
     * @example
     * // Update one Otp
     * const otp = await prisma.otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtpUpdateArgs>(args: SelectSubset<T, OtpUpdateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Otps.
     * @param {OtpDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtpDeleteManyArgs>(args?: SelectSubset<T, OtpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtpUpdateManyArgs>(args: SelectSubset<T, OtpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps and returns the data updated in the database.
     * @param {OtpUpdateManyAndReturnArgs} args - Arguments to update many Otps.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Otps and only return the `id`
     * const otpWithIdOnly = await prisma.otp.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OtpUpdateManyAndReturnArgs>(args: SelectSubset<T, OtpUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Otp.
     * @param {OtpUpsertArgs} args - Arguments to update or create a Otp.
     * @example
     * // Update or create a Otp
     * const otp = await prisma.otp.upsert({
     *   create: {
     *     // ... data to create a Otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp we want to update
     *   }
     * })
     */
    upsert<T extends OtpUpsertArgs>(args: SelectSubset<T, OtpUpsertArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otp.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends OtpCountArgs>(
      args?: Subset<T, OtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAggregateArgs>(args: Subset<T, OtpAggregateArgs>): Prisma.PrismaPromise<GetOtpAggregateType<T>>

    /**
     * Group by Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpGroupByArgs['orderBy'] }
        : { orderBy?: OtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Otp model
   */
  readonly fields: OtpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Otp model
   */ 
  interface OtpFieldRefs {
    readonly id: FieldRef<"Otp", 'String'>
    readonly email: FieldRef<"Otp", 'String'>
    readonly otp: FieldRef<"Otp", 'String'>
    readonly type: FieldRef<"Otp", 'OTPType'>
    readonly expiresAt: FieldRef<"Otp", 'DateTime'>
    readonly isUsed: FieldRef<"Otp", 'Boolean'>
    readonly createdAt: FieldRef<"Otp", 'DateTime'>
    readonly attempts: FieldRef<"Otp", 'Int'>
    readonly requestToken: FieldRef<"Otp", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Otp findUnique
   */
  export type OtpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findUniqueOrThrow
   */
  export type OtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findFirst
   */
  export type OtpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findFirstOrThrow
   */
  export type OtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findMany
   */
  export type OtpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otps to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp create
   */
  export type OtpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data needed to create a Otp.
     */
    data: XOR<OtpCreateInput, OtpUncheckedCreateInput>
  }

  /**
   * Otp createMany
   */
  export type OtpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Otps.
     */
    data: OtpCreateManyInput | OtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Otp createManyAndReturn
   */
  export type OtpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data used to create many Otps.
     */
    data: OtpCreateManyInput | OtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Otp update
   */
  export type OtpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data needed to update a Otp.
     */
    data: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
    /**
     * Choose, which Otp to update.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp updateMany
   */
  export type OtpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to update.
     */
    limit?: number
  }

  /**
   * Otp updateManyAndReturn
   */
  export type OtpUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to update.
     */
    limit?: number
  }

  /**
   * Otp upsert
   */
  export type OtpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The filter to search for the Otp to update in case it exists.
     */
    where: OtpWhereUniqueInput
    /**
     * In case the Otp found by the `where` argument doesn't exist, create a new Otp with this data.
     */
    create: XOR<OtpCreateInput, OtpUncheckedCreateInput>
    /**
     * In case the Otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
  }

  /**
   * Otp delete
   */
  export type OtpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter which Otp to delete.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp deleteMany
   */
  export type OtpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otps to delete
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to delete.
     */
    limit?: number
  }

  /**
   * Otp without action
   */
  export type OtpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
  }


  /**
   * Model Categories
   */

  export type AggregateCategories = {
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  export type CategoriesAvgAggregateOutputType = {
    id: number | null
  }

  export type CategoriesSumAggregateOutputType = {
    id: number | null
  }

  export type CategoriesMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
  }

  export type CategoriesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
  }

  export type CategoriesCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    _all: number
  }


  export type CategoriesAvgAggregateInputType = {
    id?: true
  }

  export type CategoriesSumAggregateInputType = {
    id?: true
  }

  export type CategoriesMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type CategoriesMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type CategoriesCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type CategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to aggregate.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriesMaxAggregateInputType
  }

  export type GetCategoriesAggregateType<T extends CategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategories[P]>
      : GetScalarType<T[P], AggregateCategories[P]>
  }




  export type CategoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriesWhereInput
    orderBy?: CategoriesOrderByWithAggregationInput | CategoriesOrderByWithAggregationInput[]
    by: CategoriesScalarFieldEnum[] | CategoriesScalarFieldEnum
    having?: CategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriesCountAggregateInputType | true
    _avg?: CategoriesAvgAggregateInputType
    _sum?: CategoriesSumAggregateInputType
    _min?: CategoriesMinAggregateInputType
    _max?: CategoriesMaxAggregateInputType
  }

  export type CategoriesGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  type GetCategoriesGroupByPayload<T extends CategoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
        }
      >
    >


  export type CategoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    EventCategories?: boolean | Categories$EventCategoriesArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>

  export type CategoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["categories"]>

  export type CategoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["categories"]>

  export type CategoriesSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type CategoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt", ExtArgs["result"]["categories"]>
  export type CategoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EventCategories?: boolean | Categories$EventCategoriesArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Categories"
    objects: {
      EventCategories: Prisma.$EventCategoriesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
    }, ExtArgs["result"]["categories"]>
    composites: {}
  }

  type CategoriesGetPayload<S extends boolean | null | undefined | CategoriesDefaultArgs> = $Result.GetResult<Prisma.$CategoriesPayload, S>

  type CategoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriesCountAggregateInputType | true
    }

  export interface CategoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Categories'], meta: { name: 'Categories' } }
    /**
     * Find zero or one Categories that matches the filter.
     * @param {CategoriesFindUniqueArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoriesFindUniqueArgs>(args: SelectSubset<T, CategoriesFindUniqueArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoriesFindUniqueOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesFindFirstArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoriesFindFirstArgs>(args?: SelectSubset<T, CategoriesFindFirstArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesFindFirstOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.categories.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriesWithIdOnly = await prisma.categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoriesFindManyArgs>(args?: SelectSubset<T, CategoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Categories.
     * @param {CategoriesCreateArgs} args - Arguments to create a Categories.
     * @example
     * // Create one Categories
     * const Categories = await prisma.categories.create({
     *   data: {
     *     // ... data to create a Categories
     *   }
     * })
     * 
     */
    create<T extends CategoriesCreateArgs>(args: SelectSubset<T, CategoriesCreateArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Categories.
     * @param {CategoriesCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoriesCreateManyArgs>(args?: SelectSubset<T, CategoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoriesCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoriesWithIdOnly = await prisma.categories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Categories.
     * @param {CategoriesDeleteArgs} args - Arguments to delete one Categories.
     * @example
     * // Delete one Categories
     * const Categories = await prisma.categories.delete({
     *   where: {
     *     // ... filter to delete one Categories
     *   }
     * })
     * 
     */
    delete<T extends CategoriesDeleteArgs>(args: SelectSubset<T, CategoriesDeleteArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Categories.
     * @param {CategoriesUpdateArgs} args - Arguments to update one Categories.
     * @example
     * // Update one Categories
     * const categories = await prisma.categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoriesUpdateArgs>(args: SelectSubset<T, CategoriesUpdateArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoriesDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoriesDeleteManyArgs>(args?: SelectSubset<T, CategoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoriesUpdateManyArgs>(args: SelectSubset<T, CategoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoriesUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoriesWithIdOnly = await prisma.categories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Categories.
     * @param {CategoriesUpsertArgs} args - Arguments to update or create a Categories.
     * @example
     * // Update or create a Categories
     * const categories = await prisma.categories.upsert({
     *   create: {
     *     // ... data to create a Categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categories we want to update
     *   }
     * })
     */
    upsert<T extends CategoriesUpsertArgs>(args: SelectSubset<T, CategoriesUpsertArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.categories.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoriesCountArgs>(
      args?: Subset<T, CategoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriesAggregateArgs>(args: Subset<T, CategoriesAggregateArgs>): Prisma.PrismaPromise<GetCategoriesAggregateType<T>>

    /**
     * Group by Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriesGroupByArgs['orderBy'] }
        : { orderBy?: CategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Categories model
   */
  readonly fields: CategoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    EventCategories<T extends Categories$EventCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Categories$EventCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCategoriesPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Categories model
   */ 
  interface CategoriesFieldRefs {
    readonly id: FieldRef<"Categories", 'Int'>
    readonly name: FieldRef<"Categories", 'String'>
    readonly createdAt: FieldRef<"Categories", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Categories findUnique
   */
  export type CategoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories findUniqueOrThrow
   */
  export type CategoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories findFirst
   */
  export type CategoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * Categories findFirstOrThrow
   */
  export type CategoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * Categories findMany
   */
  export type CategoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * Categories create
   */
  export type CategoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a Categories.
     */
    data: XOR<CategoriesCreateInput, CategoriesUncheckedCreateInput>
  }

  /**
   * Categories createMany
   */
  export type CategoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoriesCreateManyInput | CategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Categories createManyAndReturn
   */
  export type CategoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoriesCreateManyInput | CategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Categories update
   */
  export type CategoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a Categories.
     */
    data: XOR<CategoriesUpdateInput, CategoriesUncheckedUpdateInput>
    /**
     * Choose, which Categories to update.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories updateMany
   */
  export type CategoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoriesUpdateManyMutationInput, CategoriesUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoriesWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Categories updateManyAndReturn
   */
  export type CategoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoriesUpdateManyMutationInput, CategoriesUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoriesWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Categories upsert
   */
  export type CategoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the Categories to update in case it exists.
     */
    where: CategoriesWhereUniqueInput
    /**
     * In case the Categories found by the `where` argument doesn't exist, create a new Categories with this data.
     */
    create: XOR<CategoriesCreateInput, CategoriesUncheckedCreateInput>
    /**
     * In case the Categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoriesUpdateInput, CategoriesUncheckedUpdateInput>
  }

  /**
   * Categories delete
   */
  export type CategoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter which Categories to delete.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories deleteMany
   */
  export type CategoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoriesWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Categories.EventCategories
   */
  export type Categories$EventCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategories
     */
    select?: EventCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCategories
     */
    omit?: EventCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoriesInclude<ExtArgs> | null
    where?: EventCategoriesWhereInput
    orderBy?: EventCategoriesOrderByWithRelationInput | EventCategoriesOrderByWithRelationInput[]
    cursor?: EventCategoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventCategoriesScalarFieldEnum | EventCategoriesScalarFieldEnum[]
  }

  /**
   * Categories without action
   */
  export type CategoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
  }


  /**
   * Model EventCategories
   */

  export type AggregateEventCategories = {
    _count: EventCategoriesCountAggregateOutputType | null
    _avg: EventCategoriesAvgAggregateOutputType | null
    _sum: EventCategoriesSumAggregateOutputType | null
    _min: EventCategoriesMinAggregateOutputType | null
    _max: EventCategoriesMaxAggregateOutputType | null
  }

  export type EventCategoriesAvgAggregateOutputType = {
    id: number | null
    eventId: number | null
    categoryId: number | null
  }

  export type EventCategoriesSumAggregateOutputType = {
    id: number | null
    eventId: number | null
    categoryId: number | null
  }

  export type EventCategoriesMinAggregateOutputType = {
    id: number | null
    eventId: number | null
    categoryId: number | null
    isSpecial: boolean | null
  }

  export type EventCategoriesMaxAggregateOutputType = {
    id: number | null
    eventId: number | null
    categoryId: number | null
    isSpecial: boolean | null
  }

  export type EventCategoriesCountAggregateOutputType = {
    id: number
    eventId: number
    categoryId: number
    isSpecial: number
    _all: number
  }


  export type EventCategoriesAvgAggregateInputType = {
    id?: true
    eventId?: true
    categoryId?: true
  }

  export type EventCategoriesSumAggregateInputType = {
    id?: true
    eventId?: true
    categoryId?: true
  }

  export type EventCategoriesMinAggregateInputType = {
    id?: true
    eventId?: true
    categoryId?: true
    isSpecial?: true
  }

  export type EventCategoriesMaxAggregateInputType = {
    id?: true
    eventId?: true
    categoryId?: true
    isSpecial?: true
  }

  export type EventCategoriesCountAggregateInputType = {
    id?: true
    eventId?: true
    categoryId?: true
    isSpecial?: true
    _all?: true
  }

  export type EventCategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventCategories to aggregate.
     */
    where?: EventCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCategories to fetch.
     */
    orderBy?: EventCategoriesOrderByWithRelationInput | EventCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventCategories
    **/
    _count?: true | EventCategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventCategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventCategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventCategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventCategoriesMaxAggregateInputType
  }

  export type GetEventCategoriesAggregateType<T extends EventCategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateEventCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventCategories[P]>
      : GetScalarType<T[P], AggregateEventCategories[P]>
  }




  export type EventCategoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventCategoriesWhereInput
    orderBy?: EventCategoriesOrderByWithAggregationInput | EventCategoriesOrderByWithAggregationInput[]
    by: EventCategoriesScalarFieldEnum[] | EventCategoriesScalarFieldEnum
    having?: EventCategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCategoriesCountAggregateInputType | true
    _avg?: EventCategoriesAvgAggregateInputType
    _sum?: EventCategoriesSumAggregateInputType
    _min?: EventCategoriesMinAggregateInputType
    _max?: EventCategoriesMaxAggregateInputType
  }

  export type EventCategoriesGroupByOutputType = {
    id: number
    eventId: number
    categoryId: number
    isSpecial: boolean
    _count: EventCategoriesCountAggregateOutputType | null
    _avg: EventCategoriesAvgAggregateOutputType | null
    _sum: EventCategoriesSumAggregateOutputType | null
    _min: EventCategoriesMinAggregateOutputType | null
    _max: EventCategoriesMaxAggregateOutputType | null
  }

  type GetEventCategoriesGroupByPayload<T extends EventCategoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventCategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventCategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventCategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], EventCategoriesGroupByOutputType[P]>
        }
      >
    >


  export type EventCategoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    categoryId?: boolean
    isSpecial?: boolean
    Categories?: boolean | CategoriesDefaultArgs<ExtArgs>
    Events?: boolean | EventsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventCategories"]>

  export type EventCategoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    categoryId?: boolean
    isSpecial?: boolean
    Categories?: boolean | CategoriesDefaultArgs<ExtArgs>
    Events?: boolean | EventsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventCategories"]>

  export type EventCategoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    categoryId?: boolean
    isSpecial?: boolean
    Categories?: boolean | CategoriesDefaultArgs<ExtArgs>
    Events?: boolean | EventsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventCategories"]>

  export type EventCategoriesSelectScalar = {
    id?: boolean
    eventId?: boolean
    categoryId?: boolean
    isSpecial?: boolean
  }

  export type EventCategoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "categoryId" | "isSpecial", ExtArgs["result"]["eventCategories"]>
  export type EventCategoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Categories?: boolean | CategoriesDefaultArgs<ExtArgs>
    Events?: boolean | EventsDefaultArgs<ExtArgs>
  }
  export type EventCategoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Categories?: boolean | CategoriesDefaultArgs<ExtArgs>
    Events?: boolean | EventsDefaultArgs<ExtArgs>
  }
  export type EventCategoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Categories?: boolean | CategoriesDefaultArgs<ExtArgs>
    Events?: boolean | EventsDefaultArgs<ExtArgs>
  }

  export type $EventCategoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventCategories"
    objects: {
      Categories: Prisma.$CategoriesPayload<ExtArgs>
      Events: Prisma.$EventsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      eventId: number
      categoryId: number
      isSpecial: boolean
    }, ExtArgs["result"]["eventCategories"]>
    composites: {}
  }

  type EventCategoriesGetPayload<S extends boolean | null | undefined | EventCategoriesDefaultArgs> = $Result.GetResult<Prisma.$EventCategoriesPayload, S>

  type EventCategoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventCategoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCategoriesCountAggregateInputType | true
    }

  export interface EventCategoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventCategories'], meta: { name: 'EventCategories' } }
    /**
     * Find zero or one EventCategories that matches the filter.
     * @param {EventCategoriesFindUniqueArgs} args - Arguments to find a EventCategories
     * @example
     * // Get one EventCategories
     * const eventCategories = await prisma.eventCategories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventCategoriesFindUniqueArgs>(args: SelectSubset<T, EventCategoriesFindUniqueArgs<ExtArgs>>): Prisma__EventCategoriesClient<$Result.GetResult<Prisma.$EventCategoriesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one EventCategories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventCategoriesFindUniqueOrThrowArgs} args - Arguments to find a EventCategories
     * @example
     * // Get one EventCategories
     * const eventCategories = await prisma.eventCategories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventCategoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, EventCategoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventCategoriesClient<$Result.GetResult<Prisma.$EventCategoriesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first EventCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoriesFindFirstArgs} args - Arguments to find a EventCategories
     * @example
     * // Get one EventCategories
     * const eventCategories = await prisma.eventCategories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventCategoriesFindFirstArgs>(args?: SelectSubset<T, EventCategoriesFindFirstArgs<ExtArgs>>): Prisma__EventCategoriesClient<$Result.GetResult<Prisma.$EventCategoriesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first EventCategories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoriesFindFirstOrThrowArgs} args - Arguments to find a EventCategories
     * @example
     * // Get one EventCategories
     * const eventCategories = await prisma.eventCategories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventCategoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, EventCategoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventCategoriesClient<$Result.GetResult<Prisma.$EventCategoriesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more EventCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventCategories
     * const eventCategories = await prisma.eventCategories.findMany()
     * 
     * // Get first 10 EventCategories
     * const eventCategories = await prisma.eventCategories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventCategoriesWithIdOnly = await prisma.eventCategories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventCategoriesFindManyArgs>(args?: SelectSubset<T, EventCategoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCategoriesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a EventCategories.
     * @param {EventCategoriesCreateArgs} args - Arguments to create a EventCategories.
     * @example
     * // Create one EventCategories
     * const EventCategories = await prisma.eventCategories.create({
     *   data: {
     *     // ... data to create a EventCategories
     *   }
     * })
     * 
     */
    create<T extends EventCategoriesCreateArgs>(args: SelectSubset<T, EventCategoriesCreateArgs<ExtArgs>>): Prisma__EventCategoriesClient<$Result.GetResult<Prisma.$EventCategoriesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many EventCategories.
     * @param {EventCategoriesCreateManyArgs} args - Arguments to create many EventCategories.
     * @example
     * // Create many EventCategories
     * const eventCategories = await prisma.eventCategories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCategoriesCreateManyArgs>(args?: SelectSubset<T, EventCategoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventCategories and returns the data saved in the database.
     * @param {EventCategoriesCreateManyAndReturnArgs} args - Arguments to create many EventCategories.
     * @example
     * // Create many EventCategories
     * const eventCategories = await prisma.eventCategories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventCategories and only return the `id`
     * const eventCategoriesWithIdOnly = await prisma.eventCategories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCategoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCategoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCategoriesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a EventCategories.
     * @param {EventCategoriesDeleteArgs} args - Arguments to delete one EventCategories.
     * @example
     * // Delete one EventCategories
     * const EventCategories = await prisma.eventCategories.delete({
     *   where: {
     *     // ... filter to delete one EventCategories
     *   }
     * })
     * 
     */
    delete<T extends EventCategoriesDeleteArgs>(args: SelectSubset<T, EventCategoriesDeleteArgs<ExtArgs>>): Prisma__EventCategoriesClient<$Result.GetResult<Prisma.$EventCategoriesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one EventCategories.
     * @param {EventCategoriesUpdateArgs} args - Arguments to update one EventCategories.
     * @example
     * // Update one EventCategories
     * const eventCategories = await prisma.eventCategories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventCategoriesUpdateArgs>(args: SelectSubset<T, EventCategoriesUpdateArgs<ExtArgs>>): Prisma__EventCategoriesClient<$Result.GetResult<Prisma.$EventCategoriesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more EventCategories.
     * @param {EventCategoriesDeleteManyArgs} args - Arguments to filter EventCategories to delete.
     * @example
     * // Delete a few EventCategories
     * const { count } = await prisma.eventCategories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventCategoriesDeleteManyArgs>(args?: SelectSubset<T, EventCategoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventCategories
     * const eventCategories = await prisma.eventCategories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventCategoriesUpdateManyArgs>(args: SelectSubset<T, EventCategoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventCategories and returns the data updated in the database.
     * @param {EventCategoriesUpdateManyAndReturnArgs} args - Arguments to update many EventCategories.
     * @example
     * // Update many EventCategories
     * const eventCategories = await prisma.eventCategories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventCategories and only return the `id`
     * const eventCategoriesWithIdOnly = await prisma.eventCategories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventCategoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, EventCategoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCategoriesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one EventCategories.
     * @param {EventCategoriesUpsertArgs} args - Arguments to update or create a EventCategories.
     * @example
     * // Update or create a EventCategories
     * const eventCategories = await prisma.eventCategories.upsert({
     *   create: {
     *     // ... data to create a EventCategories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventCategories we want to update
     *   }
     * })
     */
    upsert<T extends EventCategoriesUpsertArgs>(args: SelectSubset<T, EventCategoriesUpsertArgs<ExtArgs>>): Prisma__EventCategoriesClient<$Result.GetResult<Prisma.$EventCategoriesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of EventCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoriesCountArgs} args - Arguments to filter EventCategories to count.
     * @example
     * // Count the number of EventCategories
     * const count = await prisma.eventCategories.count({
     *   where: {
     *     // ... the filter for the EventCategories we want to count
     *   }
     * })
    **/
    count<T extends EventCategoriesCountArgs>(
      args?: Subset<T, EventCategoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventCategoriesAggregateArgs>(args: Subset<T, EventCategoriesAggregateArgs>): Prisma.PrismaPromise<GetEventCategoriesAggregateType<T>>

    /**
     * Group by EventCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventCategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventCategoriesGroupByArgs['orderBy'] }
        : { orderBy?: EventCategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventCategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventCategories model
   */
  readonly fields: EventCategoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventCategories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventCategoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Categories<T extends CategoriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoriesDefaultArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Events<T extends EventsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventsDefaultArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventCategories model
   */ 
  interface EventCategoriesFieldRefs {
    readonly id: FieldRef<"EventCategories", 'Int'>
    readonly eventId: FieldRef<"EventCategories", 'Int'>
    readonly categoryId: FieldRef<"EventCategories", 'Int'>
    readonly isSpecial: FieldRef<"EventCategories", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * EventCategories findUnique
   */
  export type EventCategoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategories
     */
    select?: EventCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCategories
     */
    omit?: EventCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which EventCategories to fetch.
     */
    where: EventCategoriesWhereUniqueInput
  }

  /**
   * EventCategories findUniqueOrThrow
   */
  export type EventCategoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategories
     */
    select?: EventCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCategories
     */
    omit?: EventCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which EventCategories to fetch.
     */
    where: EventCategoriesWhereUniqueInput
  }

  /**
   * EventCategories findFirst
   */
  export type EventCategoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategories
     */
    select?: EventCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCategories
     */
    omit?: EventCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which EventCategories to fetch.
     */
    where?: EventCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCategories to fetch.
     */
    orderBy?: EventCategoriesOrderByWithRelationInput | EventCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventCategories.
     */
    cursor?: EventCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventCategories.
     */
    distinct?: EventCategoriesScalarFieldEnum | EventCategoriesScalarFieldEnum[]
  }

  /**
   * EventCategories findFirstOrThrow
   */
  export type EventCategoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategories
     */
    select?: EventCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCategories
     */
    omit?: EventCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which EventCategories to fetch.
     */
    where?: EventCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCategories to fetch.
     */
    orderBy?: EventCategoriesOrderByWithRelationInput | EventCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventCategories.
     */
    cursor?: EventCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventCategories.
     */
    distinct?: EventCategoriesScalarFieldEnum | EventCategoriesScalarFieldEnum[]
  }

  /**
   * EventCategories findMany
   */
  export type EventCategoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategories
     */
    select?: EventCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCategories
     */
    omit?: EventCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which EventCategories to fetch.
     */
    where?: EventCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCategories to fetch.
     */
    orderBy?: EventCategoriesOrderByWithRelationInput | EventCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventCategories.
     */
    cursor?: EventCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCategories.
     */
    skip?: number
    distinct?: EventCategoriesScalarFieldEnum | EventCategoriesScalarFieldEnum[]
  }

  /**
   * EventCategories create
   */
  export type EventCategoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategories
     */
    select?: EventCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCategories
     */
    omit?: EventCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a EventCategories.
     */
    data: XOR<EventCategoriesCreateInput, EventCategoriesUncheckedCreateInput>
  }

  /**
   * EventCategories createMany
   */
  export type EventCategoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventCategories.
     */
    data: EventCategoriesCreateManyInput | EventCategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventCategories createManyAndReturn
   */
  export type EventCategoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategories
     */
    select?: EventCategoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventCategories
     */
    omit?: EventCategoriesOmit<ExtArgs> | null
    /**
     * The data used to create many EventCategories.
     */
    data: EventCategoriesCreateManyInput | EventCategoriesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoriesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventCategories update
   */
  export type EventCategoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategories
     */
    select?: EventCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCategories
     */
    omit?: EventCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a EventCategories.
     */
    data: XOR<EventCategoriesUpdateInput, EventCategoriesUncheckedUpdateInput>
    /**
     * Choose, which EventCategories to update.
     */
    where: EventCategoriesWhereUniqueInput
  }

  /**
   * EventCategories updateMany
   */
  export type EventCategoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventCategories.
     */
    data: XOR<EventCategoriesUpdateManyMutationInput, EventCategoriesUncheckedUpdateManyInput>
    /**
     * Filter which EventCategories to update
     */
    where?: EventCategoriesWhereInput
    /**
     * Limit how many EventCategories to update.
     */
    limit?: number
  }

  /**
   * EventCategories updateManyAndReturn
   */
  export type EventCategoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategories
     */
    select?: EventCategoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventCategories
     */
    omit?: EventCategoriesOmit<ExtArgs> | null
    /**
     * The data used to update EventCategories.
     */
    data: XOR<EventCategoriesUpdateManyMutationInput, EventCategoriesUncheckedUpdateManyInput>
    /**
     * Filter which EventCategories to update
     */
    where?: EventCategoriesWhereInput
    /**
     * Limit how many EventCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoriesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventCategories upsert
   */
  export type EventCategoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategories
     */
    select?: EventCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCategories
     */
    omit?: EventCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the EventCategories to update in case it exists.
     */
    where: EventCategoriesWhereUniqueInput
    /**
     * In case the EventCategories found by the `where` argument doesn't exist, create a new EventCategories with this data.
     */
    create: XOR<EventCategoriesCreateInput, EventCategoriesUncheckedCreateInput>
    /**
     * In case the EventCategories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventCategoriesUpdateInput, EventCategoriesUncheckedUpdateInput>
  }

  /**
   * EventCategories delete
   */
  export type EventCategoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategories
     */
    select?: EventCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCategories
     */
    omit?: EventCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoriesInclude<ExtArgs> | null
    /**
     * Filter which EventCategories to delete.
     */
    where: EventCategoriesWhereUniqueInput
  }

  /**
   * EventCategories deleteMany
   */
  export type EventCategoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventCategories to delete
     */
    where?: EventCategoriesWhereInput
    /**
     * Limit how many EventCategories to delete.
     */
    limit?: number
  }

  /**
   * EventCategories without action
   */
  export type EventCategoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategories
     */
    select?: EventCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCategories
     */
    omit?: EventCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoriesInclude<ExtArgs> | null
  }


  /**
   * Model Events
   */

  export type AggregateEvents = {
    _count: EventsCountAggregateOutputType | null
    _avg: EventsAvgAggregateOutputType | null
    _sum: EventsSumAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  export type EventsAvgAggregateOutputType = {
    id: number | null
    locationId: number | null
    imgLogoId: number | null
    imgPosterId: number | null
    minTicketPrice: number | null
    lastScore: Decimal | null
    totalClicks: number | null
    weekClicks: number | null
  }

  export type EventsSumAggregateOutputType = {
    id: number | null
    locationId: number | null
    imgLogoId: number | null
    imgPosterId: number | null
    minTicketPrice: number | null
    lastScore: Decimal | null
    totalClicks: number | null
    weekClicks: number | null
  }

  export type EventsMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    organizerId: string | null
    status: string | null
    locationId: number | null
    venue: string | null
    imgLogoId: number | null
    imgPosterId: number | null
    createdAt: Date | null
    minTicketPrice: number | null
    isOnlyOnEve: boolean | null
    isSpecial: boolean | null
    lastScore: Decimal | null
    totalClicks: number | null
    weekClicks: number | null
  }

  export type EventsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    organizerId: string | null
    status: string | null
    locationId: number | null
    venue: string | null
    imgLogoId: number | null
    imgPosterId: number | null
    createdAt: Date | null
    minTicketPrice: number | null
    isOnlyOnEve: boolean | null
    isSpecial: boolean | null
    lastScore: Decimal | null
    totalClicks: number | null
    weekClicks: number | null
  }

  export type EventsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    startDate: number
    endDate: number
    organizerId: number
    status: number
    locationId: number
    venue: number
    imgLogoId: number
    imgPosterId: number
    createdAt: number
    minTicketPrice: number
    isOnlyOnEve: number
    isSpecial: number
    lastScore: number
    totalClicks: number
    weekClicks: number
    _all: number
  }


  export type EventsAvgAggregateInputType = {
    id?: true
    locationId?: true
    imgLogoId?: true
    imgPosterId?: true
    minTicketPrice?: true
    lastScore?: true
    totalClicks?: true
    weekClicks?: true
  }

  export type EventsSumAggregateInputType = {
    id?: true
    locationId?: true
    imgLogoId?: true
    imgPosterId?: true
    minTicketPrice?: true
    lastScore?: true
    totalClicks?: true
    weekClicks?: true
  }

  export type EventsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    organizerId?: true
    status?: true
    locationId?: true
    venue?: true
    imgLogoId?: true
    imgPosterId?: true
    createdAt?: true
    minTicketPrice?: true
    isOnlyOnEve?: true
    isSpecial?: true
    lastScore?: true
    totalClicks?: true
    weekClicks?: true
  }

  export type EventsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    organizerId?: true
    status?: true
    locationId?: true
    venue?: true
    imgLogoId?: true
    imgPosterId?: true
    createdAt?: true
    minTicketPrice?: true
    isOnlyOnEve?: true
    isSpecial?: true
    lastScore?: true
    totalClicks?: true
    weekClicks?: true
  }

  export type EventsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    organizerId?: true
    status?: true
    locationId?: true
    venue?: true
    imgLogoId?: true
    imgPosterId?: true
    createdAt?: true
    minTicketPrice?: true
    isOnlyOnEve?: true
    isSpecial?: true
    lastScore?: true
    totalClicks?: true
    weekClicks?: true
    _all?: true
  }

  export type EventsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to aggregate.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventsMaxAggregateInputType
  }

  export type GetEventsAggregateType<T extends EventsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvents[P]>
      : GetScalarType<T[P], AggregateEvents[P]>
  }




  export type EventsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventsWhereInput
    orderBy?: EventsOrderByWithAggregationInput | EventsOrderByWithAggregationInput[]
    by: EventsScalarFieldEnum[] | EventsScalarFieldEnum
    having?: EventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventsCountAggregateInputType | true
    _avg?: EventsAvgAggregateInputType
    _sum?: EventsSumAggregateInputType
    _min?: EventsMinAggregateInputType
    _max?: EventsMaxAggregateInputType
  }

  export type EventsGroupByOutputType = {
    id: number
    title: string
    description: string | null
    startDate: Date
    endDate: Date
    organizerId: string | null
    status: string
    locationId: number
    venue: string | null
    imgLogoId: number | null
    imgPosterId: number | null
    createdAt: Date
    minTicketPrice: number
    isOnlyOnEve: boolean
    isSpecial: boolean
    lastScore: Decimal
    totalClicks: number
    weekClicks: number
    _count: EventsCountAggregateOutputType | null
    _avg: EventsAvgAggregateOutputType | null
    _sum: EventsSumAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  type GetEventsGroupByPayload<T extends EventsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventsGroupByOutputType[P]>
            : GetScalarType<T[P], EventsGroupByOutputType[P]>
        }
      >
    >


  export type EventsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    organizerId?: boolean
    status?: boolean
    locationId?: boolean
    venue?: boolean
    imgLogoId?: boolean
    imgPosterId?: boolean
    createdAt?: boolean
    minTicketPrice?: boolean
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore?: boolean
    totalClicks?: boolean
    weekClicks?: boolean
    EventCategories?: boolean | Events$EventCategoriesArgs<ExtArgs>
    Images_Events_imgLogoIdToImages?: boolean | Events$Images_Events_imgLogoIdToImagesArgs<ExtArgs>
    Images_Events_imgPosterIdToImages?: boolean | Events$Images_Events_imgPosterIdToImagesArgs<ExtArgs>
    locations?: boolean | locationsDefaultArgs<ExtArgs>
    users?: boolean | Events$usersArgs<ExtArgs>
    Showing?: boolean | Events$ShowingArgs<ExtArgs>
    _count?: boolean | EventsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["events"]>

  export type EventsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    organizerId?: boolean
    status?: boolean
    locationId?: boolean
    venue?: boolean
    imgLogoId?: boolean
    imgPosterId?: boolean
    createdAt?: boolean
    minTicketPrice?: boolean
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore?: boolean
    totalClicks?: boolean
    weekClicks?: boolean
    Images_Events_imgLogoIdToImages?: boolean | Events$Images_Events_imgLogoIdToImagesArgs<ExtArgs>
    Images_Events_imgPosterIdToImages?: boolean | Events$Images_Events_imgPosterIdToImagesArgs<ExtArgs>
    locations?: boolean | locationsDefaultArgs<ExtArgs>
    users?: boolean | Events$usersArgs<ExtArgs>
  }, ExtArgs["result"]["events"]>

  export type EventsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    organizerId?: boolean
    status?: boolean
    locationId?: boolean
    venue?: boolean
    imgLogoId?: boolean
    imgPosterId?: boolean
    createdAt?: boolean
    minTicketPrice?: boolean
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore?: boolean
    totalClicks?: boolean
    weekClicks?: boolean
    Images_Events_imgLogoIdToImages?: boolean | Events$Images_Events_imgLogoIdToImagesArgs<ExtArgs>
    Images_Events_imgPosterIdToImages?: boolean | Events$Images_Events_imgPosterIdToImagesArgs<ExtArgs>
    locations?: boolean | locationsDefaultArgs<ExtArgs>
    users?: boolean | Events$usersArgs<ExtArgs>
  }, ExtArgs["result"]["events"]>

  export type EventsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    organizerId?: boolean
    status?: boolean
    locationId?: boolean
    venue?: boolean
    imgLogoId?: boolean
    imgPosterId?: boolean
    createdAt?: boolean
    minTicketPrice?: boolean
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore?: boolean
    totalClicks?: boolean
    weekClicks?: boolean
  }

  export type EventsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "startDate" | "endDate" | "organizerId" | "status" | "locationId" | "venue" | "imgLogoId" | "imgPosterId" | "createdAt" | "minTicketPrice" | "isOnlyOnEve" | "isSpecial" | "lastScore" | "totalClicks" | "weekClicks", ExtArgs["result"]["events"]>
  export type EventsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EventCategories?: boolean | Events$EventCategoriesArgs<ExtArgs>
    Images_Events_imgLogoIdToImages?: boolean | Events$Images_Events_imgLogoIdToImagesArgs<ExtArgs>
    Images_Events_imgPosterIdToImages?: boolean | Events$Images_Events_imgPosterIdToImagesArgs<ExtArgs>
    locations?: boolean | locationsDefaultArgs<ExtArgs>
    users?: boolean | Events$usersArgs<ExtArgs>
    Showing?: boolean | Events$ShowingArgs<ExtArgs>
    _count?: boolean | EventsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Images_Events_imgLogoIdToImages?: boolean | Events$Images_Events_imgLogoIdToImagesArgs<ExtArgs>
    Images_Events_imgPosterIdToImages?: boolean | Events$Images_Events_imgPosterIdToImagesArgs<ExtArgs>
    locations?: boolean | locationsDefaultArgs<ExtArgs>
    users?: boolean | Events$usersArgs<ExtArgs>
  }
  export type EventsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Images_Events_imgLogoIdToImages?: boolean | Events$Images_Events_imgLogoIdToImagesArgs<ExtArgs>
    Images_Events_imgPosterIdToImages?: boolean | Events$Images_Events_imgPosterIdToImagesArgs<ExtArgs>
    locations?: boolean | locationsDefaultArgs<ExtArgs>
    users?: boolean | Events$usersArgs<ExtArgs>
  }

  export type $EventsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Events"
    objects: {
      EventCategories: Prisma.$EventCategoriesPayload<ExtArgs>[]
      Images_Events_imgLogoIdToImages: Prisma.$ImagesPayload<ExtArgs> | null
      Images_Events_imgPosterIdToImages: Prisma.$ImagesPayload<ExtArgs> | null
      locations: Prisma.$locationsPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs> | null
      Showing: Prisma.$ShowingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      startDate: Date
      endDate: Date
      organizerId: string | null
      status: string
      locationId: number
      venue: string | null
      imgLogoId: number | null
      imgPosterId: number | null
      createdAt: Date
      minTicketPrice: number
      isOnlyOnEve: boolean
      isSpecial: boolean
      lastScore: Prisma.Decimal
      totalClicks: number
      weekClicks: number
    }, ExtArgs["result"]["events"]>
    composites: {}
  }

  type EventsGetPayload<S extends boolean | null | undefined | EventsDefaultArgs> = $Result.GetResult<Prisma.$EventsPayload, S>

  type EventsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventsCountAggregateInputType | true
    }

  export interface EventsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Events'], meta: { name: 'Events' } }
    /**
     * Find zero or one Events that matches the filter.
     * @param {EventsFindUniqueArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventsFindUniqueArgs>(args: SelectSubset<T, EventsFindUniqueArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Events that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventsFindUniqueOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventsFindUniqueOrThrowArgs>(args: SelectSubset<T, EventsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindFirstArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventsFindFirstArgs>(args?: SelectSubset<T, EventsFindFirstArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Events that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindFirstOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventsFindFirstOrThrowArgs>(args?: SelectSubset<T, EventsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.events.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventsWithIdOnly = await prisma.events.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventsFindManyArgs>(args?: SelectSubset<T, EventsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Events.
     * @param {EventsCreateArgs} args - Arguments to create a Events.
     * @example
     * // Create one Events
     * const Events = await prisma.events.create({
     *   data: {
     *     // ... data to create a Events
     *   }
     * })
     * 
     */
    create<T extends EventsCreateArgs>(args: SelectSubset<T, EventsCreateArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Events.
     * @param {EventsCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const events = await prisma.events.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventsCreateManyArgs>(args?: SelectSubset<T, EventsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventsCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const events = await prisma.events.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventsWithIdOnly = await prisma.events.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventsCreateManyAndReturnArgs>(args?: SelectSubset<T, EventsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Events.
     * @param {EventsDeleteArgs} args - Arguments to delete one Events.
     * @example
     * // Delete one Events
     * const Events = await prisma.events.delete({
     *   where: {
     *     // ... filter to delete one Events
     *   }
     * })
     * 
     */
    delete<T extends EventsDeleteArgs>(args: SelectSubset<T, EventsDeleteArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Events.
     * @param {EventsUpdateArgs} args - Arguments to update one Events.
     * @example
     * // Update one Events
     * const events = await prisma.events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventsUpdateArgs>(args: SelectSubset<T, EventsUpdateArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Events.
     * @param {EventsDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventsDeleteManyArgs>(args?: SelectSubset<T, EventsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const events = await prisma.events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventsUpdateManyArgs>(args: SelectSubset<T, EventsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventsUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const events = await prisma.events.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventsWithIdOnly = await prisma.events.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventsUpdateManyAndReturnArgs>(args: SelectSubset<T, EventsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Events.
     * @param {EventsUpsertArgs} args - Arguments to update or create a Events.
     * @example
     * // Update or create a Events
     * const events = await prisma.events.upsert({
     *   create: {
     *     // ... data to create a Events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Events we want to update
     *   }
     * })
     */
    upsert<T extends EventsUpsertArgs>(args: SelectSubset<T, EventsUpsertArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.events.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventsCountArgs>(
      args?: Subset<T, EventsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventsAggregateArgs>(args: Subset<T, EventsAggregateArgs>): Prisma.PrismaPromise<GetEventsAggregateType<T>>

    /**
     * Group by Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventsGroupByArgs['orderBy'] }
        : { orderBy?: EventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Events model
   */
  readonly fields: EventsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    EventCategories<T extends Events$EventCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Events$EventCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCategoriesPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Images_Events_imgLogoIdToImages<T extends Events$Images_Events_imgLogoIdToImagesArgs<ExtArgs> = {}>(args?: Subset<T, Events$Images_Events_imgLogoIdToImagesArgs<ExtArgs>>): Prisma__ImagesClient<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Images_Events_imgPosterIdToImages<T extends Events$Images_Events_imgPosterIdToImagesArgs<ExtArgs> = {}>(args?: Subset<T, Events$Images_Events_imgPosterIdToImagesArgs<ExtArgs>>): Prisma__ImagesClient<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    locations<T extends locationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, locationsDefaultArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    users<T extends Events$usersArgs<ExtArgs> = {}>(args?: Subset<T, Events$usersArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Showing<T extends Events$ShowingArgs<ExtArgs> = {}>(args?: Subset<T, Events$ShowingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Events model
   */ 
  interface EventsFieldRefs {
    readonly id: FieldRef<"Events", 'Int'>
    readonly title: FieldRef<"Events", 'String'>
    readonly description: FieldRef<"Events", 'String'>
    readonly startDate: FieldRef<"Events", 'DateTime'>
    readonly endDate: FieldRef<"Events", 'DateTime'>
    readonly organizerId: FieldRef<"Events", 'String'>
    readonly status: FieldRef<"Events", 'String'>
    readonly locationId: FieldRef<"Events", 'Int'>
    readonly venue: FieldRef<"Events", 'String'>
    readonly imgLogoId: FieldRef<"Events", 'Int'>
    readonly imgPosterId: FieldRef<"Events", 'Int'>
    readonly createdAt: FieldRef<"Events", 'DateTime'>
    readonly minTicketPrice: FieldRef<"Events", 'Int'>
    readonly isOnlyOnEve: FieldRef<"Events", 'Boolean'>
    readonly isSpecial: FieldRef<"Events", 'Boolean'>
    readonly lastScore: FieldRef<"Events", 'Decimal'>
    readonly totalClicks: FieldRef<"Events", 'Int'>
    readonly weekClicks: FieldRef<"Events", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Events findUnique
   */
  export type EventsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where: EventsWhereUniqueInput
  }

  /**
   * Events findUniqueOrThrow
   */
  export type EventsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where: EventsWhereUniqueInput
  }

  /**
   * Events findFirst
   */
  export type EventsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Events findFirstOrThrow
   */
  export type EventsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Events findMany
   */
  export type EventsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Events create
   */
  export type EventsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * The data needed to create a Events.
     */
    data: XOR<EventsCreateInput, EventsUncheckedCreateInput>
  }

  /**
   * Events createMany
   */
  export type EventsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventsCreateManyInput | EventsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Events createManyAndReturn
   */
  export type EventsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventsCreateManyInput | EventsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Events update
   */
  export type EventsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * The data needed to update a Events.
     */
    data: XOR<EventsUpdateInput, EventsUncheckedUpdateInput>
    /**
     * Choose, which Events to update.
     */
    where: EventsWhereUniqueInput
  }

  /**
   * Events updateMany
   */
  export type EventsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventsWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Events updateManyAndReturn
   */
  export type EventsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventsWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Events upsert
   */
  export type EventsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * The filter to search for the Events to update in case it exists.
     */
    where: EventsWhereUniqueInput
    /**
     * In case the Events found by the `where` argument doesn't exist, create a new Events with this data.
     */
    create: XOR<EventsCreateInput, EventsUncheckedCreateInput>
    /**
     * In case the Events was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventsUpdateInput, EventsUncheckedUpdateInput>
  }

  /**
   * Events delete
   */
  export type EventsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    /**
     * Filter which Events to delete.
     */
    where: EventsWhereUniqueInput
  }

  /**
   * Events deleteMany
   */
  export type EventsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventsWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Events.EventCategories
   */
  export type Events$EventCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategories
     */
    select?: EventCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventCategories
     */
    omit?: EventCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoriesInclude<ExtArgs> | null
    where?: EventCategoriesWhereInput
    orderBy?: EventCategoriesOrderByWithRelationInput | EventCategoriesOrderByWithRelationInput[]
    cursor?: EventCategoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventCategoriesScalarFieldEnum | EventCategoriesScalarFieldEnum[]
  }

  /**
   * Events.Images_Events_imgLogoIdToImages
   */
  export type Events$Images_Events_imgLogoIdToImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    where?: ImagesWhereInput
  }

  /**
   * Events.Images_Events_imgPosterIdToImages
   */
  export type Events$Images_Events_imgPosterIdToImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    where?: ImagesWhereInput
  }

  /**
   * Events.users
   */
  export type Events$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Events.Showing
   */
  export type Events$ShowingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showing
     */
    omit?: ShowingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    where?: ShowingWhereInput
    orderBy?: ShowingOrderByWithRelationInput | ShowingOrderByWithRelationInput[]
    cursor?: ShowingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShowingScalarFieldEnum | ShowingScalarFieldEnum[]
  }

  /**
   * Events without action
   */
  export type EventsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
  }


  /**
   * Model Images
   */

  export type AggregateImages = {
    _count: ImagesCountAggregateOutputType | null
    _avg: ImagesAvgAggregateOutputType | null
    _sum: ImagesSumAggregateOutputType | null
    _min: ImagesMinAggregateOutputType | null
    _max: ImagesMaxAggregateOutputType | null
  }

  export type ImagesAvgAggregateOutputType = {
    id: number | null
  }

  export type ImagesSumAggregateOutputType = {
    id: number | null
  }

  export type ImagesMinAggregateOutputType = {
    id: number | null
    imageUrl: string | null
  }

  export type ImagesMaxAggregateOutputType = {
    id: number | null
    imageUrl: string | null
  }

  export type ImagesCountAggregateOutputType = {
    id: number
    imageUrl: number
    _all: number
  }


  export type ImagesAvgAggregateInputType = {
    id?: true
  }

  export type ImagesSumAggregateInputType = {
    id?: true
  }

  export type ImagesMinAggregateInputType = {
    id?: true
    imageUrl?: true
  }

  export type ImagesMaxAggregateInputType = {
    id?: true
    imageUrl?: true
  }

  export type ImagesCountAggregateInputType = {
    id?: true
    imageUrl?: true
    _all?: true
  }

  export type ImagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Images to aggregate.
     */
    where?: ImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImagesOrderByWithRelationInput | ImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    _count?: true | ImagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImagesMaxAggregateInputType
  }

  export type GetImagesAggregateType<T extends ImagesAggregateArgs> = {
        [P in keyof T & keyof AggregateImages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImages[P]>
      : GetScalarType<T[P], AggregateImages[P]>
  }




  export type ImagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImagesWhereInput
    orderBy?: ImagesOrderByWithAggregationInput | ImagesOrderByWithAggregationInput[]
    by: ImagesScalarFieldEnum[] | ImagesScalarFieldEnum
    having?: ImagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImagesCountAggregateInputType | true
    _avg?: ImagesAvgAggregateInputType
    _sum?: ImagesSumAggregateInputType
    _min?: ImagesMinAggregateInputType
    _max?: ImagesMaxAggregateInputType
  }

  export type ImagesGroupByOutputType = {
    id: number
    imageUrl: string
    _count: ImagesCountAggregateOutputType | null
    _avg: ImagesAvgAggregateOutputType | null
    _sum: ImagesSumAggregateOutputType | null
    _min: ImagesMinAggregateOutputType | null
    _max: ImagesMaxAggregateOutputType | null
  }

  type GetImagesGroupByPayload<T extends ImagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImagesGroupByOutputType[P]>
            : GetScalarType<T[P], ImagesGroupByOutputType[P]>
        }
      >
    >


  export type ImagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imageUrl?: boolean
    Events_Events_imgLogoIdToImages?: boolean | Images$Events_Events_imgLogoIdToImagesArgs<ExtArgs>
    Events_Events_imgPosterIdToImages?: boolean | Images$Events_Events_imgPosterIdToImagesArgs<ExtArgs>
    _count?: boolean | ImagesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["images"]>

  export type ImagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imageUrl?: boolean
  }, ExtArgs["result"]["images"]>

  export type ImagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imageUrl?: boolean
  }, ExtArgs["result"]["images"]>

  export type ImagesSelectScalar = {
    id?: boolean
    imageUrl?: boolean
  }

  export type ImagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "imageUrl", ExtArgs["result"]["images"]>
  export type ImagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Events_Events_imgLogoIdToImages?: boolean | Images$Events_Events_imgLogoIdToImagesArgs<ExtArgs>
    Events_Events_imgPosterIdToImages?: boolean | Images$Events_Events_imgPosterIdToImagesArgs<ExtArgs>
    _count?: boolean | ImagesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ImagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ImagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ImagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Images"
    objects: {
      Events_Events_imgLogoIdToImages: Prisma.$EventsPayload<ExtArgs>[]
      Events_Events_imgPosterIdToImages: Prisma.$EventsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      imageUrl: string
    }, ExtArgs["result"]["images"]>
    composites: {}
  }

  type ImagesGetPayload<S extends boolean | null | undefined | ImagesDefaultArgs> = $Result.GetResult<Prisma.$ImagesPayload, S>

  type ImagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImagesCountAggregateInputType | true
    }

  export interface ImagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Images'], meta: { name: 'Images' } }
    /**
     * Find zero or one Images that matches the filter.
     * @param {ImagesFindUniqueArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImagesFindUniqueArgs>(args: SelectSubset<T, ImagesFindUniqueArgs<ExtArgs>>): Prisma__ImagesClient<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Images that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImagesFindUniqueOrThrowArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImagesFindUniqueOrThrowArgs>(args: SelectSubset<T, ImagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImagesClient<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagesFindFirstArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImagesFindFirstArgs>(args?: SelectSubset<T, ImagesFindFirstArgs<ExtArgs>>): Prisma__ImagesClient<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Images that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagesFindFirstOrThrowArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImagesFindFirstOrThrowArgs>(args?: SelectSubset<T, ImagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImagesClient<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.images.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.images.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imagesWithIdOnly = await prisma.images.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImagesFindManyArgs>(args?: SelectSubset<T, ImagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Images.
     * @param {ImagesCreateArgs} args - Arguments to create a Images.
     * @example
     * // Create one Images
     * const Images = await prisma.images.create({
     *   data: {
     *     // ... data to create a Images
     *   }
     * })
     * 
     */
    create<T extends ImagesCreateArgs>(args: SelectSubset<T, ImagesCreateArgs<ExtArgs>>): Prisma__ImagesClient<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Images.
     * @param {ImagesCreateManyArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const images = await prisma.images.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImagesCreateManyArgs>(args?: SelectSubset<T, ImagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Images and returns the data saved in the database.
     * @param {ImagesCreateManyAndReturnArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const images = await prisma.images.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Images and only return the `id`
     * const imagesWithIdOnly = await prisma.images.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImagesCreateManyAndReturnArgs>(args?: SelectSubset<T, ImagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Images.
     * @param {ImagesDeleteArgs} args - Arguments to delete one Images.
     * @example
     * // Delete one Images
     * const Images = await prisma.images.delete({
     *   where: {
     *     // ... filter to delete one Images
     *   }
     * })
     * 
     */
    delete<T extends ImagesDeleteArgs>(args: SelectSubset<T, ImagesDeleteArgs<ExtArgs>>): Prisma__ImagesClient<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Images.
     * @param {ImagesUpdateArgs} args - Arguments to update one Images.
     * @example
     * // Update one Images
     * const images = await prisma.images.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImagesUpdateArgs>(args: SelectSubset<T, ImagesUpdateArgs<ExtArgs>>): Prisma__ImagesClient<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Images.
     * @param {ImagesDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.images.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImagesDeleteManyArgs>(args?: SelectSubset<T, ImagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const images = await prisma.images.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImagesUpdateManyArgs>(args: SelectSubset<T, ImagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images and returns the data updated in the database.
     * @param {ImagesUpdateManyAndReturnArgs} args - Arguments to update many Images.
     * @example
     * // Update many Images
     * const images = await prisma.images.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Images and only return the `id`
     * const imagesWithIdOnly = await prisma.images.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImagesUpdateManyAndReturnArgs>(args: SelectSubset<T, ImagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Images.
     * @param {ImagesUpsertArgs} args - Arguments to update or create a Images.
     * @example
     * // Update or create a Images
     * const images = await prisma.images.upsert({
     *   create: {
     *     // ... data to create a Images
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Images we want to update
     *   }
     * })
     */
    upsert<T extends ImagesUpsertArgs>(args: SelectSubset<T, ImagesUpsertArgs<ExtArgs>>): Prisma__ImagesClient<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagesCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.images.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImagesCountArgs>(
      args?: Subset<T, ImagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImagesAggregateArgs>(args: Subset<T, ImagesAggregateArgs>): Prisma.PrismaPromise<GetImagesAggregateType<T>>

    /**
     * Group by Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImagesGroupByArgs['orderBy'] }
        : { orderBy?: ImagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Images model
   */
  readonly fields: ImagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Images.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Events_Events_imgLogoIdToImages<T extends Images$Events_Events_imgLogoIdToImagesArgs<ExtArgs> = {}>(args?: Subset<T, Images$Events_Events_imgLogoIdToImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Events_Events_imgPosterIdToImages<T extends Images$Events_Events_imgPosterIdToImagesArgs<ExtArgs> = {}>(args?: Subset<T, Images$Events_Events_imgPosterIdToImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Images model
   */ 
  interface ImagesFieldRefs {
    readonly id: FieldRef<"Images", 'Int'>
    readonly imageUrl: FieldRef<"Images", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Images findUnique
   */
  export type ImagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where: ImagesWhereUniqueInput
  }

  /**
   * Images findUniqueOrThrow
   */
  export type ImagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where: ImagesWhereUniqueInput
  }

  /**
   * Images findFirst
   */
  export type ImagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImagesOrderByWithRelationInput | ImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * Images findFirstOrThrow
   */
  export type ImagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImagesOrderByWithRelationInput | ImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * Images findMany
   */
  export type ImagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImagesOrderByWithRelationInput | ImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
     */
    cursor?: ImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * Images create
   */
  export type ImagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    /**
     * The data needed to create a Images.
     */
    data: XOR<ImagesCreateInput, ImagesUncheckedCreateInput>
  }

  /**
   * Images createMany
   */
  export type ImagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Images.
     */
    data: ImagesCreateManyInput | ImagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Images createManyAndReturn
   */
  export type ImagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * The data used to create many Images.
     */
    data: ImagesCreateManyInput | ImagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Images update
   */
  export type ImagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    /**
     * The data needed to update a Images.
     */
    data: XOR<ImagesUpdateInput, ImagesUncheckedUpdateInput>
    /**
     * Choose, which Images to update.
     */
    where: ImagesWhereUniqueInput
  }

  /**
   * Images updateMany
   */
  export type ImagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Images.
     */
    data: XOR<ImagesUpdateManyMutationInput, ImagesUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImagesWhereInput
    /**
     * Limit how many Images to update.
     */
    limit?: number
  }

  /**
   * Images updateManyAndReturn
   */
  export type ImagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * The data used to update Images.
     */
    data: XOR<ImagesUpdateManyMutationInput, ImagesUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImagesWhereInput
    /**
     * Limit how many Images to update.
     */
    limit?: number
  }

  /**
   * Images upsert
   */
  export type ImagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    /**
     * The filter to search for the Images to update in case it exists.
     */
    where: ImagesWhereUniqueInput
    /**
     * In case the Images found by the `where` argument doesn't exist, create a new Images with this data.
     */
    create: XOR<ImagesCreateInput, ImagesUncheckedCreateInput>
    /**
     * In case the Images was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImagesUpdateInput, ImagesUncheckedUpdateInput>
  }

  /**
   * Images delete
   */
  export type ImagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    /**
     * Filter which Images to delete.
     */
    where: ImagesWhereUniqueInput
  }

  /**
   * Images deleteMany
   */
  export type ImagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Images to delete
     */
    where?: ImagesWhereInput
    /**
     * Limit how many Images to delete.
     */
    limit?: number
  }

  /**
   * Images.Events_Events_imgLogoIdToImages
   */
  export type Images$Events_Events_imgLogoIdToImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    where?: EventsWhereInput
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    cursor?: EventsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Images.Events_Events_imgPosterIdToImages
   */
  export type Images$Events_Events_imgPosterIdToImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    where?: EventsWhereInput
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    cursor?: EventsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Images without action
   */
  export type ImagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
  }


  /**
   * Model districts
   */

  export type AggregateDistricts = {
    _count: DistrictsCountAggregateOutputType | null
    _avg: DistrictsAvgAggregateOutputType | null
    _sum: DistrictsSumAggregateOutputType | null
    _min: DistrictsMinAggregateOutputType | null
    _max: DistrictsMaxAggregateOutputType | null
  }

  export type DistrictsAvgAggregateOutputType = {
    id: number | null
    provinceId: number | null
  }

  export type DistrictsSumAggregateOutputType = {
    id: number | null
    provinceId: number | null
  }

  export type DistrictsMinAggregateOutputType = {
    id: number | null
    name: string | null
    provinceId: number | null
    createdAt: Date | null
  }

  export type DistrictsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    provinceId: number | null
    createdAt: Date | null
  }

  export type DistrictsCountAggregateOutputType = {
    id: number
    name: number
    provinceId: number
    createdAt: number
    _all: number
  }


  export type DistrictsAvgAggregateInputType = {
    id?: true
    provinceId?: true
  }

  export type DistrictsSumAggregateInputType = {
    id?: true
    provinceId?: true
  }

  export type DistrictsMinAggregateInputType = {
    id?: true
    name?: true
    provinceId?: true
    createdAt?: true
  }

  export type DistrictsMaxAggregateInputType = {
    id?: true
    name?: true
    provinceId?: true
    createdAt?: true
  }

  export type DistrictsCountAggregateInputType = {
    id?: true
    name?: true
    provinceId?: true
    createdAt?: true
    _all?: true
  }

  export type DistrictsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which districts to aggregate.
     */
    where?: districtsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of districts to fetch.
     */
    orderBy?: districtsOrderByWithRelationInput | districtsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: districtsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned districts
    **/
    _count?: true | DistrictsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DistrictsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DistrictsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistrictsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistrictsMaxAggregateInputType
  }

  export type GetDistrictsAggregateType<T extends DistrictsAggregateArgs> = {
        [P in keyof T & keyof AggregateDistricts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistricts[P]>
      : GetScalarType<T[P], AggregateDistricts[P]>
  }




  export type districtsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: districtsWhereInput
    orderBy?: districtsOrderByWithAggregationInput | districtsOrderByWithAggregationInput[]
    by: DistrictsScalarFieldEnum[] | DistrictsScalarFieldEnum
    having?: districtsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistrictsCountAggregateInputType | true
    _avg?: DistrictsAvgAggregateInputType
    _sum?: DistrictsSumAggregateInputType
    _min?: DistrictsMinAggregateInputType
    _max?: DistrictsMaxAggregateInputType
  }

  export type DistrictsGroupByOutputType = {
    id: number
    name: string
    provinceId: number
    createdAt: Date
    _count: DistrictsCountAggregateOutputType | null
    _avg: DistrictsAvgAggregateOutputType | null
    _sum: DistrictsSumAggregateOutputType | null
    _min: DistrictsMinAggregateOutputType | null
    _max: DistrictsMaxAggregateOutputType | null
  }

  type GetDistrictsGroupByPayload<T extends districtsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DistrictsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistrictsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistrictsGroupByOutputType[P]>
            : GetScalarType<T[P], DistrictsGroupByOutputType[P]>
        }
      >
    >


  export type districtsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    provinceId?: boolean
    createdAt?: boolean
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    locations?: boolean | districts$locationsArgs<ExtArgs>
    _count?: boolean | DistrictsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["districts"]>

  export type districtsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    provinceId?: boolean
    createdAt?: boolean
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["districts"]>

  export type districtsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    provinceId?: boolean
    createdAt?: boolean
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["districts"]>

  export type districtsSelectScalar = {
    id?: boolean
    name?: boolean
    provinceId?: boolean
    createdAt?: boolean
  }

  export type districtsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "provinceId" | "createdAt", ExtArgs["result"]["districts"]>
  export type districtsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    locations?: boolean | districts$locationsArgs<ExtArgs>
    _count?: boolean | DistrictsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type districtsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }
  export type districtsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }

  export type $districtsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "districts"
    objects: {
      province: Prisma.$ProvincePayload<ExtArgs>
      locations: Prisma.$locationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      provinceId: number
      createdAt: Date
    }, ExtArgs["result"]["districts"]>
    composites: {}
  }

  type districtsGetPayload<S extends boolean | null | undefined | districtsDefaultArgs> = $Result.GetResult<Prisma.$districtsPayload, S>

  type districtsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<districtsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DistrictsCountAggregateInputType | true
    }

  export interface districtsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['districts'], meta: { name: 'districts' } }
    /**
     * Find zero or one Districts that matches the filter.
     * @param {districtsFindUniqueArgs} args - Arguments to find a Districts
     * @example
     * // Get one Districts
     * const districts = await prisma.districts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends districtsFindUniqueArgs>(args: SelectSubset<T, districtsFindUniqueArgs<ExtArgs>>): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Districts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {districtsFindUniqueOrThrowArgs} args - Arguments to find a Districts
     * @example
     * // Get one Districts
     * const districts = await prisma.districts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends districtsFindUniqueOrThrowArgs>(args: SelectSubset<T, districtsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Districts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtsFindFirstArgs} args - Arguments to find a Districts
     * @example
     * // Get one Districts
     * const districts = await prisma.districts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends districtsFindFirstArgs>(args?: SelectSubset<T, districtsFindFirstArgs<ExtArgs>>): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Districts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtsFindFirstOrThrowArgs} args - Arguments to find a Districts
     * @example
     * // Get one Districts
     * const districts = await prisma.districts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends districtsFindFirstOrThrowArgs>(args?: SelectSubset<T, districtsFindFirstOrThrowArgs<ExtArgs>>): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Districts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Districts
     * const districts = await prisma.districts.findMany()
     * 
     * // Get first 10 Districts
     * const districts = await prisma.districts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const districtsWithIdOnly = await prisma.districts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends districtsFindManyArgs>(args?: SelectSubset<T, districtsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Districts.
     * @param {districtsCreateArgs} args - Arguments to create a Districts.
     * @example
     * // Create one Districts
     * const Districts = await prisma.districts.create({
     *   data: {
     *     // ... data to create a Districts
     *   }
     * })
     * 
     */
    create<T extends districtsCreateArgs>(args: SelectSubset<T, districtsCreateArgs<ExtArgs>>): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Districts.
     * @param {districtsCreateManyArgs} args - Arguments to create many Districts.
     * @example
     * // Create many Districts
     * const districts = await prisma.districts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends districtsCreateManyArgs>(args?: SelectSubset<T, districtsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Districts and returns the data saved in the database.
     * @param {districtsCreateManyAndReturnArgs} args - Arguments to create many Districts.
     * @example
     * // Create many Districts
     * const districts = await prisma.districts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Districts and only return the `id`
     * const districtsWithIdOnly = await prisma.districts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends districtsCreateManyAndReturnArgs>(args?: SelectSubset<T, districtsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Districts.
     * @param {districtsDeleteArgs} args - Arguments to delete one Districts.
     * @example
     * // Delete one Districts
     * const Districts = await prisma.districts.delete({
     *   where: {
     *     // ... filter to delete one Districts
     *   }
     * })
     * 
     */
    delete<T extends districtsDeleteArgs>(args: SelectSubset<T, districtsDeleteArgs<ExtArgs>>): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Districts.
     * @param {districtsUpdateArgs} args - Arguments to update one Districts.
     * @example
     * // Update one Districts
     * const districts = await prisma.districts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends districtsUpdateArgs>(args: SelectSubset<T, districtsUpdateArgs<ExtArgs>>): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Districts.
     * @param {districtsDeleteManyArgs} args - Arguments to filter Districts to delete.
     * @example
     * // Delete a few Districts
     * const { count } = await prisma.districts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends districtsDeleteManyArgs>(args?: SelectSubset<T, districtsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Districts
     * const districts = await prisma.districts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends districtsUpdateManyArgs>(args: SelectSubset<T, districtsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Districts and returns the data updated in the database.
     * @param {districtsUpdateManyAndReturnArgs} args - Arguments to update many Districts.
     * @example
     * // Update many Districts
     * const districts = await prisma.districts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Districts and only return the `id`
     * const districtsWithIdOnly = await prisma.districts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends districtsUpdateManyAndReturnArgs>(args: SelectSubset<T, districtsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Districts.
     * @param {districtsUpsertArgs} args - Arguments to update or create a Districts.
     * @example
     * // Update or create a Districts
     * const districts = await prisma.districts.upsert({
     *   create: {
     *     // ... data to create a Districts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Districts we want to update
     *   }
     * })
     */
    upsert<T extends districtsUpsertArgs>(args: SelectSubset<T, districtsUpsertArgs<ExtArgs>>): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtsCountArgs} args - Arguments to filter Districts to count.
     * @example
     * // Count the number of Districts
     * const count = await prisma.districts.count({
     *   where: {
     *     // ... the filter for the Districts we want to count
     *   }
     * })
    **/
    count<T extends districtsCountArgs>(
      args?: Subset<T, districtsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistrictsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistrictsAggregateArgs>(args: Subset<T, DistrictsAggregateArgs>): Prisma.PrismaPromise<GetDistrictsAggregateType<T>>

    /**
     * Group by Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends districtsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: districtsGroupByArgs['orderBy'] }
        : { orderBy?: districtsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, districtsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistrictsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the districts model
   */
  readonly fields: districtsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for districts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__districtsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    province<T extends ProvinceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvinceDefaultArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    locations<T extends districts$locationsArgs<ExtArgs> = {}>(args?: Subset<T, districts$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the districts model
   */ 
  interface districtsFieldRefs {
    readonly id: FieldRef<"districts", 'Int'>
    readonly name: FieldRef<"districts", 'String'>
    readonly provinceId: FieldRef<"districts", 'Int'>
    readonly createdAt: FieldRef<"districts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * districts findUnique
   */
  export type districtsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the districts
     */
    omit?: districtsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    /**
     * Filter, which districts to fetch.
     */
    where: districtsWhereUniqueInput
  }

  /**
   * districts findUniqueOrThrow
   */
  export type districtsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the districts
     */
    omit?: districtsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    /**
     * Filter, which districts to fetch.
     */
    where: districtsWhereUniqueInput
  }

  /**
   * districts findFirst
   */
  export type districtsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the districts
     */
    omit?: districtsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    /**
     * Filter, which districts to fetch.
     */
    where?: districtsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of districts to fetch.
     */
    orderBy?: districtsOrderByWithRelationInput | districtsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for districts.
     */
    cursor?: districtsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of districts.
     */
    distinct?: DistrictsScalarFieldEnum | DistrictsScalarFieldEnum[]
  }

  /**
   * districts findFirstOrThrow
   */
  export type districtsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the districts
     */
    omit?: districtsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    /**
     * Filter, which districts to fetch.
     */
    where?: districtsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of districts to fetch.
     */
    orderBy?: districtsOrderByWithRelationInput | districtsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for districts.
     */
    cursor?: districtsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of districts.
     */
    distinct?: DistrictsScalarFieldEnum | DistrictsScalarFieldEnum[]
  }

  /**
   * districts findMany
   */
  export type districtsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the districts
     */
    omit?: districtsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    /**
     * Filter, which districts to fetch.
     */
    where?: districtsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of districts to fetch.
     */
    orderBy?: districtsOrderByWithRelationInput | districtsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing districts.
     */
    cursor?: districtsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` districts.
     */
    skip?: number
    distinct?: DistrictsScalarFieldEnum | DistrictsScalarFieldEnum[]
  }

  /**
   * districts create
   */
  export type districtsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the districts
     */
    omit?: districtsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    /**
     * The data needed to create a districts.
     */
    data: XOR<districtsCreateInput, districtsUncheckedCreateInput>
  }

  /**
   * districts createMany
   */
  export type districtsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many districts.
     */
    data: districtsCreateManyInput | districtsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * districts createManyAndReturn
   */
  export type districtsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the districts
     */
    omit?: districtsOmit<ExtArgs> | null
    /**
     * The data used to create many districts.
     */
    data: districtsCreateManyInput | districtsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * districts update
   */
  export type districtsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the districts
     */
    omit?: districtsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    /**
     * The data needed to update a districts.
     */
    data: XOR<districtsUpdateInput, districtsUncheckedUpdateInput>
    /**
     * Choose, which districts to update.
     */
    where: districtsWhereUniqueInput
  }

  /**
   * districts updateMany
   */
  export type districtsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update districts.
     */
    data: XOR<districtsUpdateManyMutationInput, districtsUncheckedUpdateManyInput>
    /**
     * Filter which districts to update
     */
    where?: districtsWhereInput
    /**
     * Limit how many districts to update.
     */
    limit?: number
  }

  /**
   * districts updateManyAndReturn
   */
  export type districtsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the districts
     */
    omit?: districtsOmit<ExtArgs> | null
    /**
     * The data used to update districts.
     */
    data: XOR<districtsUpdateManyMutationInput, districtsUncheckedUpdateManyInput>
    /**
     * Filter which districts to update
     */
    where?: districtsWhereInput
    /**
     * Limit how many districts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * districts upsert
   */
  export type districtsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the districts
     */
    omit?: districtsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    /**
     * The filter to search for the districts to update in case it exists.
     */
    where: districtsWhereUniqueInput
    /**
     * In case the districts found by the `where` argument doesn't exist, create a new districts with this data.
     */
    create: XOR<districtsCreateInput, districtsUncheckedCreateInput>
    /**
     * In case the districts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<districtsUpdateInput, districtsUncheckedUpdateInput>
  }

  /**
   * districts delete
   */
  export type districtsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the districts
     */
    omit?: districtsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
    /**
     * Filter which districts to delete.
     */
    where: districtsWhereUniqueInput
  }

  /**
   * districts deleteMany
   */
  export type districtsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which districts to delete
     */
    where?: districtsWhereInput
    /**
     * Limit how many districts to delete.
     */
    limit?: number
  }

  /**
   * districts.locations
   */
  export type districts$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    where?: locationsWhereInput
    orderBy?: locationsOrderByWithRelationInput | locationsOrderByWithRelationInput[]
    cursor?: locationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * districts without action
   */
  export type districtsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the districts
     */
    omit?: districtsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: districtsInclude<ExtArgs> | null
  }


  /**
   * Model locations
   */

  export type AggregateLocations = {
    _count: LocationsCountAggregateOutputType | null
    _avg: LocationsAvgAggregateOutputType | null
    _sum: LocationsSumAggregateOutputType | null
    _min: LocationsMinAggregateOutputType | null
    _max: LocationsMaxAggregateOutputType | null
  }

  export type LocationsAvgAggregateOutputType = {
    id: number | null
    districtId: number | null
  }

  export type LocationsSumAggregateOutputType = {
    id: number | null
    districtId: number | null
  }

  export type LocationsMinAggregateOutputType = {
    id: number | null
    street: string | null
    ward: string | null
    districtId: number | null
    createdAt: Date | null
  }

  export type LocationsMaxAggregateOutputType = {
    id: number | null
    street: string | null
    ward: string | null
    districtId: number | null
    createdAt: Date | null
  }

  export type LocationsCountAggregateOutputType = {
    id: number
    street: number
    ward: number
    districtId: number
    createdAt: number
    _all: number
  }


  export type LocationsAvgAggregateInputType = {
    id?: true
    districtId?: true
  }

  export type LocationsSumAggregateInputType = {
    id?: true
    districtId?: true
  }

  export type LocationsMinAggregateInputType = {
    id?: true
    street?: true
    ward?: true
    districtId?: true
    createdAt?: true
  }

  export type LocationsMaxAggregateInputType = {
    id?: true
    street?: true
    ward?: true
    districtId?: true
    createdAt?: true
  }

  export type LocationsCountAggregateInputType = {
    id?: true
    street?: true
    ward?: true
    districtId?: true
    createdAt?: true
    _all?: true
  }

  export type LocationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which locations to aggregate.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationsOrderByWithRelationInput | locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned locations
    **/
    _count?: true | LocationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationsMaxAggregateInputType
  }

  export type GetLocationsAggregateType<T extends LocationsAggregateArgs> = {
        [P in keyof T & keyof AggregateLocations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocations[P]>
      : GetScalarType<T[P], AggregateLocations[P]>
  }




  export type locationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: locationsWhereInput
    orderBy?: locationsOrderByWithAggregationInput | locationsOrderByWithAggregationInput[]
    by: LocationsScalarFieldEnum[] | LocationsScalarFieldEnum
    having?: locationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationsCountAggregateInputType | true
    _avg?: LocationsAvgAggregateInputType
    _sum?: LocationsSumAggregateInputType
    _min?: LocationsMinAggregateInputType
    _max?: LocationsMaxAggregateInputType
  }

  export type LocationsGroupByOutputType = {
    id: number
    street: string
    ward: string
    districtId: number
    createdAt: Date
    _count: LocationsCountAggregateOutputType | null
    _avg: LocationsAvgAggregateOutputType | null
    _sum: LocationsSumAggregateOutputType | null
    _min: LocationsMinAggregateOutputType | null
    _max: LocationsMaxAggregateOutputType | null
  }

  type GetLocationsGroupByPayload<T extends locationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationsGroupByOutputType[P]>
            : GetScalarType<T[P], LocationsGroupByOutputType[P]>
        }
      >
    >


  export type locationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    ward?: boolean
    districtId?: boolean
    createdAt?: boolean
    Events?: boolean | locations$EventsArgs<ExtArgs>
    districts?: boolean | districtsDefaultArgs<ExtArgs>
    _count?: boolean | LocationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locations"]>

  export type locationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    ward?: boolean
    districtId?: boolean
    createdAt?: boolean
    districts?: boolean | districtsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locations"]>

  export type locationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    ward?: boolean
    districtId?: boolean
    createdAt?: boolean
    districts?: boolean | districtsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locations"]>

  export type locationsSelectScalar = {
    id?: boolean
    street?: boolean
    ward?: boolean
    districtId?: boolean
    createdAt?: boolean
  }

  export type locationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "street" | "ward" | "districtId" | "createdAt", ExtArgs["result"]["locations"]>
  export type locationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Events?: boolean | locations$EventsArgs<ExtArgs>
    districts?: boolean | districtsDefaultArgs<ExtArgs>
    _count?: boolean | LocationsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type locationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    districts?: boolean | districtsDefaultArgs<ExtArgs>
  }
  export type locationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    districts?: boolean | districtsDefaultArgs<ExtArgs>
  }

  export type $locationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "locations"
    objects: {
      Events: Prisma.$EventsPayload<ExtArgs>[]
      districts: Prisma.$districtsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      street: string
      ward: string
      districtId: number
      createdAt: Date
    }, ExtArgs["result"]["locations"]>
    composites: {}
  }

  type locationsGetPayload<S extends boolean | null | undefined | locationsDefaultArgs> = $Result.GetResult<Prisma.$locationsPayload, S>

  type locationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<locationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationsCountAggregateInputType | true
    }

  export interface locationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['locations'], meta: { name: 'locations' } }
    /**
     * Find zero or one Locations that matches the filter.
     * @param {locationsFindUniqueArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends locationsFindUniqueArgs>(args: SelectSubset<T, locationsFindUniqueArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Locations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {locationsFindUniqueOrThrowArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends locationsFindUniqueOrThrowArgs>(args: SelectSubset<T, locationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindFirstArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends locationsFindFirstArgs>(args?: SelectSubset<T, locationsFindFirstArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Locations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindFirstOrThrowArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends locationsFindFirstOrThrowArgs>(args?: SelectSubset<T, locationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.locations.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.locations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationsWithIdOnly = await prisma.locations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends locationsFindManyArgs>(args?: SelectSubset<T, locationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Locations.
     * @param {locationsCreateArgs} args - Arguments to create a Locations.
     * @example
     * // Create one Locations
     * const Locations = await prisma.locations.create({
     *   data: {
     *     // ... data to create a Locations
     *   }
     * })
     * 
     */
    create<T extends locationsCreateArgs>(args: SelectSubset<T, locationsCreateArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Locations.
     * @param {locationsCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const locations = await prisma.locations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends locationsCreateManyArgs>(args?: SelectSubset<T, locationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {locationsCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const locations = await prisma.locations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationsWithIdOnly = await prisma.locations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends locationsCreateManyAndReturnArgs>(args?: SelectSubset<T, locationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Locations.
     * @param {locationsDeleteArgs} args - Arguments to delete one Locations.
     * @example
     * // Delete one Locations
     * const Locations = await prisma.locations.delete({
     *   where: {
     *     // ... filter to delete one Locations
     *   }
     * })
     * 
     */
    delete<T extends locationsDeleteArgs>(args: SelectSubset<T, locationsDeleteArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Locations.
     * @param {locationsUpdateArgs} args - Arguments to update one Locations.
     * @example
     * // Update one Locations
     * const locations = await prisma.locations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends locationsUpdateArgs>(args: SelectSubset<T, locationsUpdateArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Locations.
     * @param {locationsDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.locations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends locationsDeleteManyArgs>(args?: SelectSubset<T, locationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const locations = await prisma.locations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends locationsUpdateManyArgs>(args: SelectSubset<T, locationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {locationsUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const locations = await prisma.locations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationsWithIdOnly = await prisma.locations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends locationsUpdateManyAndReturnArgs>(args: SelectSubset<T, locationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Locations.
     * @param {locationsUpsertArgs} args - Arguments to update or create a Locations.
     * @example
     * // Update or create a Locations
     * const locations = await prisma.locations.upsert({
     *   create: {
     *     // ... data to create a Locations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Locations we want to update
     *   }
     * })
     */
    upsert<T extends locationsUpsertArgs>(args: SelectSubset<T, locationsUpsertArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.locations.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends locationsCountArgs>(
      args?: Subset<T, locationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationsAggregateArgs>(args: Subset<T, LocationsAggregateArgs>): Prisma.PrismaPromise<GetLocationsAggregateType<T>>

    /**
     * Group by Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends locationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: locationsGroupByArgs['orderBy'] }
        : { orderBy?: locationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, locationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the locations model
   */
  readonly fields: locationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for locations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__locationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Events<T extends locations$EventsArgs<ExtArgs> = {}>(args?: Subset<T, locations$EventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    districts<T extends districtsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, districtsDefaultArgs<ExtArgs>>): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the locations model
   */ 
  interface locationsFieldRefs {
    readonly id: FieldRef<"locations", 'Int'>
    readonly street: FieldRef<"locations", 'String'>
    readonly ward: FieldRef<"locations", 'String'>
    readonly districtId: FieldRef<"locations", 'Int'>
    readonly createdAt: FieldRef<"locations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * locations findUnique
   */
  export type locationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where: locationsWhereUniqueInput
  }

  /**
   * locations findUniqueOrThrow
   */
  export type locationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where: locationsWhereUniqueInput
  }

  /**
   * locations findFirst
   */
  export type locationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationsOrderByWithRelationInput | locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * locations findFirstOrThrow
   */
  export type locationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationsOrderByWithRelationInput | locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * locations findMany
   */
  export type locationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationsOrderByWithRelationInput | locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * locations create
   */
  export type locationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    /**
     * The data needed to create a locations.
     */
    data: XOR<locationsCreateInput, locationsUncheckedCreateInput>
  }

  /**
   * locations createMany
   */
  export type locationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many locations.
     */
    data: locationsCreateManyInput | locationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * locations createManyAndReturn
   */
  export type locationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * The data used to create many locations.
     */
    data: locationsCreateManyInput | locationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * locations update
   */
  export type locationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    /**
     * The data needed to update a locations.
     */
    data: XOR<locationsUpdateInput, locationsUncheckedUpdateInput>
    /**
     * Choose, which locations to update.
     */
    where: locationsWhereUniqueInput
  }

  /**
   * locations updateMany
   */
  export type locationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update locations.
     */
    data: XOR<locationsUpdateManyMutationInput, locationsUncheckedUpdateManyInput>
    /**
     * Filter which locations to update
     */
    where?: locationsWhereInput
    /**
     * Limit how many locations to update.
     */
    limit?: number
  }

  /**
   * locations updateManyAndReturn
   */
  export type locationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * The data used to update locations.
     */
    data: XOR<locationsUpdateManyMutationInput, locationsUncheckedUpdateManyInput>
    /**
     * Filter which locations to update
     */
    where?: locationsWhereInput
    /**
     * Limit how many locations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * locations upsert
   */
  export type locationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    /**
     * The filter to search for the locations to update in case it exists.
     */
    where: locationsWhereUniqueInput
    /**
     * In case the locations found by the `where` argument doesn't exist, create a new locations with this data.
     */
    create: XOR<locationsCreateInput, locationsUncheckedCreateInput>
    /**
     * In case the locations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<locationsUpdateInput, locationsUncheckedUpdateInput>
  }

  /**
   * locations delete
   */
  export type locationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    /**
     * Filter which locations to delete.
     */
    where: locationsWhereUniqueInput
  }

  /**
   * locations deleteMany
   */
  export type locationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which locations to delete
     */
    where?: locationsWhereInput
    /**
     * Limit how many locations to delete.
     */
    limit?: number
  }

  /**
   * locations.Events
   */
  export type locations$EventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventsInclude<ExtArgs> | null
    where?: EventsWhereInput
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    cursor?: EventsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * locations without action
   */
  export type locationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
  }


  /**
   * Model Row
   */

  export type AggregateRow = {
    _count: RowCountAggregateOutputType | null
    _avg: RowAvgAggregateOutputType | null
    _sum: RowSumAggregateOutputType | null
    _min: RowMinAggregateOutputType | null
    _max: RowMaxAggregateOutputType | null
  }

  export type RowAvgAggregateOutputType = {
    id: number | null
    sectionId: number | null
  }

  export type RowSumAggregateOutputType = {
    id: number | null
    sectionId: number | null
  }

  export type RowMinAggregateOutputType = {
    id: number | null
    name: string | null
    sectionId: number | null
    createdAt: Date | null
  }

  export type RowMaxAggregateOutputType = {
    id: number | null
    name: string | null
    sectionId: number | null
    createdAt: Date | null
  }

  export type RowCountAggregateOutputType = {
    id: number
    name: number
    sectionId: number
    createdAt: number
    _all: number
  }


  export type RowAvgAggregateInputType = {
    id?: true
    sectionId?: true
  }

  export type RowSumAggregateInputType = {
    id?: true
    sectionId?: true
  }

  export type RowMinAggregateInputType = {
    id?: true
    name?: true
    sectionId?: true
    createdAt?: true
  }

  export type RowMaxAggregateInputType = {
    id?: true
    name?: true
    sectionId?: true
    createdAt?: true
  }

  export type RowCountAggregateInputType = {
    id?: true
    name?: true
    sectionId?: true
    createdAt?: true
    _all?: true
  }

  export type RowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Row to aggregate.
     */
    where?: RowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rows to fetch.
     */
    orderBy?: RowOrderByWithRelationInput | RowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rows
    **/
    _count?: true | RowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RowMaxAggregateInputType
  }

  export type GetRowAggregateType<T extends RowAggregateArgs> = {
        [P in keyof T & keyof AggregateRow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRow[P]>
      : GetScalarType<T[P], AggregateRow[P]>
  }




  export type RowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RowWhereInput
    orderBy?: RowOrderByWithAggregationInput | RowOrderByWithAggregationInput[]
    by: RowScalarFieldEnum[] | RowScalarFieldEnum
    having?: RowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RowCountAggregateInputType | true
    _avg?: RowAvgAggregateInputType
    _sum?: RowSumAggregateInputType
    _min?: RowMinAggregateInputType
    _max?: RowMaxAggregateInputType
  }

  export type RowGroupByOutputType = {
    id: number
    name: string
    sectionId: number
    createdAt: Date
    _count: RowCountAggregateOutputType | null
    _avg: RowAvgAggregateOutputType | null
    _sum: RowSumAggregateOutputType | null
    _min: RowMinAggregateOutputType | null
    _max: RowMaxAggregateOutputType | null
  }

  type GetRowGroupByPayload<T extends RowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RowGroupByOutputType[P]>
            : GetScalarType<T[P], RowGroupByOutputType[P]>
        }
      >
    >


  export type RowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    sectionId?: boolean
    createdAt?: boolean
    Section?: boolean | SectionDefaultArgs<ExtArgs>
    Seat?: boolean | Row$SeatArgs<ExtArgs>
    _count?: boolean | RowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["row"]>

  export type RowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    sectionId?: boolean
    createdAt?: boolean
    Section?: boolean | SectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["row"]>

  export type RowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    sectionId?: boolean
    createdAt?: boolean
    Section?: boolean | SectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["row"]>

  export type RowSelectScalar = {
    id?: boolean
    name?: boolean
    sectionId?: boolean
    createdAt?: boolean
  }

  export type RowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "sectionId" | "createdAt", ExtArgs["result"]["row"]>
  export type RowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Section?: boolean | SectionDefaultArgs<ExtArgs>
    Seat?: boolean | Row$SeatArgs<ExtArgs>
    _count?: boolean | RowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Section?: boolean | SectionDefaultArgs<ExtArgs>
  }
  export type RowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Section?: boolean | SectionDefaultArgs<ExtArgs>
  }

  export type $RowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Row"
    objects: {
      Section: Prisma.$SectionPayload<ExtArgs>
      Seat: Prisma.$SeatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      sectionId: number
      createdAt: Date
    }, ExtArgs["result"]["row"]>
    composites: {}
  }

  type RowGetPayload<S extends boolean | null | undefined | RowDefaultArgs> = $Result.GetResult<Prisma.$RowPayload, S>

  type RowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RowCountAggregateInputType | true
    }

  export interface RowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Row'], meta: { name: 'Row' } }
    /**
     * Find zero or one Row that matches the filter.
     * @param {RowFindUniqueArgs} args - Arguments to find a Row
     * @example
     * // Get one Row
     * const row = await prisma.row.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RowFindUniqueArgs>(args: SelectSubset<T, RowFindUniqueArgs<ExtArgs>>): Prisma__RowClient<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Row that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RowFindUniqueOrThrowArgs} args - Arguments to find a Row
     * @example
     * // Get one Row
     * const row = await prisma.row.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RowFindUniqueOrThrowArgs>(args: SelectSubset<T, RowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RowClient<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Row that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RowFindFirstArgs} args - Arguments to find a Row
     * @example
     * // Get one Row
     * const row = await prisma.row.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RowFindFirstArgs>(args?: SelectSubset<T, RowFindFirstArgs<ExtArgs>>): Prisma__RowClient<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Row that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RowFindFirstOrThrowArgs} args - Arguments to find a Row
     * @example
     * // Get one Row
     * const row = await prisma.row.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RowFindFirstOrThrowArgs>(args?: SelectSubset<T, RowFindFirstOrThrowArgs<ExtArgs>>): Prisma__RowClient<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Rows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rows
     * const rows = await prisma.row.findMany()
     * 
     * // Get first 10 Rows
     * const rows = await prisma.row.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rowWithIdOnly = await prisma.row.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RowFindManyArgs>(args?: SelectSubset<T, RowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Row.
     * @param {RowCreateArgs} args - Arguments to create a Row.
     * @example
     * // Create one Row
     * const Row = await prisma.row.create({
     *   data: {
     *     // ... data to create a Row
     *   }
     * })
     * 
     */
    create<T extends RowCreateArgs>(args: SelectSubset<T, RowCreateArgs<ExtArgs>>): Prisma__RowClient<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Rows.
     * @param {RowCreateManyArgs} args - Arguments to create many Rows.
     * @example
     * // Create many Rows
     * const row = await prisma.row.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RowCreateManyArgs>(args?: SelectSubset<T, RowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rows and returns the data saved in the database.
     * @param {RowCreateManyAndReturnArgs} args - Arguments to create many Rows.
     * @example
     * // Create many Rows
     * const row = await prisma.row.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rows and only return the `id`
     * const rowWithIdOnly = await prisma.row.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RowCreateManyAndReturnArgs>(args?: SelectSubset<T, RowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Row.
     * @param {RowDeleteArgs} args - Arguments to delete one Row.
     * @example
     * // Delete one Row
     * const Row = await prisma.row.delete({
     *   where: {
     *     // ... filter to delete one Row
     *   }
     * })
     * 
     */
    delete<T extends RowDeleteArgs>(args: SelectSubset<T, RowDeleteArgs<ExtArgs>>): Prisma__RowClient<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Row.
     * @param {RowUpdateArgs} args - Arguments to update one Row.
     * @example
     * // Update one Row
     * const row = await prisma.row.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RowUpdateArgs>(args: SelectSubset<T, RowUpdateArgs<ExtArgs>>): Prisma__RowClient<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Rows.
     * @param {RowDeleteManyArgs} args - Arguments to filter Rows to delete.
     * @example
     * // Delete a few Rows
     * const { count } = await prisma.row.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RowDeleteManyArgs>(args?: SelectSubset<T, RowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rows
     * const row = await prisma.row.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RowUpdateManyArgs>(args: SelectSubset<T, RowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rows and returns the data updated in the database.
     * @param {RowUpdateManyAndReturnArgs} args - Arguments to update many Rows.
     * @example
     * // Update many Rows
     * const row = await prisma.row.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rows and only return the `id`
     * const rowWithIdOnly = await prisma.row.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RowUpdateManyAndReturnArgs>(args: SelectSubset<T, RowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Row.
     * @param {RowUpsertArgs} args - Arguments to update or create a Row.
     * @example
     * // Update or create a Row
     * const row = await prisma.row.upsert({
     *   create: {
     *     // ... data to create a Row
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Row we want to update
     *   }
     * })
     */
    upsert<T extends RowUpsertArgs>(args: SelectSubset<T, RowUpsertArgs<ExtArgs>>): Prisma__RowClient<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Rows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RowCountArgs} args - Arguments to filter Rows to count.
     * @example
     * // Count the number of Rows
     * const count = await prisma.row.count({
     *   where: {
     *     // ... the filter for the Rows we want to count
     *   }
     * })
    **/
    count<T extends RowCountArgs>(
      args?: Subset<T, RowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Row.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RowAggregateArgs>(args: Subset<T, RowAggregateArgs>): Prisma.PrismaPromise<GetRowAggregateType<T>>

    /**
     * Group by Row.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RowGroupByArgs['orderBy'] }
        : { orderBy?: RowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Row model
   */
  readonly fields: RowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Row.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Seat<T extends Row$SeatArgs<ExtArgs> = {}>(args?: Subset<T, Row$SeatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Row model
   */ 
  interface RowFieldRefs {
    readonly id: FieldRef<"Row", 'Int'>
    readonly name: FieldRef<"Row", 'String'>
    readonly sectionId: FieldRef<"Row", 'Int'>
    readonly createdAt: FieldRef<"Row", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Row findUnique
   */
  export type RowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
    /**
     * Filter, which Row to fetch.
     */
    where: RowWhereUniqueInput
  }

  /**
   * Row findUniqueOrThrow
   */
  export type RowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
    /**
     * Filter, which Row to fetch.
     */
    where: RowWhereUniqueInput
  }

  /**
   * Row findFirst
   */
  export type RowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
    /**
     * Filter, which Row to fetch.
     */
    where?: RowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rows to fetch.
     */
    orderBy?: RowOrderByWithRelationInput | RowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rows.
     */
    cursor?: RowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rows.
     */
    distinct?: RowScalarFieldEnum | RowScalarFieldEnum[]
  }

  /**
   * Row findFirstOrThrow
   */
  export type RowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
    /**
     * Filter, which Row to fetch.
     */
    where?: RowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rows to fetch.
     */
    orderBy?: RowOrderByWithRelationInput | RowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rows.
     */
    cursor?: RowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rows.
     */
    distinct?: RowScalarFieldEnum | RowScalarFieldEnum[]
  }

  /**
   * Row findMany
   */
  export type RowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
    /**
     * Filter, which Rows to fetch.
     */
    where?: RowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rows to fetch.
     */
    orderBy?: RowOrderByWithRelationInput | RowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rows.
     */
    cursor?: RowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rows.
     */
    skip?: number
    distinct?: RowScalarFieldEnum | RowScalarFieldEnum[]
  }

  /**
   * Row create
   */
  export type RowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
    /**
     * The data needed to create a Row.
     */
    data: XOR<RowCreateInput, RowUncheckedCreateInput>
  }

  /**
   * Row createMany
   */
  export type RowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rows.
     */
    data: RowCreateManyInput | RowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Row createManyAndReturn
   */
  export type RowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * The data used to create many Rows.
     */
    data: RowCreateManyInput | RowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Row update
   */
  export type RowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
    /**
     * The data needed to update a Row.
     */
    data: XOR<RowUpdateInput, RowUncheckedUpdateInput>
    /**
     * Choose, which Row to update.
     */
    where: RowWhereUniqueInput
  }

  /**
   * Row updateMany
   */
  export type RowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rows.
     */
    data: XOR<RowUpdateManyMutationInput, RowUncheckedUpdateManyInput>
    /**
     * Filter which Rows to update
     */
    where?: RowWhereInput
    /**
     * Limit how many Rows to update.
     */
    limit?: number
  }

  /**
   * Row updateManyAndReturn
   */
  export type RowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * The data used to update Rows.
     */
    data: XOR<RowUpdateManyMutationInput, RowUncheckedUpdateManyInput>
    /**
     * Filter which Rows to update
     */
    where?: RowWhereInput
    /**
     * Limit how many Rows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Row upsert
   */
  export type RowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
    /**
     * The filter to search for the Row to update in case it exists.
     */
    where: RowWhereUniqueInput
    /**
     * In case the Row found by the `where` argument doesn't exist, create a new Row with this data.
     */
    create: XOR<RowCreateInput, RowUncheckedCreateInput>
    /**
     * In case the Row was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RowUpdateInput, RowUncheckedUpdateInput>
  }

  /**
   * Row delete
   */
  export type RowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
    /**
     * Filter which Row to delete.
     */
    where: RowWhereUniqueInput
  }

  /**
   * Row deleteMany
   */
  export type RowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rows to delete
     */
    where?: RowWhereInput
    /**
     * Limit how many Rows to delete.
     */
    limit?: number
  }

  /**
   * Row.Seat
   */
  export type Row$SeatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    where?: SeatWhereInput
    orderBy?: SeatOrderByWithRelationInput | SeatOrderByWithRelationInput[]
    cursor?: SeatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * Row without action
   */
  export type RowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
  }


  /**
   * Model Seat
   */

  export type AggregateSeat = {
    _count: SeatCountAggregateOutputType | null
    _avg: SeatAvgAggregateOutputType | null
    _sum: SeatSumAggregateOutputType | null
    _min: SeatMinAggregateOutputType | null
    _max: SeatMaxAggregateOutputType | null
  }

  export type SeatAvgAggregateOutputType = {
    id: number | null
    rowId: number | null
    positionX: number | null
    positionY: number | null
    position: number | null
  }

  export type SeatSumAggregateOutputType = {
    id: number | null
    rowId: number | null
    positionX: number | null
    positionY: number | null
    position: number | null
  }

  export type SeatMinAggregateOutputType = {
    id: number | null
    name: string | null
    rowId: number | null
    positionX: number | null
    positionY: number | null
    createdAt: Date | null
    position: number | null
  }

  export type SeatMaxAggregateOutputType = {
    id: number | null
    name: string | null
    rowId: number | null
    positionX: number | null
    positionY: number | null
    createdAt: Date | null
    position: number | null
  }

  export type SeatCountAggregateOutputType = {
    id: number
    name: number
    rowId: number
    positionX: number
    positionY: number
    createdAt: number
    position: number
    _all: number
  }


  export type SeatAvgAggregateInputType = {
    id?: true
    rowId?: true
    positionX?: true
    positionY?: true
    position?: true
  }

  export type SeatSumAggregateInputType = {
    id?: true
    rowId?: true
    positionX?: true
    positionY?: true
    position?: true
  }

  export type SeatMinAggregateInputType = {
    id?: true
    name?: true
    rowId?: true
    positionX?: true
    positionY?: true
    createdAt?: true
    position?: true
  }

  export type SeatMaxAggregateInputType = {
    id?: true
    name?: true
    rowId?: true
    positionX?: true
    positionY?: true
    createdAt?: true
    position?: true
  }

  export type SeatCountAggregateInputType = {
    id?: true
    name?: true
    rowId?: true
    positionX?: true
    positionY?: true
    createdAt?: true
    position?: true
    _all?: true
  }

  export type SeatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seat to aggregate.
     */
    where?: SeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seats to fetch.
     */
    orderBy?: SeatOrderByWithRelationInput | SeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Seats
    **/
    _count?: true | SeatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeatMaxAggregateInputType
  }

  export type GetSeatAggregateType<T extends SeatAggregateArgs> = {
        [P in keyof T & keyof AggregateSeat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeat[P]>
      : GetScalarType<T[P], AggregateSeat[P]>
  }




  export type SeatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatWhereInput
    orderBy?: SeatOrderByWithAggregationInput | SeatOrderByWithAggregationInput[]
    by: SeatScalarFieldEnum[] | SeatScalarFieldEnum
    having?: SeatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeatCountAggregateInputType | true
    _avg?: SeatAvgAggregateInputType
    _sum?: SeatSumAggregateInputType
    _min?: SeatMinAggregateInputType
    _max?: SeatMaxAggregateInputType
  }

  export type SeatGroupByOutputType = {
    id: number
    name: string
    rowId: number
    positionX: number
    positionY: number
    createdAt: Date
    position: number
    _count: SeatCountAggregateOutputType | null
    _avg: SeatAvgAggregateOutputType | null
    _sum: SeatSumAggregateOutputType | null
    _min: SeatMinAggregateOutputType | null
    _max: SeatMaxAggregateOutputType | null
  }

  type GetSeatGroupByPayload<T extends SeatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeatGroupByOutputType[P]>
            : GetScalarType<T[P], SeatGroupByOutputType[P]>
        }
      >
    >


  export type SeatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    rowId?: boolean
    positionX?: boolean
    positionY?: boolean
    createdAt?: boolean
    position?: boolean
    Row?: boolean | RowDefaultArgs<ExtArgs>
    Ticket?: boolean | Seat$TicketArgs<ExtArgs>
    _count?: boolean | SeatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seat"]>

  export type SeatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    rowId?: boolean
    positionX?: boolean
    positionY?: boolean
    createdAt?: boolean
    position?: boolean
    Row?: boolean | RowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seat"]>

  export type SeatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    rowId?: boolean
    positionX?: boolean
    positionY?: boolean
    createdAt?: boolean
    position?: boolean
    Row?: boolean | RowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seat"]>

  export type SeatSelectScalar = {
    id?: boolean
    name?: boolean
    rowId?: boolean
    positionX?: boolean
    positionY?: boolean
    createdAt?: boolean
    position?: boolean
  }

  export type SeatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "rowId" | "positionX" | "positionY" | "createdAt" | "position", ExtArgs["result"]["seat"]>
  export type SeatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Row?: boolean | RowDefaultArgs<ExtArgs>
    Ticket?: boolean | Seat$TicketArgs<ExtArgs>
    _count?: boolean | SeatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Row?: boolean | RowDefaultArgs<ExtArgs>
  }
  export type SeatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Row?: boolean | RowDefaultArgs<ExtArgs>
  }

  export type $SeatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Seat"
    objects: {
      Row: Prisma.$RowPayload<ExtArgs>
      Ticket: Prisma.$TicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      rowId: number
      positionX: number
      positionY: number
      createdAt: Date
      position: number
    }, ExtArgs["result"]["seat"]>
    composites: {}
  }

  type SeatGetPayload<S extends boolean | null | undefined | SeatDefaultArgs> = $Result.GetResult<Prisma.$SeatPayload, S>

  type SeatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeatCountAggregateInputType | true
    }

  export interface SeatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Seat'], meta: { name: 'Seat' } }
    /**
     * Find zero or one Seat that matches the filter.
     * @param {SeatFindUniqueArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeatFindUniqueArgs>(args: SelectSubset<T, SeatFindUniqueArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Seat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeatFindUniqueOrThrowArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeatFindUniqueOrThrowArgs>(args: SelectSubset<T, SeatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Seat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatFindFirstArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeatFindFirstArgs>(args?: SelectSubset<T, SeatFindFirstArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Seat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatFindFirstOrThrowArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeatFindFirstOrThrowArgs>(args?: SelectSubset<T, SeatFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Seats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seats
     * const seats = await prisma.seat.findMany()
     * 
     * // Get first 10 Seats
     * const seats = await prisma.seat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seatWithIdOnly = await prisma.seat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeatFindManyArgs>(args?: SelectSubset<T, SeatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Seat.
     * @param {SeatCreateArgs} args - Arguments to create a Seat.
     * @example
     * // Create one Seat
     * const Seat = await prisma.seat.create({
     *   data: {
     *     // ... data to create a Seat
     *   }
     * })
     * 
     */
    create<T extends SeatCreateArgs>(args: SelectSubset<T, SeatCreateArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Seats.
     * @param {SeatCreateManyArgs} args - Arguments to create many Seats.
     * @example
     * // Create many Seats
     * const seat = await prisma.seat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeatCreateManyArgs>(args?: SelectSubset<T, SeatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Seats and returns the data saved in the database.
     * @param {SeatCreateManyAndReturnArgs} args - Arguments to create many Seats.
     * @example
     * // Create many Seats
     * const seat = await prisma.seat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Seats and only return the `id`
     * const seatWithIdOnly = await prisma.seat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeatCreateManyAndReturnArgs>(args?: SelectSubset<T, SeatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Seat.
     * @param {SeatDeleteArgs} args - Arguments to delete one Seat.
     * @example
     * // Delete one Seat
     * const Seat = await prisma.seat.delete({
     *   where: {
     *     // ... filter to delete one Seat
     *   }
     * })
     * 
     */
    delete<T extends SeatDeleteArgs>(args: SelectSubset<T, SeatDeleteArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Seat.
     * @param {SeatUpdateArgs} args - Arguments to update one Seat.
     * @example
     * // Update one Seat
     * const seat = await prisma.seat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeatUpdateArgs>(args: SelectSubset<T, SeatUpdateArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Seats.
     * @param {SeatDeleteManyArgs} args - Arguments to filter Seats to delete.
     * @example
     * // Delete a few Seats
     * const { count } = await prisma.seat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeatDeleteManyArgs>(args?: SelectSubset<T, SeatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seats
     * const seat = await prisma.seat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeatUpdateManyArgs>(args: SelectSubset<T, SeatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seats and returns the data updated in the database.
     * @param {SeatUpdateManyAndReturnArgs} args - Arguments to update many Seats.
     * @example
     * // Update many Seats
     * const seat = await prisma.seat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Seats and only return the `id`
     * const seatWithIdOnly = await prisma.seat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeatUpdateManyAndReturnArgs>(args: SelectSubset<T, SeatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Seat.
     * @param {SeatUpsertArgs} args - Arguments to update or create a Seat.
     * @example
     * // Update or create a Seat
     * const seat = await prisma.seat.upsert({
     *   create: {
     *     // ... data to create a Seat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seat we want to update
     *   }
     * })
     */
    upsert<T extends SeatUpsertArgs>(args: SelectSubset<T, SeatUpsertArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Seats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatCountArgs} args - Arguments to filter Seats to count.
     * @example
     * // Count the number of Seats
     * const count = await prisma.seat.count({
     *   where: {
     *     // ... the filter for the Seats we want to count
     *   }
     * })
    **/
    count<T extends SeatCountArgs>(
      args?: Subset<T, SeatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeatAggregateArgs>(args: Subset<T, SeatAggregateArgs>): Prisma.PrismaPromise<GetSeatAggregateType<T>>

    /**
     * Group by Seat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeatGroupByArgs['orderBy'] }
        : { orderBy?: SeatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Seat model
   */
  readonly fields: SeatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Seat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Row<T extends RowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RowDefaultArgs<ExtArgs>>): Prisma__RowClient<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Ticket<T extends Seat$TicketArgs<ExtArgs> = {}>(args?: Subset<T, Seat$TicketArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Seat model
   */ 
  interface SeatFieldRefs {
    readonly id: FieldRef<"Seat", 'Int'>
    readonly name: FieldRef<"Seat", 'String'>
    readonly rowId: FieldRef<"Seat", 'Int'>
    readonly positionX: FieldRef<"Seat", 'Float'>
    readonly positionY: FieldRef<"Seat", 'Float'>
    readonly createdAt: FieldRef<"Seat", 'DateTime'>
    readonly position: FieldRef<"Seat", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Seat findUnique
   */
  export type SeatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter, which Seat to fetch.
     */
    where: SeatWhereUniqueInput
  }

  /**
   * Seat findUniqueOrThrow
   */
  export type SeatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter, which Seat to fetch.
     */
    where: SeatWhereUniqueInput
  }

  /**
   * Seat findFirst
   */
  export type SeatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter, which Seat to fetch.
     */
    where?: SeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seats to fetch.
     */
    orderBy?: SeatOrderByWithRelationInput | SeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seats.
     */
    cursor?: SeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seats.
     */
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * Seat findFirstOrThrow
   */
  export type SeatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter, which Seat to fetch.
     */
    where?: SeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seats to fetch.
     */
    orderBy?: SeatOrderByWithRelationInput | SeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seats.
     */
    cursor?: SeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seats.
     */
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * Seat findMany
   */
  export type SeatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter, which Seats to fetch.
     */
    where?: SeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seats to fetch.
     */
    orderBy?: SeatOrderByWithRelationInput | SeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Seats.
     */
    cursor?: SeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seats.
     */
    skip?: number
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * Seat create
   */
  export type SeatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * The data needed to create a Seat.
     */
    data: XOR<SeatCreateInput, SeatUncheckedCreateInput>
  }

  /**
   * Seat createMany
   */
  export type SeatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Seats.
     */
    data: SeatCreateManyInput | SeatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Seat createManyAndReturn
   */
  export type SeatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * The data used to create many Seats.
     */
    data: SeatCreateManyInput | SeatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Seat update
   */
  export type SeatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * The data needed to update a Seat.
     */
    data: XOR<SeatUpdateInput, SeatUncheckedUpdateInput>
    /**
     * Choose, which Seat to update.
     */
    where: SeatWhereUniqueInput
  }

  /**
   * Seat updateMany
   */
  export type SeatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Seats.
     */
    data: XOR<SeatUpdateManyMutationInput, SeatUncheckedUpdateManyInput>
    /**
     * Filter which Seats to update
     */
    where?: SeatWhereInput
    /**
     * Limit how many Seats to update.
     */
    limit?: number
  }

  /**
   * Seat updateManyAndReturn
   */
  export type SeatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * The data used to update Seats.
     */
    data: XOR<SeatUpdateManyMutationInput, SeatUncheckedUpdateManyInput>
    /**
     * Filter which Seats to update
     */
    where?: SeatWhereInput
    /**
     * Limit how many Seats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Seat upsert
   */
  export type SeatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * The filter to search for the Seat to update in case it exists.
     */
    where: SeatWhereUniqueInput
    /**
     * In case the Seat found by the `where` argument doesn't exist, create a new Seat with this data.
     */
    create: XOR<SeatCreateInput, SeatUncheckedCreateInput>
    /**
     * In case the Seat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeatUpdateInput, SeatUncheckedUpdateInput>
  }

  /**
   * Seat delete
   */
  export type SeatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter which Seat to delete.
     */
    where: SeatWhereUniqueInput
  }

  /**
   * Seat deleteMany
   */
  export type SeatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seats to delete
     */
    where?: SeatWhereInput
    /**
     * Limit how many Seats to delete.
     */
    limit?: number
  }

  /**
   * Seat.Ticket
   */
  export type Seat$TicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Seat without action
   */
  export type SeatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
  }


  /**
   * Model Seatmap
   */

  export type AggregateSeatmap = {
    _count: SeatmapCountAggregateOutputType | null
    _avg: SeatmapAvgAggregateOutputType | null
    _sum: SeatmapSumAggregateOutputType | null
    _min: SeatmapMinAggregateOutputType | null
    _max: SeatmapMaxAggregateOutputType | null
  }

  export type SeatmapAvgAggregateOutputType = {
    id: number | null
    status: number | null
  }

  export type SeatmapSumAggregateOutputType = {
    id: number | null
    status: number | null
  }

  export type SeatmapMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    viewBox: string | null
    status: number | null
  }

  export type SeatmapMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    viewBox: string | null
    status: number | null
  }

  export type SeatmapCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    viewBox: number
    status: number
    _all: number
  }


  export type SeatmapAvgAggregateInputType = {
    id?: true
    status?: true
  }

  export type SeatmapSumAggregateInputType = {
    id?: true
    status?: true
  }

  export type SeatmapMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    viewBox?: true
    status?: true
  }

  export type SeatmapMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    viewBox?: true
    status?: true
  }

  export type SeatmapCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    viewBox?: true
    status?: true
    _all?: true
  }

  export type SeatmapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seatmap to aggregate.
     */
    where?: SeatmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seatmaps to fetch.
     */
    orderBy?: SeatmapOrderByWithRelationInput | SeatmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeatmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seatmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seatmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Seatmaps
    **/
    _count?: true | SeatmapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeatmapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeatmapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeatmapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeatmapMaxAggregateInputType
  }

  export type GetSeatmapAggregateType<T extends SeatmapAggregateArgs> = {
        [P in keyof T & keyof AggregateSeatmap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeatmap[P]>
      : GetScalarType<T[P], AggregateSeatmap[P]>
  }




  export type SeatmapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatmapWhereInput
    orderBy?: SeatmapOrderByWithAggregationInput | SeatmapOrderByWithAggregationInput[]
    by: SeatmapScalarFieldEnum[] | SeatmapScalarFieldEnum
    having?: SeatmapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeatmapCountAggregateInputType | true
    _avg?: SeatmapAvgAggregateInputType
    _sum?: SeatmapSumAggregateInputType
    _min?: SeatmapMinAggregateInputType
    _max?: SeatmapMaxAggregateInputType
  }

  export type SeatmapGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    viewBox: string
    status: number
    _count: SeatmapCountAggregateOutputType | null
    _avg: SeatmapAvgAggregateOutputType | null
    _sum: SeatmapSumAggregateOutputType | null
    _min: SeatmapMinAggregateOutputType | null
    _max: SeatmapMaxAggregateOutputType | null
  }

  type GetSeatmapGroupByPayload<T extends SeatmapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeatmapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeatmapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeatmapGroupByOutputType[P]>
            : GetScalarType<T[P], SeatmapGroupByOutputType[P]>
        }
      >
    >


  export type SeatmapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    viewBox?: boolean
    status?: boolean
    Section?: boolean | Seatmap$SectionArgs<ExtArgs>
    Showing?: boolean | Seatmap$ShowingArgs<ExtArgs>
    _count?: boolean | SeatmapCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seatmap"]>

  export type SeatmapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    viewBox?: boolean
    status?: boolean
  }, ExtArgs["result"]["seatmap"]>

  export type SeatmapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    viewBox?: boolean
    status?: boolean
  }, ExtArgs["result"]["seatmap"]>

  export type SeatmapSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    viewBox?: boolean
    status?: boolean
  }

  export type SeatmapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "viewBox" | "status", ExtArgs["result"]["seatmap"]>
  export type SeatmapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Section?: boolean | Seatmap$SectionArgs<ExtArgs>
    Showing?: boolean | Seatmap$ShowingArgs<ExtArgs>
    _count?: boolean | SeatmapCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeatmapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SeatmapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SeatmapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Seatmap"
    objects: {
      Section: Prisma.$SectionPayload<ExtArgs>[]
      Showing: Prisma.$ShowingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      viewBox: string
      status: number
    }, ExtArgs["result"]["seatmap"]>
    composites: {}
  }

  type SeatmapGetPayload<S extends boolean | null | undefined | SeatmapDefaultArgs> = $Result.GetResult<Prisma.$SeatmapPayload, S>

  type SeatmapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeatmapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeatmapCountAggregateInputType | true
    }

  export interface SeatmapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Seatmap'], meta: { name: 'Seatmap' } }
    /**
     * Find zero or one Seatmap that matches the filter.
     * @param {SeatmapFindUniqueArgs} args - Arguments to find a Seatmap
     * @example
     * // Get one Seatmap
     * const seatmap = await prisma.seatmap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeatmapFindUniqueArgs>(args: SelectSubset<T, SeatmapFindUniqueArgs<ExtArgs>>): Prisma__SeatmapClient<$Result.GetResult<Prisma.$SeatmapPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Seatmap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeatmapFindUniqueOrThrowArgs} args - Arguments to find a Seatmap
     * @example
     * // Get one Seatmap
     * const seatmap = await prisma.seatmap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeatmapFindUniqueOrThrowArgs>(args: SelectSubset<T, SeatmapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeatmapClient<$Result.GetResult<Prisma.$SeatmapPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Seatmap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatmapFindFirstArgs} args - Arguments to find a Seatmap
     * @example
     * // Get one Seatmap
     * const seatmap = await prisma.seatmap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeatmapFindFirstArgs>(args?: SelectSubset<T, SeatmapFindFirstArgs<ExtArgs>>): Prisma__SeatmapClient<$Result.GetResult<Prisma.$SeatmapPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Seatmap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatmapFindFirstOrThrowArgs} args - Arguments to find a Seatmap
     * @example
     * // Get one Seatmap
     * const seatmap = await prisma.seatmap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeatmapFindFirstOrThrowArgs>(args?: SelectSubset<T, SeatmapFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeatmapClient<$Result.GetResult<Prisma.$SeatmapPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Seatmaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatmapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seatmaps
     * const seatmaps = await prisma.seatmap.findMany()
     * 
     * // Get first 10 Seatmaps
     * const seatmaps = await prisma.seatmap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seatmapWithIdOnly = await prisma.seatmap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeatmapFindManyArgs>(args?: SelectSubset<T, SeatmapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatmapPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Seatmap.
     * @param {SeatmapCreateArgs} args - Arguments to create a Seatmap.
     * @example
     * // Create one Seatmap
     * const Seatmap = await prisma.seatmap.create({
     *   data: {
     *     // ... data to create a Seatmap
     *   }
     * })
     * 
     */
    create<T extends SeatmapCreateArgs>(args: SelectSubset<T, SeatmapCreateArgs<ExtArgs>>): Prisma__SeatmapClient<$Result.GetResult<Prisma.$SeatmapPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Seatmaps.
     * @param {SeatmapCreateManyArgs} args - Arguments to create many Seatmaps.
     * @example
     * // Create many Seatmaps
     * const seatmap = await prisma.seatmap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeatmapCreateManyArgs>(args?: SelectSubset<T, SeatmapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Seatmaps and returns the data saved in the database.
     * @param {SeatmapCreateManyAndReturnArgs} args - Arguments to create many Seatmaps.
     * @example
     * // Create many Seatmaps
     * const seatmap = await prisma.seatmap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Seatmaps and only return the `id`
     * const seatmapWithIdOnly = await prisma.seatmap.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeatmapCreateManyAndReturnArgs>(args?: SelectSubset<T, SeatmapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatmapPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Seatmap.
     * @param {SeatmapDeleteArgs} args - Arguments to delete one Seatmap.
     * @example
     * // Delete one Seatmap
     * const Seatmap = await prisma.seatmap.delete({
     *   where: {
     *     // ... filter to delete one Seatmap
     *   }
     * })
     * 
     */
    delete<T extends SeatmapDeleteArgs>(args: SelectSubset<T, SeatmapDeleteArgs<ExtArgs>>): Prisma__SeatmapClient<$Result.GetResult<Prisma.$SeatmapPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Seatmap.
     * @param {SeatmapUpdateArgs} args - Arguments to update one Seatmap.
     * @example
     * // Update one Seatmap
     * const seatmap = await prisma.seatmap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeatmapUpdateArgs>(args: SelectSubset<T, SeatmapUpdateArgs<ExtArgs>>): Prisma__SeatmapClient<$Result.GetResult<Prisma.$SeatmapPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Seatmaps.
     * @param {SeatmapDeleteManyArgs} args - Arguments to filter Seatmaps to delete.
     * @example
     * // Delete a few Seatmaps
     * const { count } = await prisma.seatmap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeatmapDeleteManyArgs>(args?: SelectSubset<T, SeatmapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seatmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatmapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seatmaps
     * const seatmap = await prisma.seatmap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeatmapUpdateManyArgs>(args: SelectSubset<T, SeatmapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seatmaps and returns the data updated in the database.
     * @param {SeatmapUpdateManyAndReturnArgs} args - Arguments to update many Seatmaps.
     * @example
     * // Update many Seatmaps
     * const seatmap = await prisma.seatmap.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Seatmaps and only return the `id`
     * const seatmapWithIdOnly = await prisma.seatmap.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeatmapUpdateManyAndReturnArgs>(args: SelectSubset<T, SeatmapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatmapPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Seatmap.
     * @param {SeatmapUpsertArgs} args - Arguments to update or create a Seatmap.
     * @example
     * // Update or create a Seatmap
     * const seatmap = await prisma.seatmap.upsert({
     *   create: {
     *     // ... data to create a Seatmap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seatmap we want to update
     *   }
     * })
     */
    upsert<T extends SeatmapUpsertArgs>(args: SelectSubset<T, SeatmapUpsertArgs<ExtArgs>>): Prisma__SeatmapClient<$Result.GetResult<Prisma.$SeatmapPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Seatmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatmapCountArgs} args - Arguments to filter Seatmaps to count.
     * @example
     * // Count the number of Seatmaps
     * const count = await prisma.seatmap.count({
     *   where: {
     *     // ... the filter for the Seatmaps we want to count
     *   }
     * })
    **/
    count<T extends SeatmapCountArgs>(
      args?: Subset<T, SeatmapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeatmapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seatmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatmapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeatmapAggregateArgs>(args: Subset<T, SeatmapAggregateArgs>): Prisma.PrismaPromise<GetSeatmapAggregateType<T>>

    /**
     * Group by Seatmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatmapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeatmapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeatmapGroupByArgs['orderBy'] }
        : { orderBy?: SeatmapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeatmapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeatmapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Seatmap model
   */
  readonly fields: SeatmapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Seatmap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeatmapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Section<T extends Seatmap$SectionArgs<ExtArgs> = {}>(args?: Subset<T, Seatmap$SectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Showing<T extends Seatmap$ShowingArgs<ExtArgs> = {}>(args?: Subset<T, Seatmap$ShowingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Seatmap model
   */ 
  interface SeatmapFieldRefs {
    readonly id: FieldRef<"Seatmap", 'Int'>
    readonly name: FieldRef<"Seatmap", 'String'>
    readonly createdAt: FieldRef<"Seatmap", 'DateTime'>
    readonly viewBox: FieldRef<"Seatmap", 'String'>
    readonly status: FieldRef<"Seatmap", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Seatmap findUnique
   */
  export type SeatmapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seatmap
     */
    select?: SeatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seatmap
     */
    omit?: SeatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatmapInclude<ExtArgs> | null
    /**
     * Filter, which Seatmap to fetch.
     */
    where: SeatmapWhereUniqueInput
  }

  /**
   * Seatmap findUniqueOrThrow
   */
  export type SeatmapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seatmap
     */
    select?: SeatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seatmap
     */
    omit?: SeatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatmapInclude<ExtArgs> | null
    /**
     * Filter, which Seatmap to fetch.
     */
    where: SeatmapWhereUniqueInput
  }

  /**
   * Seatmap findFirst
   */
  export type SeatmapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seatmap
     */
    select?: SeatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seatmap
     */
    omit?: SeatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatmapInclude<ExtArgs> | null
    /**
     * Filter, which Seatmap to fetch.
     */
    where?: SeatmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seatmaps to fetch.
     */
    orderBy?: SeatmapOrderByWithRelationInput | SeatmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seatmaps.
     */
    cursor?: SeatmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seatmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seatmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seatmaps.
     */
    distinct?: SeatmapScalarFieldEnum | SeatmapScalarFieldEnum[]
  }

  /**
   * Seatmap findFirstOrThrow
   */
  export type SeatmapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seatmap
     */
    select?: SeatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seatmap
     */
    omit?: SeatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatmapInclude<ExtArgs> | null
    /**
     * Filter, which Seatmap to fetch.
     */
    where?: SeatmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seatmaps to fetch.
     */
    orderBy?: SeatmapOrderByWithRelationInput | SeatmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seatmaps.
     */
    cursor?: SeatmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seatmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seatmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seatmaps.
     */
    distinct?: SeatmapScalarFieldEnum | SeatmapScalarFieldEnum[]
  }

  /**
   * Seatmap findMany
   */
  export type SeatmapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seatmap
     */
    select?: SeatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seatmap
     */
    omit?: SeatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatmapInclude<ExtArgs> | null
    /**
     * Filter, which Seatmaps to fetch.
     */
    where?: SeatmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seatmaps to fetch.
     */
    orderBy?: SeatmapOrderByWithRelationInput | SeatmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Seatmaps.
     */
    cursor?: SeatmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seatmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seatmaps.
     */
    skip?: number
    distinct?: SeatmapScalarFieldEnum | SeatmapScalarFieldEnum[]
  }

  /**
   * Seatmap create
   */
  export type SeatmapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seatmap
     */
    select?: SeatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seatmap
     */
    omit?: SeatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatmapInclude<ExtArgs> | null
    /**
     * The data needed to create a Seatmap.
     */
    data: XOR<SeatmapCreateInput, SeatmapUncheckedCreateInput>
  }

  /**
   * Seatmap createMany
   */
  export type SeatmapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Seatmaps.
     */
    data: SeatmapCreateManyInput | SeatmapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Seatmap createManyAndReturn
   */
  export type SeatmapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seatmap
     */
    select?: SeatmapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Seatmap
     */
    omit?: SeatmapOmit<ExtArgs> | null
    /**
     * The data used to create many Seatmaps.
     */
    data: SeatmapCreateManyInput | SeatmapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Seatmap update
   */
  export type SeatmapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seatmap
     */
    select?: SeatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seatmap
     */
    omit?: SeatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatmapInclude<ExtArgs> | null
    /**
     * The data needed to update a Seatmap.
     */
    data: XOR<SeatmapUpdateInput, SeatmapUncheckedUpdateInput>
    /**
     * Choose, which Seatmap to update.
     */
    where: SeatmapWhereUniqueInput
  }

  /**
   * Seatmap updateMany
   */
  export type SeatmapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Seatmaps.
     */
    data: XOR<SeatmapUpdateManyMutationInput, SeatmapUncheckedUpdateManyInput>
    /**
     * Filter which Seatmaps to update
     */
    where?: SeatmapWhereInput
    /**
     * Limit how many Seatmaps to update.
     */
    limit?: number
  }

  /**
   * Seatmap updateManyAndReturn
   */
  export type SeatmapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seatmap
     */
    select?: SeatmapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Seatmap
     */
    omit?: SeatmapOmit<ExtArgs> | null
    /**
     * The data used to update Seatmaps.
     */
    data: XOR<SeatmapUpdateManyMutationInput, SeatmapUncheckedUpdateManyInput>
    /**
     * Filter which Seatmaps to update
     */
    where?: SeatmapWhereInput
    /**
     * Limit how many Seatmaps to update.
     */
    limit?: number
  }

  /**
   * Seatmap upsert
   */
  export type SeatmapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seatmap
     */
    select?: SeatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seatmap
     */
    omit?: SeatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatmapInclude<ExtArgs> | null
    /**
     * The filter to search for the Seatmap to update in case it exists.
     */
    where: SeatmapWhereUniqueInput
    /**
     * In case the Seatmap found by the `where` argument doesn't exist, create a new Seatmap with this data.
     */
    create: XOR<SeatmapCreateInput, SeatmapUncheckedCreateInput>
    /**
     * In case the Seatmap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeatmapUpdateInput, SeatmapUncheckedUpdateInput>
  }

  /**
   * Seatmap delete
   */
  export type SeatmapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seatmap
     */
    select?: SeatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seatmap
     */
    omit?: SeatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatmapInclude<ExtArgs> | null
    /**
     * Filter which Seatmap to delete.
     */
    where: SeatmapWhereUniqueInput
  }

  /**
   * Seatmap deleteMany
   */
  export type SeatmapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seatmaps to delete
     */
    where?: SeatmapWhereInput
    /**
     * Limit how many Seatmaps to delete.
     */
    limit?: number
  }

  /**
   * Seatmap.Section
   */
  export type Seatmap$SectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    cursor?: SectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Seatmap.Showing
   */
  export type Seatmap$ShowingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showing
     */
    omit?: ShowingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    where?: ShowingWhereInput
    orderBy?: ShowingOrderByWithRelationInput | ShowingOrderByWithRelationInput[]
    cursor?: ShowingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShowingScalarFieldEnum | ShowingScalarFieldEnum[]
  }

  /**
   * Seatmap without action
   */
  export type SeatmapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seatmap
     */
    select?: SeatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seatmap
     */
    omit?: SeatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatmapInclude<ExtArgs> | null
  }


  /**
   * Model Section
   */

  export type AggregateSection = {
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  export type SectionAvgAggregateOutputType = {
    id: number | null
    seatmapId: number | null
  }

  export type SectionSumAggregateOutputType = {
    id: number | null
    seatmapId: number | null
  }

  export type SectionMinAggregateOutputType = {
    id: number | null
    name: string | null
    seatmapId: number | null
    isStage: boolean | null
    createdAt: Date | null
    ticketTypeId: string | null
  }

  export type SectionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    seatmapId: number | null
    isStage: boolean | null
    createdAt: Date | null
    ticketTypeId: string | null
  }

  export type SectionCountAggregateOutputType = {
    id: number
    name: number
    seatmapId: number
    isStage: number
    element: number
    attribute: number
    createdAt: number
    ticketTypeId: number
    _all: number
  }


  export type SectionAvgAggregateInputType = {
    id?: true
    seatmapId?: true
  }

  export type SectionSumAggregateInputType = {
    id?: true
    seatmapId?: true
  }

  export type SectionMinAggregateInputType = {
    id?: true
    name?: true
    seatmapId?: true
    isStage?: true
    createdAt?: true
    ticketTypeId?: true
  }

  export type SectionMaxAggregateInputType = {
    id?: true
    name?: true
    seatmapId?: true
    isStage?: true
    createdAt?: true
    ticketTypeId?: true
  }

  export type SectionCountAggregateInputType = {
    id?: true
    name?: true
    seatmapId?: true
    isStage?: true
    element?: true
    attribute?: true
    createdAt?: true
    ticketTypeId?: true
    _all?: true
  }

  export type SectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Section to aggregate.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sections
    **/
    _count?: true | SectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectionMaxAggregateInputType
  }

  export type GetSectionAggregateType<T extends SectionAggregateArgs> = {
        [P in keyof T & keyof AggregateSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSection[P]>
      : GetScalarType<T[P], AggregateSection[P]>
  }




  export type SectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithAggregationInput | SectionOrderByWithAggregationInput[]
    by: SectionScalarFieldEnum[] | SectionScalarFieldEnum
    having?: SectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectionCountAggregateInputType | true
    _avg?: SectionAvgAggregateInputType
    _sum?: SectionSumAggregateInputType
    _min?: SectionMinAggregateInputType
    _max?: SectionMaxAggregateInputType
  }

  export type SectionGroupByOutputType = {
    id: number
    name: string
    seatmapId: number
    isStage: boolean
    element: JsonValue
    attribute: JsonValue
    createdAt: Date
    ticketTypeId: string
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  type GetSectionGroupByPayload<T extends SectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectionGroupByOutputType[P]>
            : GetScalarType<T[P], SectionGroupByOutputType[P]>
        }
      >
    >


  export type SectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    seatmapId?: boolean
    isStage?: boolean
    element?: boolean
    attribute?: boolean
    createdAt?: boolean
    ticketTypeId?: boolean
    Row?: boolean | Section$RowArgs<ExtArgs>
    Seatmap?: boolean | SeatmapDefaultArgs<ExtArgs>
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>

  export type SectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    seatmapId?: boolean
    isStage?: boolean
    element?: boolean
    attribute?: boolean
    createdAt?: boolean
    ticketTypeId?: boolean
    Seatmap?: boolean | SeatmapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>

  export type SectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    seatmapId?: boolean
    isStage?: boolean
    element?: boolean
    attribute?: boolean
    createdAt?: boolean
    ticketTypeId?: boolean
    Seatmap?: boolean | SeatmapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>

  export type SectionSelectScalar = {
    id?: boolean
    name?: boolean
    seatmapId?: boolean
    isStage?: boolean
    element?: boolean
    attribute?: boolean
    createdAt?: boolean
    ticketTypeId?: boolean
  }

  export type SectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "seatmapId" | "isStage" | "element" | "attribute" | "createdAt" | "ticketTypeId", ExtArgs["result"]["section"]>
  export type SectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Row?: boolean | Section$RowArgs<ExtArgs>
    Seatmap?: boolean | SeatmapDefaultArgs<ExtArgs>
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Seatmap?: boolean | SeatmapDefaultArgs<ExtArgs>
  }
  export type SectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Seatmap?: boolean | SeatmapDefaultArgs<ExtArgs>
  }

  export type $SectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Section"
    objects: {
      Row: Prisma.$RowPayload<ExtArgs>[]
      Seatmap: Prisma.$SeatmapPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      seatmapId: number
      isStage: boolean
      element: Prisma.JsonValue
      attribute: Prisma.JsonValue
      createdAt: Date
      ticketTypeId: string
    }, ExtArgs["result"]["section"]>
    composites: {}
  }

  type SectionGetPayload<S extends boolean | null | undefined | SectionDefaultArgs> = $Result.GetResult<Prisma.$SectionPayload, S>

  type SectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SectionCountAggregateInputType | true
    }

  export interface SectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Section'], meta: { name: 'Section' } }
    /**
     * Find zero or one Section that matches the filter.
     * @param {SectionFindUniqueArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectionFindUniqueArgs>(args: SelectSubset<T, SectionFindUniqueArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Section that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SectionFindUniqueOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectionFindUniqueOrThrowArgs>(args: SelectSubset<T, SectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Section that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectionFindFirstArgs>(args?: SelectSubset<T, SectionFindFirstArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Section that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectionFindFirstOrThrowArgs>(args?: SelectSubset<T, SectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sections
     * const sections = await prisma.section.findMany()
     * 
     * // Get first 10 Sections
     * const sections = await prisma.section.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectionWithIdOnly = await prisma.section.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SectionFindManyArgs>(args?: SelectSubset<T, SectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Section.
     * @param {SectionCreateArgs} args - Arguments to create a Section.
     * @example
     * // Create one Section
     * const Section = await prisma.section.create({
     *   data: {
     *     // ... data to create a Section
     *   }
     * })
     * 
     */
    create<T extends SectionCreateArgs>(args: SelectSubset<T, SectionCreateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Sections.
     * @param {SectionCreateManyArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectionCreateManyArgs>(args?: SelectSubset<T, SectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sections and returns the data saved in the database.
     * @param {SectionCreateManyAndReturnArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sections and only return the `id`
     * const sectionWithIdOnly = await prisma.section.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SectionCreateManyAndReturnArgs>(args?: SelectSubset<T, SectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Section.
     * @param {SectionDeleteArgs} args - Arguments to delete one Section.
     * @example
     * // Delete one Section
     * const Section = await prisma.section.delete({
     *   where: {
     *     // ... filter to delete one Section
     *   }
     * })
     * 
     */
    delete<T extends SectionDeleteArgs>(args: SelectSubset<T, SectionDeleteArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Section.
     * @param {SectionUpdateArgs} args - Arguments to update one Section.
     * @example
     * // Update one Section
     * const section = await prisma.section.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectionUpdateArgs>(args: SelectSubset<T, SectionUpdateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Sections.
     * @param {SectionDeleteManyArgs} args - Arguments to filter Sections to delete.
     * @example
     * // Delete a few Sections
     * const { count } = await prisma.section.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectionDeleteManyArgs>(args?: SelectSubset<T, SectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sections
     * const section = await prisma.section.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectionUpdateManyArgs>(args: SelectSubset<T, SectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections and returns the data updated in the database.
     * @param {SectionUpdateManyAndReturnArgs} args - Arguments to update many Sections.
     * @example
     * // Update many Sections
     * const section = await prisma.section.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sections and only return the `id`
     * const sectionWithIdOnly = await prisma.section.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SectionUpdateManyAndReturnArgs>(args: SelectSubset<T, SectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Section.
     * @param {SectionUpsertArgs} args - Arguments to update or create a Section.
     * @example
     * // Update or create a Section
     * const section = await prisma.section.upsert({
     *   create: {
     *     // ... data to create a Section
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Section we want to update
     *   }
     * })
     */
    upsert<T extends SectionUpsertArgs>(args: SelectSubset<T, SectionUpsertArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionCountArgs} args - Arguments to filter Sections to count.
     * @example
     * // Count the number of Sections
     * const count = await prisma.section.count({
     *   where: {
     *     // ... the filter for the Sections we want to count
     *   }
     * })
    **/
    count<T extends SectionCountArgs>(
      args?: Subset<T, SectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectionAggregateArgs>(args: Subset<T, SectionAggregateArgs>): Prisma.PrismaPromise<GetSectionAggregateType<T>>

    /**
     * Group by Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectionGroupByArgs['orderBy'] }
        : { orderBy?: SectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Section model
   */
  readonly fields: SectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Section.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Row<T extends Section$RowArgs<ExtArgs> = {}>(args?: Subset<T, Section$RowArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RowPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Seatmap<T extends SeatmapDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeatmapDefaultArgs<ExtArgs>>): Prisma__SeatmapClient<$Result.GetResult<Prisma.$SeatmapPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Section model
   */ 
  interface SectionFieldRefs {
    readonly id: FieldRef<"Section", 'Int'>
    readonly name: FieldRef<"Section", 'String'>
    readonly seatmapId: FieldRef<"Section", 'Int'>
    readonly isStage: FieldRef<"Section", 'Boolean'>
    readonly element: FieldRef<"Section", 'Json'>
    readonly attribute: FieldRef<"Section", 'Json'>
    readonly createdAt: FieldRef<"Section", 'DateTime'>
    readonly ticketTypeId: FieldRef<"Section", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Section findUnique
   */
  export type SectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findUniqueOrThrow
   */
  export type SectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findFirst
   */
  export type SectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findFirstOrThrow
   */
  export type SectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findMany
   */
  export type SectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Sections to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section create
   */
  export type SectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Section.
     */
    data: XOR<SectionCreateInput, SectionUncheckedCreateInput>
  }

  /**
   * Section createMany
   */
  export type SectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Section createManyAndReturn
   */
  export type SectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Section update
   */
  export type SectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Section.
     */
    data: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
    /**
     * Choose, which Section to update.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section updateMany
   */
  export type SectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sections.
     */
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyInput>
    /**
     * Filter which Sections to update
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to update.
     */
    limit?: number
  }

  /**
   * Section updateManyAndReturn
   */
  export type SectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * The data used to update Sections.
     */
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyInput>
    /**
     * Filter which Sections to update
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Section upsert
   */
  export type SectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Section to update in case it exists.
     */
    where: SectionWhereUniqueInput
    /**
     * In case the Section found by the `where` argument doesn't exist, create a new Section with this data.
     */
    create: XOR<SectionCreateInput, SectionUncheckedCreateInput>
    /**
     * In case the Section was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
  }

  /**
   * Section delete
   */
  export type SectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter which Section to delete.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section deleteMany
   */
  export type SectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sections to delete
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to delete.
     */
    limit?: number
  }

  /**
   * Section.Row
   */
  export type Section$RowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Row
     */
    select?: RowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Row
     */
    omit?: RowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RowInclude<ExtArgs> | null
    where?: RowWhereInput
    orderBy?: RowOrderByWithRelationInput | RowOrderByWithRelationInput[]
    cursor?: RowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RowScalarFieldEnum | RowScalarFieldEnum[]
  }

  /**
   * Section without action
   */
  export type SectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
  }


  /**
   * Model Showing
   */

  export type AggregateShowing = {
    _count: ShowingCountAggregateOutputType | null
    _avg: ShowingAvgAggregateOutputType | null
    _sum: ShowingSumAggregateOutputType | null
    _min: ShowingMinAggregateOutputType | null
    _max: ShowingMaxAggregateOutputType | null
  }

  export type ShowingAvgAggregateOutputType = {
    eventId: number | null
    seatMapId: number | null
  }

  export type ShowingSumAggregateOutputType = {
    eventId: number | null
    seatMapId: number | null
  }

  export type ShowingMinAggregateOutputType = {
    id: string | null
    eventId: number | null
    status: string | null
    isFree: boolean | null
    isSalable: boolean | null
    isPresale: boolean | null
    seatMapId: number | null
    startTime: Date | null
    endTime: Date | null
    isEnabledQueueWaiting: boolean | null
    showAllSeats: boolean | null
  }

  export type ShowingMaxAggregateOutputType = {
    id: string | null
    eventId: number | null
    status: string | null
    isFree: boolean | null
    isSalable: boolean | null
    isPresale: boolean | null
    seatMapId: number | null
    startTime: Date | null
    endTime: Date | null
    isEnabledQueueWaiting: boolean | null
    showAllSeats: boolean | null
  }

  export type ShowingCountAggregateOutputType = {
    id: number
    eventId: number
    status: number
    isFree: number
    isSalable: number
    isPresale: number
    seatMapId: number
    startTime: number
    endTime: number
    isEnabledQueueWaiting: number
    showAllSeats: number
    _all: number
  }


  export type ShowingAvgAggregateInputType = {
    eventId?: true
    seatMapId?: true
  }

  export type ShowingSumAggregateInputType = {
    eventId?: true
    seatMapId?: true
  }

  export type ShowingMinAggregateInputType = {
    id?: true
    eventId?: true
    status?: true
    isFree?: true
    isSalable?: true
    isPresale?: true
    seatMapId?: true
    startTime?: true
    endTime?: true
    isEnabledQueueWaiting?: true
    showAllSeats?: true
  }

  export type ShowingMaxAggregateInputType = {
    id?: true
    eventId?: true
    status?: true
    isFree?: true
    isSalable?: true
    isPresale?: true
    seatMapId?: true
    startTime?: true
    endTime?: true
    isEnabledQueueWaiting?: true
    showAllSeats?: true
  }

  export type ShowingCountAggregateInputType = {
    id?: true
    eventId?: true
    status?: true
    isFree?: true
    isSalable?: true
    isPresale?: true
    seatMapId?: true
    startTime?: true
    endTime?: true
    isEnabledQueueWaiting?: true
    showAllSeats?: true
    _all?: true
  }

  export type ShowingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Showing to aggregate.
     */
    where?: ShowingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Showings to fetch.
     */
    orderBy?: ShowingOrderByWithRelationInput | ShowingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShowingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Showings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Showings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Showings
    **/
    _count?: true | ShowingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShowingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShowingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShowingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShowingMaxAggregateInputType
  }

  export type GetShowingAggregateType<T extends ShowingAggregateArgs> = {
        [P in keyof T & keyof AggregateShowing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShowing[P]>
      : GetScalarType<T[P], AggregateShowing[P]>
  }




  export type ShowingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShowingWhereInput
    orderBy?: ShowingOrderByWithAggregationInput | ShowingOrderByWithAggregationInput[]
    by: ShowingScalarFieldEnum[] | ShowingScalarFieldEnum
    having?: ShowingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShowingCountAggregateInputType | true
    _avg?: ShowingAvgAggregateInputType
    _sum?: ShowingSumAggregateInputType
    _min?: ShowingMinAggregateInputType
    _max?: ShowingMaxAggregateInputType
  }

  export type ShowingGroupByOutputType = {
    id: string
    eventId: number
    status: string
    isFree: boolean
    isSalable: boolean
    isPresale: boolean
    seatMapId: number
    startTime: Date
    endTime: Date
    isEnabledQueueWaiting: boolean
    showAllSeats: boolean
    _count: ShowingCountAggregateOutputType | null
    _avg: ShowingAvgAggregateOutputType | null
    _sum: ShowingSumAggregateOutputType | null
    _min: ShowingMinAggregateOutputType | null
    _max: ShowingMaxAggregateOutputType | null
  }

  type GetShowingGroupByPayload<T extends ShowingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShowingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShowingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShowingGroupByOutputType[P]>
            : GetScalarType<T[P], ShowingGroupByOutputType[P]>
        }
      >
    >


  export type ShowingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    status?: boolean
    isFree?: boolean
    isSalable?: boolean
    isPresale?: boolean
    seatMapId?: boolean
    startTime?: boolean
    endTime?: boolean
    isEnabledQueueWaiting?: boolean
    showAllSeats?: boolean
    Events?: boolean | EventsDefaultArgs<ExtArgs>
    Seatmap?: boolean | SeatmapDefaultArgs<ExtArgs>
    Ticket?: boolean | Showing$TicketArgs<ExtArgs>
    TicketType?: boolean | Showing$TicketTypeArgs<ExtArgs>
    _count?: boolean | ShowingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["showing"]>

  export type ShowingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    status?: boolean
    isFree?: boolean
    isSalable?: boolean
    isPresale?: boolean
    seatMapId?: boolean
    startTime?: boolean
    endTime?: boolean
    isEnabledQueueWaiting?: boolean
    showAllSeats?: boolean
    Events?: boolean | EventsDefaultArgs<ExtArgs>
    Seatmap?: boolean | SeatmapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["showing"]>

  export type ShowingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    status?: boolean
    isFree?: boolean
    isSalable?: boolean
    isPresale?: boolean
    seatMapId?: boolean
    startTime?: boolean
    endTime?: boolean
    isEnabledQueueWaiting?: boolean
    showAllSeats?: boolean
    Events?: boolean | EventsDefaultArgs<ExtArgs>
    Seatmap?: boolean | SeatmapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["showing"]>

  export type ShowingSelectScalar = {
    id?: boolean
    eventId?: boolean
    status?: boolean
    isFree?: boolean
    isSalable?: boolean
    isPresale?: boolean
    seatMapId?: boolean
    startTime?: boolean
    endTime?: boolean
    isEnabledQueueWaiting?: boolean
    showAllSeats?: boolean
  }

  export type ShowingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "status" | "isFree" | "isSalable" | "isPresale" | "seatMapId" | "startTime" | "endTime" | "isEnabledQueueWaiting" | "showAllSeats", ExtArgs["result"]["showing"]>
  export type ShowingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Events?: boolean | EventsDefaultArgs<ExtArgs>
    Seatmap?: boolean | SeatmapDefaultArgs<ExtArgs>
    Ticket?: boolean | Showing$TicketArgs<ExtArgs>
    TicketType?: boolean | Showing$TicketTypeArgs<ExtArgs>
    _count?: boolean | ShowingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShowingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Events?: boolean | EventsDefaultArgs<ExtArgs>
    Seatmap?: boolean | SeatmapDefaultArgs<ExtArgs>
  }
  export type ShowingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Events?: boolean | EventsDefaultArgs<ExtArgs>
    Seatmap?: boolean | SeatmapDefaultArgs<ExtArgs>
  }

  export type $ShowingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Showing"
    objects: {
      Events: Prisma.$EventsPayload<ExtArgs>
      Seatmap: Prisma.$SeatmapPayload<ExtArgs>
      Ticket: Prisma.$TicketPayload<ExtArgs>[]
      TicketType: Prisma.$TicketTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: number
      status: string
      isFree: boolean
      isSalable: boolean
      isPresale: boolean
      seatMapId: number
      startTime: Date
      endTime: Date
      isEnabledQueueWaiting: boolean
      showAllSeats: boolean
    }, ExtArgs["result"]["showing"]>
    composites: {}
  }

  type ShowingGetPayload<S extends boolean | null | undefined | ShowingDefaultArgs> = $Result.GetResult<Prisma.$ShowingPayload, S>

  type ShowingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShowingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShowingCountAggregateInputType | true
    }

  export interface ShowingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Showing'], meta: { name: 'Showing' } }
    /**
     * Find zero or one Showing that matches the filter.
     * @param {ShowingFindUniqueArgs} args - Arguments to find a Showing
     * @example
     * // Get one Showing
     * const showing = await prisma.showing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShowingFindUniqueArgs>(args: SelectSubset<T, ShowingFindUniqueArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Showing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShowingFindUniqueOrThrowArgs} args - Arguments to find a Showing
     * @example
     * // Get one Showing
     * const showing = await prisma.showing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShowingFindUniqueOrThrowArgs>(args: SelectSubset<T, ShowingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Showing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowingFindFirstArgs} args - Arguments to find a Showing
     * @example
     * // Get one Showing
     * const showing = await prisma.showing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShowingFindFirstArgs>(args?: SelectSubset<T, ShowingFindFirstArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Showing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowingFindFirstOrThrowArgs} args - Arguments to find a Showing
     * @example
     * // Get one Showing
     * const showing = await prisma.showing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShowingFindFirstOrThrowArgs>(args?: SelectSubset<T, ShowingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Showings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Showings
     * const showings = await prisma.showing.findMany()
     * 
     * // Get first 10 Showings
     * const showings = await prisma.showing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const showingWithIdOnly = await prisma.showing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShowingFindManyArgs>(args?: SelectSubset<T, ShowingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Showing.
     * @param {ShowingCreateArgs} args - Arguments to create a Showing.
     * @example
     * // Create one Showing
     * const Showing = await prisma.showing.create({
     *   data: {
     *     // ... data to create a Showing
     *   }
     * })
     * 
     */
    create<T extends ShowingCreateArgs>(args: SelectSubset<T, ShowingCreateArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Showings.
     * @param {ShowingCreateManyArgs} args - Arguments to create many Showings.
     * @example
     * // Create many Showings
     * const showing = await prisma.showing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShowingCreateManyArgs>(args?: SelectSubset<T, ShowingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Showings and returns the data saved in the database.
     * @param {ShowingCreateManyAndReturnArgs} args - Arguments to create many Showings.
     * @example
     * // Create many Showings
     * const showing = await prisma.showing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Showings and only return the `id`
     * const showingWithIdOnly = await prisma.showing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShowingCreateManyAndReturnArgs>(args?: SelectSubset<T, ShowingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Showing.
     * @param {ShowingDeleteArgs} args - Arguments to delete one Showing.
     * @example
     * // Delete one Showing
     * const Showing = await prisma.showing.delete({
     *   where: {
     *     // ... filter to delete one Showing
     *   }
     * })
     * 
     */
    delete<T extends ShowingDeleteArgs>(args: SelectSubset<T, ShowingDeleteArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Showing.
     * @param {ShowingUpdateArgs} args - Arguments to update one Showing.
     * @example
     * // Update one Showing
     * const showing = await prisma.showing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShowingUpdateArgs>(args: SelectSubset<T, ShowingUpdateArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Showings.
     * @param {ShowingDeleteManyArgs} args - Arguments to filter Showings to delete.
     * @example
     * // Delete a few Showings
     * const { count } = await prisma.showing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShowingDeleteManyArgs>(args?: SelectSubset<T, ShowingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Showings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Showings
     * const showing = await prisma.showing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShowingUpdateManyArgs>(args: SelectSubset<T, ShowingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Showings and returns the data updated in the database.
     * @param {ShowingUpdateManyAndReturnArgs} args - Arguments to update many Showings.
     * @example
     * // Update many Showings
     * const showing = await prisma.showing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Showings and only return the `id`
     * const showingWithIdOnly = await prisma.showing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShowingUpdateManyAndReturnArgs>(args: SelectSubset<T, ShowingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Showing.
     * @param {ShowingUpsertArgs} args - Arguments to update or create a Showing.
     * @example
     * // Update or create a Showing
     * const showing = await prisma.showing.upsert({
     *   create: {
     *     // ... data to create a Showing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Showing we want to update
     *   }
     * })
     */
    upsert<T extends ShowingUpsertArgs>(args: SelectSubset<T, ShowingUpsertArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Showings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowingCountArgs} args - Arguments to filter Showings to count.
     * @example
     * // Count the number of Showings
     * const count = await prisma.showing.count({
     *   where: {
     *     // ... the filter for the Showings we want to count
     *   }
     * })
    **/
    count<T extends ShowingCountArgs>(
      args?: Subset<T, ShowingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShowingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Showing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShowingAggregateArgs>(args: Subset<T, ShowingAggregateArgs>): Prisma.PrismaPromise<GetShowingAggregateType<T>>

    /**
     * Group by Showing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShowingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShowingGroupByArgs['orderBy'] }
        : { orderBy?: ShowingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShowingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShowingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Showing model
   */
  readonly fields: ShowingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Showing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShowingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Events<T extends EventsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventsDefaultArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Seatmap<T extends SeatmapDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeatmapDefaultArgs<ExtArgs>>): Prisma__SeatmapClient<$Result.GetResult<Prisma.$SeatmapPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Ticket<T extends Showing$TicketArgs<ExtArgs> = {}>(args?: Subset<T, Showing$TicketArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    TicketType<T extends Showing$TicketTypeArgs<ExtArgs> = {}>(args?: Subset<T, Showing$TicketTypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTypePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Showing model
   */ 
  interface ShowingFieldRefs {
    readonly id: FieldRef<"Showing", 'String'>
    readonly eventId: FieldRef<"Showing", 'Int'>
    readonly status: FieldRef<"Showing", 'String'>
    readonly isFree: FieldRef<"Showing", 'Boolean'>
    readonly isSalable: FieldRef<"Showing", 'Boolean'>
    readonly isPresale: FieldRef<"Showing", 'Boolean'>
    readonly seatMapId: FieldRef<"Showing", 'Int'>
    readonly startTime: FieldRef<"Showing", 'DateTime'>
    readonly endTime: FieldRef<"Showing", 'DateTime'>
    readonly isEnabledQueueWaiting: FieldRef<"Showing", 'Boolean'>
    readonly showAllSeats: FieldRef<"Showing", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Showing findUnique
   */
  export type ShowingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showing
     */
    omit?: ShowingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    /**
     * Filter, which Showing to fetch.
     */
    where: ShowingWhereUniqueInput
  }

  /**
   * Showing findUniqueOrThrow
   */
  export type ShowingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showing
     */
    omit?: ShowingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    /**
     * Filter, which Showing to fetch.
     */
    where: ShowingWhereUniqueInput
  }

  /**
   * Showing findFirst
   */
  export type ShowingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showing
     */
    omit?: ShowingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    /**
     * Filter, which Showing to fetch.
     */
    where?: ShowingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Showings to fetch.
     */
    orderBy?: ShowingOrderByWithRelationInput | ShowingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Showings.
     */
    cursor?: ShowingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Showings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Showings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Showings.
     */
    distinct?: ShowingScalarFieldEnum | ShowingScalarFieldEnum[]
  }

  /**
   * Showing findFirstOrThrow
   */
  export type ShowingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showing
     */
    omit?: ShowingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    /**
     * Filter, which Showing to fetch.
     */
    where?: ShowingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Showings to fetch.
     */
    orderBy?: ShowingOrderByWithRelationInput | ShowingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Showings.
     */
    cursor?: ShowingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Showings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Showings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Showings.
     */
    distinct?: ShowingScalarFieldEnum | ShowingScalarFieldEnum[]
  }

  /**
   * Showing findMany
   */
  export type ShowingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showing
     */
    omit?: ShowingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    /**
     * Filter, which Showings to fetch.
     */
    where?: ShowingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Showings to fetch.
     */
    orderBy?: ShowingOrderByWithRelationInput | ShowingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Showings.
     */
    cursor?: ShowingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Showings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Showings.
     */
    skip?: number
    distinct?: ShowingScalarFieldEnum | ShowingScalarFieldEnum[]
  }

  /**
   * Showing create
   */
  export type ShowingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showing
     */
    omit?: ShowingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    /**
     * The data needed to create a Showing.
     */
    data: XOR<ShowingCreateInput, ShowingUncheckedCreateInput>
  }

  /**
   * Showing createMany
   */
  export type ShowingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Showings.
     */
    data: ShowingCreateManyInput | ShowingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Showing createManyAndReturn
   */
  export type ShowingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Showing
     */
    omit?: ShowingOmit<ExtArgs> | null
    /**
     * The data used to create many Showings.
     */
    data: ShowingCreateManyInput | ShowingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Showing update
   */
  export type ShowingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showing
     */
    omit?: ShowingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    /**
     * The data needed to update a Showing.
     */
    data: XOR<ShowingUpdateInput, ShowingUncheckedUpdateInput>
    /**
     * Choose, which Showing to update.
     */
    where: ShowingWhereUniqueInput
  }

  /**
   * Showing updateMany
   */
  export type ShowingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Showings.
     */
    data: XOR<ShowingUpdateManyMutationInput, ShowingUncheckedUpdateManyInput>
    /**
     * Filter which Showings to update
     */
    where?: ShowingWhereInput
    /**
     * Limit how many Showings to update.
     */
    limit?: number
  }

  /**
   * Showing updateManyAndReturn
   */
  export type ShowingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Showing
     */
    omit?: ShowingOmit<ExtArgs> | null
    /**
     * The data used to update Showings.
     */
    data: XOR<ShowingUpdateManyMutationInput, ShowingUncheckedUpdateManyInput>
    /**
     * Filter which Showings to update
     */
    where?: ShowingWhereInput
    /**
     * Limit how many Showings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Showing upsert
   */
  export type ShowingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showing
     */
    omit?: ShowingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    /**
     * The filter to search for the Showing to update in case it exists.
     */
    where: ShowingWhereUniqueInput
    /**
     * In case the Showing found by the `where` argument doesn't exist, create a new Showing with this data.
     */
    create: XOR<ShowingCreateInput, ShowingUncheckedCreateInput>
    /**
     * In case the Showing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShowingUpdateInput, ShowingUncheckedUpdateInput>
  }

  /**
   * Showing delete
   */
  export type ShowingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showing
     */
    omit?: ShowingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    /**
     * Filter which Showing to delete.
     */
    where: ShowingWhereUniqueInput
  }

  /**
   * Showing deleteMany
   */
  export type ShowingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Showings to delete
     */
    where?: ShowingWhereInput
    /**
     * Limit how many Showings to delete.
     */
    limit?: number
  }

  /**
   * Showing.Ticket
   */
  export type Showing$TicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Showing.TicketType
   */
  export type Showing$TicketTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketType
     */
    select?: TicketTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketType
     */
    omit?: TicketTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTypeInclude<ExtArgs> | null
    where?: TicketTypeWhereInput
    orderBy?: TicketTypeOrderByWithRelationInput | TicketTypeOrderByWithRelationInput[]
    cursor?: TicketTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketTypeScalarFieldEnum | TicketTypeScalarFieldEnum[]
  }

  /**
   * Showing without action
   */
  export type ShowingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showing
     */
    omit?: ShowingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketAvgAggregateOutputType = {
    seatId: number | null
    status: number | null
    price: number | null
    userId: number | null
  }

  export type TicketSumAggregateOutputType = {
    seatId: number | null
    status: number | null
    price: number | null
    userId: number | null
  }

  export type TicketMinAggregateOutputType = {
    id: string | null
    seatId: number | null
    showingId: string | null
    ticketTypeId: string | null
    status: number | null
    price: number | null
    userId: number | null
    purchasedAt: Date | null
    qrCode: string | null
  }

  export type TicketMaxAggregateOutputType = {
    id: string | null
    seatId: number | null
    showingId: string | null
    ticketTypeId: string | null
    status: number | null
    price: number | null
    userId: number | null
    purchasedAt: Date | null
    qrCode: string | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    seatId: number
    showingId: number
    ticketTypeId: number
    status: number
    price: number
    userId: number
    purchasedAt: number
    qrCode: number
    _all: number
  }


  export type TicketAvgAggregateInputType = {
    seatId?: true
    status?: true
    price?: true
    userId?: true
  }

  export type TicketSumAggregateInputType = {
    seatId?: true
    status?: true
    price?: true
    userId?: true
  }

  export type TicketMinAggregateInputType = {
    id?: true
    seatId?: true
    showingId?: true
    ticketTypeId?: true
    status?: true
    price?: true
    userId?: true
    purchasedAt?: true
    qrCode?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    seatId?: true
    showingId?: true
    ticketTypeId?: true
    status?: true
    price?: true
    userId?: true
    purchasedAt?: true
    qrCode?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    seatId?: true
    showingId?: true
    ticketTypeId?: true
    status?: true
    price?: true
    userId?: true
    purchasedAt?: true
    qrCode?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _avg?: TicketAvgAggregateInputType
    _sum?: TicketSumAggregateInputType
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: string
    seatId: number
    showingId: string
    ticketTypeId: string
    status: number
    price: number
    userId: number | null
    purchasedAt: Date | null
    qrCode: string | null
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seatId?: boolean
    showingId?: boolean
    ticketTypeId?: boolean
    status?: boolean
    price?: boolean
    userId?: boolean
    purchasedAt?: boolean
    qrCode?: boolean
    Seat?: boolean | SeatDefaultArgs<ExtArgs>
    Showing?: boolean | ShowingDefaultArgs<ExtArgs>
    TicketType?: boolean | TicketTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seatId?: boolean
    showingId?: boolean
    ticketTypeId?: boolean
    status?: boolean
    price?: boolean
    userId?: boolean
    purchasedAt?: boolean
    qrCode?: boolean
    Seat?: boolean | SeatDefaultArgs<ExtArgs>
    Showing?: boolean | ShowingDefaultArgs<ExtArgs>
    TicketType?: boolean | TicketTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seatId?: boolean
    showingId?: boolean
    ticketTypeId?: boolean
    status?: boolean
    price?: boolean
    userId?: boolean
    purchasedAt?: boolean
    qrCode?: boolean
    Seat?: boolean | SeatDefaultArgs<ExtArgs>
    Showing?: boolean | ShowingDefaultArgs<ExtArgs>
    TicketType?: boolean | TicketTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectScalar = {
    id?: boolean
    seatId?: boolean
    showingId?: boolean
    ticketTypeId?: boolean
    status?: boolean
    price?: boolean
    userId?: boolean
    purchasedAt?: boolean
    qrCode?: boolean
  }

  export type TicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seatId" | "showingId" | "ticketTypeId" | "status" | "price" | "userId" | "purchasedAt" | "qrCode", ExtArgs["result"]["ticket"]>
  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Seat?: boolean | SeatDefaultArgs<ExtArgs>
    Showing?: boolean | ShowingDefaultArgs<ExtArgs>
    TicketType?: boolean | TicketTypeDefaultArgs<ExtArgs>
  }
  export type TicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Seat?: boolean | SeatDefaultArgs<ExtArgs>
    Showing?: boolean | ShowingDefaultArgs<ExtArgs>
    TicketType?: boolean | TicketTypeDefaultArgs<ExtArgs>
  }
  export type TicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Seat?: boolean | SeatDefaultArgs<ExtArgs>
    Showing?: boolean | ShowingDefaultArgs<ExtArgs>
    TicketType?: boolean | TicketTypeDefaultArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      Seat: Prisma.$SeatPayload<ExtArgs>
      Showing: Prisma.$ShowingPayload<ExtArgs>
      TicketType: Prisma.$TicketTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seatId: number
      showingId: string
      ticketTypeId: string
      status: number
      price: number
      userId: number | null
      purchasedAt: Date | null
      qrCode: string | null
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {TicketCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets and returns the data updated in the database.
     * @param {TicketUpdateManyAndReturnArgs} args - Arguments to update many Tickets.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Seat<T extends SeatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeatDefaultArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Showing<T extends ShowingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShowingDefaultArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TicketType<T extends TicketTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketTypeDefaultArgs<ExtArgs>>): Prisma__TicketTypeClient<$Result.GetResult<Prisma.$TicketTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */ 
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'String'>
    readonly seatId: FieldRef<"Ticket", 'Int'>
    readonly showingId: FieldRef<"Ticket", 'String'>
    readonly ticketTypeId: FieldRef<"Ticket", 'String'>
    readonly status: FieldRef<"Ticket", 'Int'>
    readonly price: FieldRef<"Ticket", 'Int'>
    readonly userId: FieldRef<"Ticket", 'Int'>
    readonly purchasedAt: FieldRef<"Ticket", 'DateTime'>
    readonly qrCode: FieldRef<"Ticket", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket createManyAndReturn
   */
  export type TicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
  }

  /**
   * Ticket updateManyAndReturn
   */
  export type TicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to delete.
     */
    limit?: number
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Model TicketType
   */

  export type AggregateTicketType = {
    _count: TicketTypeCountAggregateOutputType | null
    _avg: TicketTypeAvgAggregateOutputType | null
    _sum: TicketTypeSumAggregateOutputType | null
    _min: TicketTypeMinAggregateOutputType | null
    _max: TicketTypeMaxAggregateOutputType | null
  }

  export type TicketTypeAvgAggregateOutputType = {
    price: number | null
    originalPrice: number | null
    maxQtyPerOrder: number | null
    minQtyPerOrder: number | null
    position: number | null
  }

  export type TicketTypeSumAggregateOutputType = {
    price: number | null
    originalPrice: number | null
    maxQtyPerOrder: number | null
    minQtyPerOrder: number | null
    position: number | null
  }

  export type TicketTypeMinAggregateOutputType = {
    id: string | null
    showingId: string | null
    name: string | null
    description: string | null
    color: string | null
    isFree: boolean | null
    price: number | null
    originalPrice: number | null
    maxQtyPerOrder: number | null
    minQtyPerOrder: number | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    position: number | null
    status: string | null
    imageUrl: string | null
    isHidden: boolean | null
  }

  export type TicketTypeMaxAggregateOutputType = {
    id: string | null
    showingId: string | null
    name: string | null
    description: string | null
    color: string | null
    isFree: boolean | null
    price: number | null
    originalPrice: number | null
    maxQtyPerOrder: number | null
    minQtyPerOrder: number | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    position: number | null
    status: string | null
    imageUrl: string | null
    isHidden: boolean | null
  }

  export type TicketTypeCountAggregateOutputType = {
    id: number
    showingId: number
    name: number
    description: number
    color: number
    isFree: number
    price: number
    originalPrice: number
    maxQtyPerOrder: number
    minQtyPerOrder: number
    effectiveFrom: number
    effectiveTo: number
    position: number
    status: number
    imageUrl: number
    isHidden: number
    _all: number
  }


  export type TicketTypeAvgAggregateInputType = {
    price?: true
    originalPrice?: true
    maxQtyPerOrder?: true
    minQtyPerOrder?: true
    position?: true
  }

  export type TicketTypeSumAggregateInputType = {
    price?: true
    originalPrice?: true
    maxQtyPerOrder?: true
    minQtyPerOrder?: true
    position?: true
  }

  export type TicketTypeMinAggregateInputType = {
    id?: true
    showingId?: true
    name?: true
    description?: true
    color?: true
    isFree?: true
    price?: true
    originalPrice?: true
    maxQtyPerOrder?: true
    minQtyPerOrder?: true
    effectiveFrom?: true
    effectiveTo?: true
    position?: true
    status?: true
    imageUrl?: true
    isHidden?: true
  }

  export type TicketTypeMaxAggregateInputType = {
    id?: true
    showingId?: true
    name?: true
    description?: true
    color?: true
    isFree?: true
    price?: true
    originalPrice?: true
    maxQtyPerOrder?: true
    minQtyPerOrder?: true
    effectiveFrom?: true
    effectiveTo?: true
    position?: true
    status?: true
    imageUrl?: true
    isHidden?: true
  }

  export type TicketTypeCountAggregateInputType = {
    id?: true
    showingId?: true
    name?: true
    description?: true
    color?: true
    isFree?: true
    price?: true
    originalPrice?: true
    maxQtyPerOrder?: true
    minQtyPerOrder?: true
    effectiveFrom?: true
    effectiveTo?: true
    position?: true
    status?: true
    imageUrl?: true
    isHidden?: true
    _all?: true
  }

  export type TicketTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketType to aggregate.
     */
    where?: TicketTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTypes to fetch.
     */
    orderBy?: TicketTypeOrderByWithRelationInput | TicketTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketTypes
    **/
    _count?: true | TicketTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketTypeMaxAggregateInputType
  }

  export type GetTicketTypeAggregateType<T extends TicketTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketType[P]>
      : GetScalarType<T[P], AggregateTicketType[P]>
  }




  export type TicketTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketTypeWhereInput
    orderBy?: TicketTypeOrderByWithAggregationInput | TicketTypeOrderByWithAggregationInput[]
    by: TicketTypeScalarFieldEnum[] | TicketTypeScalarFieldEnum
    having?: TicketTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketTypeCountAggregateInputType | true
    _avg?: TicketTypeAvgAggregateInputType
    _sum?: TicketTypeSumAggregateInputType
    _min?: TicketTypeMinAggregateInputType
    _max?: TicketTypeMaxAggregateInputType
  }

  export type TicketTypeGroupByOutputType = {
    id: string
    showingId: string
    name: string
    description: string
    color: string
    isFree: boolean
    price: number
    originalPrice: number
    maxQtyPerOrder: number
    minQtyPerOrder: number
    effectiveFrom: Date
    effectiveTo: Date | null
    position: number
    status: string
    imageUrl: string
    isHidden: boolean
    _count: TicketTypeCountAggregateOutputType | null
    _avg: TicketTypeAvgAggregateOutputType | null
    _sum: TicketTypeSumAggregateOutputType | null
    _min: TicketTypeMinAggregateOutputType | null
    _max: TicketTypeMaxAggregateOutputType | null
  }

  type GetTicketTypeGroupByPayload<T extends TicketTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketTypeGroupByOutputType[P]>
            : GetScalarType<T[P], TicketTypeGroupByOutputType[P]>
        }
      >
    >


  export type TicketTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    showingId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    isFree?: boolean
    price?: boolean
    originalPrice?: boolean
    maxQtyPerOrder?: boolean
    minQtyPerOrder?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    position?: boolean
    status?: boolean
    imageUrl?: boolean
    isHidden?: boolean
    Ticket?: boolean | TicketType$TicketArgs<ExtArgs>
    Showing?: boolean | ShowingDefaultArgs<ExtArgs>
    _count?: boolean | TicketTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketType"]>

  export type TicketTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    showingId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    isFree?: boolean
    price?: boolean
    originalPrice?: boolean
    maxQtyPerOrder?: boolean
    minQtyPerOrder?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    position?: boolean
    status?: boolean
    imageUrl?: boolean
    isHidden?: boolean
    Showing?: boolean | ShowingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketType"]>

  export type TicketTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    showingId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    isFree?: boolean
    price?: boolean
    originalPrice?: boolean
    maxQtyPerOrder?: boolean
    minQtyPerOrder?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    position?: boolean
    status?: boolean
    imageUrl?: boolean
    isHidden?: boolean
    Showing?: boolean | ShowingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketType"]>

  export type TicketTypeSelectScalar = {
    id?: boolean
    showingId?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    isFree?: boolean
    price?: boolean
    originalPrice?: boolean
    maxQtyPerOrder?: boolean
    minQtyPerOrder?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    position?: boolean
    status?: boolean
    imageUrl?: boolean
    isHidden?: boolean
  }

  export type TicketTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "showingId" | "name" | "description" | "color" | "isFree" | "price" | "originalPrice" | "maxQtyPerOrder" | "minQtyPerOrder" | "effectiveFrom" | "effectiveTo" | "position" | "status" | "imageUrl" | "isHidden", ExtArgs["result"]["ticketType"]>
  export type TicketTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ticket?: boolean | TicketType$TicketArgs<ExtArgs>
    Showing?: boolean | ShowingDefaultArgs<ExtArgs>
    _count?: boolean | TicketTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TicketTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Showing?: boolean | ShowingDefaultArgs<ExtArgs>
  }
  export type TicketTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Showing?: boolean | ShowingDefaultArgs<ExtArgs>
  }

  export type $TicketTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketType"
    objects: {
      Ticket: Prisma.$TicketPayload<ExtArgs>[]
      Showing: Prisma.$ShowingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      showingId: string
      name: string
      description: string
      color: string
      isFree: boolean
      price: number
      originalPrice: number
      maxQtyPerOrder: number
      minQtyPerOrder: number
      effectiveFrom: Date
      effectiveTo: Date | null
      position: number
      status: string
      imageUrl: string
      isHidden: boolean
    }, ExtArgs["result"]["ticketType"]>
    composites: {}
  }

  type TicketTypeGetPayload<S extends boolean | null | undefined | TicketTypeDefaultArgs> = $Result.GetResult<Prisma.$TicketTypePayload, S>

  type TicketTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketTypeCountAggregateInputType | true
    }

  export interface TicketTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketType'], meta: { name: 'TicketType' } }
    /**
     * Find zero or one TicketType that matches the filter.
     * @param {TicketTypeFindUniqueArgs} args - Arguments to find a TicketType
     * @example
     * // Get one TicketType
     * const ticketType = await prisma.ticketType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketTypeFindUniqueArgs>(args: SelectSubset<T, TicketTypeFindUniqueArgs<ExtArgs>>): Prisma__TicketTypeClient<$Result.GetResult<Prisma.$TicketTypePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TicketType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketTypeFindUniqueOrThrowArgs} args - Arguments to find a TicketType
     * @example
     * // Get one TicketType
     * const ticketType = await prisma.ticketType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketTypeClient<$Result.GetResult<Prisma.$TicketTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TicketType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTypeFindFirstArgs} args - Arguments to find a TicketType
     * @example
     * // Get one TicketType
     * const ticketType = await prisma.ticketType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketTypeFindFirstArgs>(args?: SelectSubset<T, TicketTypeFindFirstArgs<ExtArgs>>): Prisma__TicketTypeClient<$Result.GetResult<Prisma.$TicketTypePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TicketType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTypeFindFirstOrThrowArgs} args - Arguments to find a TicketType
     * @example
     * // Get one TicketType
     * const ticketType = await prisma.ticketType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketTypeClient<$Result.GetResult<Prisma.$TicketTypePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TicketTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketTypes
     * const ticketTypes = await prisma.ticketType.findMany()
     * 
     * // Get first 10 TicketTypes
     * const ticketTypes = await prisma.ticketType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketTypeWithIdOnly = await prisma.ticketType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketTypeFindManyArgs>(args?: SelectSubset<T, TicketTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTypePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TicketType.
     * @param {TicketTypeCreateArgs} args - Arguments to create a TicketType.
     * @example
     * // Create one TicketType
     * const TicketType = await prisma.ticketType.create({
     *   data: {
     *     // ... data to create a TicketType
     *   }
     * })
     * 
     */
    create<T extends TicketTypeCreateArgs>(args: SelectSubset<T, TicketTypeCreateArgs<ExtArgs>>): Prisma__TicketTypeClient<$Result.GetResult<Prisma.$TicketTypePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TicketTypes.
     * @param {TicketTypeCreateManyArgs} args - Arguments to create many TicketTypes.
     * @example
     * // Create many TicketTypes
     * const ticketType = await prisma.ticketType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketTypeCreateManyArgs>(args?: SelectSubset<T, TicketTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketTypes and returns the data saved in the database.
     * @param {TicketTypeCreateManyAndReturnArgs} args - Arguments to create many TicketTypes.
     * @example
     * // Create many TicketTypes
     * const ticketType = await prisma.ticketType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketTypes and only return the `id`
     * const ticketTypeWithIdOnly = await prisma.ticketType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTypePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a TicketType.
     * @param {TicketTypeDeleteArgs} args - Arguments to delete one TicketType.
     * @example
     * // Delete one TicketType
     * const TicketType = await prisma.ticketType.delete({
     *   where: {
     *     // ... filter to delete one TicketType
     *   }
     * })
     * 
     */
    delete<T extends TicketTypeDeleteArgs>(args: SelectSubset<T, TicketTypeDeleteArgs<ExtArgs>>): Prisma__TicketTypeClient<$Result.GetResult<Prisma.$TicketTypePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TicketType.
     * @param {TicketTypeUpdateArgs} args - Arguments to update one TicketType.
     * @example
     * // Update one TicketType
     * const ticketType = await prisma.ticketType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketTypeUpdateArgs>(args: SelectSubset<T, TicketTypeUpdateArgs<ExtArgs>>): Prisma__TicketTypeClient<$Result.GetResult<Prisma.$TicketTypePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TicketTypes.
     * @param {TicketTypeDeleteManyArgs} args - Arguments to filter TicketTypes to delete.
     * @example
     * // Delete a few TicketTypes
     * const { count } = await prisma.ticketType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketTypeDeleteManyArgs>(args?: SelectSubset<T, TicketTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketTypes
     * const ticketType = await prisma.ticketType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketTypeUpdateManyArgs>(args: SelectSubset<T, TicketTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketTypes and returns the data updated in the database.
     * @param {TicketTypeUpdateManyAndReturnArgs} args - Arguments to update many TicketTypes.
     * @example
     * // Update many TicketTypes
     * const ticketType = await prisma.ticketType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketTypes and only return the `id`
     * const ticketTypeWithIdOnly = await prisma.ticketType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTypePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one TicketType.
     * @param {TicketTypeUpsertArgs} args - Arguments to update or create a TicketType.
     * @example
     * // Update or create a TicketType
     * const ticketType = await prisma.ticketType.upsert({
     *   create: {
     *     // ... data to create a TicketType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketType we want to update
     *   }
     * })
     */
    upsert<T extends TicketTypeUpsertArgs>(args: SelectSubset<T, TicketTypeUpsertArgs<ExtArgs>>): Prisma__TicketTypeClient<$Result.GetResult<Prisma.$TicketTypePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TicketTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTypeCountArgs} args - Arguments to filter TicketTypes to count.
     * @example
     * // Count the number of TicketTypes
     * const count = await prisma.ticketType.count({
     *   where: {
     *     // ... the filter for the TicketTypes we want to count
     *   }
     * })
    **/
    count<T extends TicketTypeCountArgs>(
      args?: Subset<T, TicketTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketTypeAggregateArgs>(args: Subset<T, TicketTypeAggregateArgs>): Prisma.PrismaPromise<GetTicketTypeAggregateType<T>>

    /**
     * Group by TicketType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketTypeGroupByArgs['orderBy'] }
        : { orderBy?: TicketTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketType model
   */
  readonly fields: TicketTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Ticket<T extends TicketType$TicketArgs<ExtArgs> = {}>(args?: Subset<T, TicketType$TicketArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Showing<T extends ShowingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShowingDefaultArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketType model
   */ 
  interface TicketTypeFieldRefs {
    readonly id: FieldRef<"TicketType", 'String'>
    readonly showingId: FieldRef<"TicketType", 'String'>
    readonly name: FieldRef<"TicketType", 'String'>
    readonly description: FieldRef<"TicketType", 'String'>
    readonly color: FieldRef<"TicketType", 'String'>
    readonly isFree: FieldRef<"TicketType", 'Boolean'>
    readonly price: FieldRef<"TicketType", 'Int'>
    readonly originalPrice: FieldRef<"TicketType", 'Int'>
    readonly maxQtyPerOrder: FieldRef<"TicketType", 'Int'>
    readonly minQtyPerOrder: FieldRef<"TicketType", 'Int'>
    readonly effectiveFrom: FieldRef<"TicketType", 'DateTime'>
    readonly effectiveTo: FieldRef<"TicketType", 'DateTime'>
    readonly position: FieldRef<"TicketType", 'Int'>
    readonly status: FieldRef<"TicketType", 'String'>
    readonly imageUrl: FieldRef<"TicketType", 'String'>
    readonly isHidden: FieldRef<"TicketType", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TicketType findUnique
   */
  export type TicketTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketType
     */
    select?: TicketTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketType
     */
    omit?: TicketTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTypeInclude<ExtArgs> | null
    /**
     * Filter, which TicketType to fetch.
     */
    where: TicketTypeWhereUniqueInput
  }

  /**
   * TicketType findUniqueOrThrow
   */
  export type TicketTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketType
     */
    select?: TicketTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketType
     */
    omit?: TicketTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTypeInclude<ExtArgs> | null
    /**
     * Filter, which TicketType to fetch.
     */
    where: TicketTypeWhereUniqueInput
  }

  /**
   * TicketType findFirst
   */
  export type TicketTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketType
     */
    select?: TicketTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketType
     */
    omit?: TicketTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTypeInclude<ExtArgs> | null
    /**
     * Filter, which TicketType to fetch.
     */
    where?: TicketTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTypes to fetch.
     */
    orderBy?: TicketTypeOrderByWithRelationInput | TicketTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketTypes.
     */
    cursor?: TicketTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketTypes.
     */
    distinct?: TicketTypeScalarFieldEnum | TicketTypeScalarFieldEnum[]
  }

  /**
   * TicketType findFirstOrThrow
   */
  export type TicketTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketType
     */
    select?: TicketTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketType
     */
    omit?: TicketTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTypeInclude<ExtArgs> | null
    /**
     * Filter, which TicketType to fetch.
     */
    where?: TicketTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTypes to fetch.
     */
    orderBy?: TicketTypeOrderByWithRelationInput | TicketTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketTypes.
     */
    cursor?: TicketTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketTypes.
     */
    distinct?: TicketTypeScalarFieldEnum | TicketTypeScalarFieldEnum[]
  }

  /**
   * TicketType findMany
   */
  export type TicketTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketType
     */
    select?: TicketTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketType
     */
    omit?: TicketTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTypeInclude<ExtArgs> | null
    /**
     * Filter, which TicketTypes to fetch.
     */
    where?: TicketTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTypes to fetch.
     */
    orderBy?: TicketTypeOrderByWithRelationInput | TicketTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketTypes.
     */
    cursor?: TicketTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTypes.
     */
    skip?: number
    distinct?: TicketTypeScalarFieldEnum | TicketTypeScalarFieldEnum[]
  }

  /**
   * TicketType create
   */
  export type TicketTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketType
     */
    select?: TicketTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketType
     */
    omit?: TicketTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketType.
     */
    data: XOR<TicketTypeCreateInput, TicketTypeUncheckedCreateInput>
  }

  /**
   * TicketType createMany
   */
  export type TicketTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketTypes.
     */
    data: TicketTypeCreateManyInput | TicketTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketType createManyAndReturn
   */
  export type TicketTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketType
     */
    select?: TicketTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketType
     */
    omit?: TicketTypeOmit<ExtArgs> | null
    /**
     * The data used to create many TicketTypes.
     */
    data: TicketTypeCreateManyInput | TicketTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketType update
   */
  export type TicketTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketType
     */
    select?: TicketTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketType
     */
    omit?: TicketTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketType.
     */
    data: XOR<TicketTypeUpdateInput, TicketTypeUncheckedUpdateInput>
    /**
     * Choose, which TicketType to update.
     */
    where: TicketTypeWhereUniqueInput
  }

  /**
   * TicketType updateMany
   */
  export type TicketTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketTypes.
     */
    data: XOR<TicketTypeUpdateManyMutationInput, TicketTypeUncheckedUpdateManyInput>
    /**
     * Filter which TicketTypes to update
     */
    where?: TicketTypeWhereInput
    /**
     * Limit how many TicketTypes to update.
     */
    limit?: number
  }

  /**
   * TicketType updateManyAndReturn
   */
  export type TicketTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketType
     */
    select?: TicketTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketType
     */
    omit?: TicketTypeOmit<ExtArgs> | null
    /**
     * The data used to update TicketTypes.
     */
    data: XOR<TicketTypeUpdateManyMutationInput, TicketTypeUncheckedUpdateManyInput>
    /**
     * Filter which TicketTypes to update
     */
    where?: TicketTypeWhereInput
    /**
     * Limit how many TicketTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketType upsert
   */
  export type TicketTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketType
     */
    select?: TicketTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketType
     */
    omit?: TicketTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketType to update in case it exists.
     */
    where: TicketTypeWhereUniqueInput
    /**
     * In case the TicketType found by the `where` argument doesn't exist, create a new TicketType with this data.
     */
    create: XOR<TicketTypeCreateInput, TicketTypeUncheckedCreateInput>
    /**
     * In case the TicketType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketTypeUpdateInput, TicketTypeUncheckedUpdateInput>
  }

  /**
   * TicketType delete
   */
  export type TicketTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketType
     */
    select?: TicketTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketType
     */
    omit?: TicketTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTypeInclude<ExtArgs> | null
    /**
     * Filter which TicketType to delete.
     */
    where: TicketTypeWhereUniqueInput
  }

  /**
   * TicketType deleteMany
   */
  export type TicketTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketTypes to delete
     */
    where?: TicketTypeWhereInput
    /**
     * Limit how many TicketTypes to delete.
     */
    limit?: number
  }

  /**
   * TicketType.Ticket
   */
  export type TicketType$TicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * TicketType without action
   */
  export type TicketTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketType
     */
    select?: TicketTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketType
     */
    omit?: TicketTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTypeInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    password: 'password',
    role_id: 'role_id',
    created_at: 'created_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    role_name: 'role_name'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const ProvinceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at'
  };

  export type ProvinceScalarFieldEnum = (typeof ProvinceScalarFieldEnum)[keyof typeof ProvinceScalarFieldEnum]


  export const UserProvinceScalarFieldEnum: {
    userId: 'userId',
    provinceId: 'provinceId'
  };

  export type UserProvinceScalarFieldEnum = (typeof UserProvinceScalarFieldEnum)[keyof typeof UserProvinceScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    email: 'email',
    revoked: 'revoked',
    expiresAt: 'expiresAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const OtpScalarFieldEnum: {
    id: 'id',
    email: 'email',
    otp: 'otp',
    type: 'type',
    expiresAt: 'expiresAt',
    isUsed: 'isUsed',
    createdAt: 'createdAt',
    attempts: 'attempts',
    requestToken: 'requestToken'
  };

  export type OtpScalarFieldEnum = (typeof OtpScalarFieldEnum)[keyof typeof OtpScalarFieldEnum]


  export const CategoriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]


  export const EventCategoriesScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    categoryId: 'categoryId',
    isSpecial: 'isSpecial'
  };

  export type EventCategoriesScalarFieldEnum = (typeof EventCategoriesScalarFieldEnum)[keyof typeof EventCategoriesScalarFieldEnum]


  export const EventsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    organizerId: 'organizerId',
    status: 'status',
    locationId: 'locationId',
    venue: 'venue',
    imgLogoId: 'imgLogoId',
    imgPosterId: 'imgPosterId',
    createdAt: 'createdAt',
    minTicketPrice: 'minTicketPrice',
    isOnlyOnEve: 'isOnlyOnEve',
    isSpecial: 'isSpecial',
    lastScore: 'lastScore',
    totalClicks: 'totalClicks',
    weekClicks: 'weekClicks'
  };

  export type EventsScalarFieldEnum = (typeof EventsScalarFieldEnum)[keyof typeof EventsScalarFieldEnum]


  export const ImagesScalarFieldEnum: {
    id: 'id',
    imageUrl: 'imageUrl'
  };

  export type ImagesScalarFieldEnum = (typeof ImagesScalarFieldEnum)[keyof typeof ImagesScalarFieldEnum]


  export const DistrictsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    provinceId: 'provinceId',
    createdAt: 'createdAt'
  };

  export type DistrictsScalarFieldEnum = (typeof DistrictsScalarFieldEnum)[keyof typeof DistrictsScalarFieldEnum]


  export const LocationsScalarFieldEnum: {
    id: 'id',
    street: 'street',
    ward: 'ward',
    districtId: 'districtId',
    createdAt: 'createdAt'
  };

  export type LocationsScalarFieldEnum = (typeof LocationsScalarFieldEnum)[keyof typeof LocationsScalarFieldEnum]


  export const RowScalarFieldEnum: {
    id: 'id',
    name: 'name',
    sectionId: 'sectionId',
    createdAt: 'createdAt'
  };

  export type RowScalarFieldEnum = (typeof RowScalarFieldEnum)[keyof typeof RowScalarFieldEnum]


  export const SeatScalarFieldEnum: {
    id: 'id',
    name: 'name',
    rowId: 'rowId',
    positionX: 'positionX',
    positionY: 'positionY',
    createdAt: 'createdAt',
    position: 'position'
  };

  export type SeatScalarFieldEnum = (typeof SeatScalarFieldEnum)[keyof typeof SeatScalarFieldEnum]


  export const SeatmapScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    viewBox: 'viewBox',
    status: 'status'
  };

  export type SeatmapScalarFieldEnum = (typeof SeatmapScalarFieldEnum)[keyof typeof SeatmapScalarFieldEnum]


  export const SectionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    seatmapId: 'seatmapId',
    isStage: 'isStage',
    element: 'element',
    attribute: 'attribute',
    createdAt: 'createdAt',
    ticketTypeId: 'ticketTypeId'
  };

  export type SectionScalarFieldEnum = (typeof SectionScalarFieldEnum)[keyof typeof SectionScalarFieldEnum]


  export const ShowingScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    status: 'status',
    isFree: 'isFree',
    isSalable: 'isSalable',
    isPresale: 'isPresale',
    seatMapId: 'seatMapId',
    startTime: 'startTime',
    endTime: 'endTime',
    isEnabledQueueWaiting: 'isEnabledQueueWaiting',
    showAllSeats: 'showAllSeats'
  };

  export type ShowingScalarFieldEnum = (typeof ShowingScalarFieldEnum)[keyof typeof ShowingScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id',
    seatId: 'seatId',
    showingId: 'showingId',
    ticketTypeId: 'ticketTypeId',
    status: 'status',
    price: 'price',
    userId: 'userId',
    purchasedAt: 'purchasedAt',
    qrCode: 'qrCode'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const TicketTypeScalarFieldEnum: {
    id: 'id',
    showingId: 'showingId',
    name: 'name',
    description: 'description',
    color: 'color',
    isFree: 'isFree',
    price: 'price',
    originalPrice: 'originalPrice',
    maxQtyPerOrder: 'maxQtyPerOrder',
    minQtyPerOrder: 'minQtyPerOrder',
    effectiveFrom: 'effectiveFrom',
    effectiveTo: 'effectiveTo',
    position: 'position',
    status: 'status',
    imageUrl: 'imageUrl',
    isHidden: 'isHidden'
  };

  export type TicketTypeScalarFieldEnum = (typeof TicketTypeScalarFieldEnum)[keyof typeof TicketTypeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'OTPType'
   */
  export type EnumOTPTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OTPType'>
    


  /**
   * Reference to a field of type 'OTPType[]'
   */
  export type ListEnumOTPTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OTPType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role_id?: IntNullableFilter<"User"> | number | null
    created_at?: DateTimeFilter<"User"> | Date | string
    Events?: EventsListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    userProvince?: UserProvinceListRelationFilter
    role?: XOR<RoleNullableScalarRelationFilter, RoleWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    Events?: EventsOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    userProvince?: UserProvinceOrderByRelationAggregateInput
    role?: RoleOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role_id?: IntNullableFilter<"User"> | number | null
    created_at?: DateTimeFilter<"User"> | Date | string
    Events?: EventsListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    userProvince?: UserProvinceListRelationFilter
    role?: XOR<RoleNullableScalarRelationFilter, RoleWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role_id?: IntNullableWithAggregatesFilter<"User"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    role_name?: StringFilter<"Role"> | string
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    role_name?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    role_name?: StringFilter<"Role"> | string
    users?: UserListRelationFilter
  }, "id">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    role_name?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    role_name?: StringWithAggregatesFilter<"Role"> | string
  }

  export type ProvinceWhereInput = {
    AND?: ProvinceWhereInput | ProvinceWhereInput[]
    OR?: ProvinceWhereInput[]
    NOT?: ProvinceWhereInput | ProvinceWhereInput[]
    id?: IntFilter<"Province"> | number
    name?: StringFilter<"Province"> | string
    created_at?: DateTimeFilter<"Province"> | Date | string
    districts?: DistrictsListRelationFilter
    userProvince?: UserProvinceListRelationFilter
  }

  export type ProvinceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    districts?: districtsOrderByRelationAggregateInput
    userProvince?: UserProvinceOrderByRelationAggregateInput
  }

  export type ProvinceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProvinceWhereInput | ProvinceWhereInput[]
    OR?: ProvinceWhereInput[]
    NOT?: ProvinceWhereInput | ProvinceWhereInput[]
    name?: StringFilter<"Province"> | string
    created_at?: DateTimeFilter<"Province"> | Date | string
    districts?: DistrictsListRelationFilter
    userProvince?: UserProvinceListRelationFilter
  }, "id">

  export type ProvinceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    _count?: ProvinceCountOrderByAggregateInput
    _avg?: ProvinceAvgOrderByAggregateInput
    _max?: ProvinceMaxOrderByAggregateInput
    _min?: ProvinceMinOrderByAggregateInput
    _sum?: ProvinceSumOrderByAggregateInput
  }

  export type ProvinceScalarWhereWithAggregatesInput = {
    AND?: ProvinceScalarWhereWithAggregatesInput | ProvinceScalarWhereWithAggregatesInput[]
    OR?: ProvinceScalarWhereWithAggregatesInput[]
    NOT?: ProvinceScalarWhereWithAggregatesInput | ProvinceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Province"> | number
    name?: StringWithAggregatesFilter<"Province"> | string
    created_at?: DateTimeWithAggregatesFilter<"Province"> | Date | string
  }

  export type UserProvinceWhereInput = {
    AND?: UserProvinceWhereInput | UserProvinceWhereInput[]
    OR?: UserProvinceWhereInput[]
    NOT?: UserProvinceWhereInput | UserProvinceWhereInput[]
    userId?: StringFilter<"UserProvince"> | string
    provinceId?: IntFilter<"UserProvince"> | number
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserProvinceOrderByWithRelationInput = {
    userId?: SortOrder
    provinceId?: SortOrder
    province?: ProvinceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserProvinceWhereUniqueInput = Prisma.AtLeast<{
    userId_provinceId?: UserProvinceUserIdProvinceIdCompoundUniqueInput
    AND?: UserProvinceWhereInput | UserProvinceWhereInput[]
    OR?: UserProvinceWhereInput[]
    NOT?: UserProvinceWhereInput | UserProvinceWhereInput[]
    userId?: StringFilter<"UserProvince"> | string
    provinceId?: IntFilter<"UserProvince"> | number
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId_provinceId">

  export type UserProvinceOrderByWithAggregationInput = {
    userId?: SortOrder
    provinceId?: SortOrder
    _count?: UserProvinceCountOrderByAggregateInput
    _avg?: UserProvinceAvgOrderByAggregateInput
    _max?: UserProvinceMaxOrderByAggregateInput
    _min?: UserProvinceMinOrderByAggregateInput
    _sum?: UserProvinceSumOrderByAggregateInput
  }

  export type UserProvinceScalarWhereWithAggregatesInput = {
    AND?: UserProvinceScalarWhereWithAggregatesInput | UserProvinceScalarWhereWithAggregatesInput[]
    OR?: UserProvinceScalarWhereWithAggregatesInput[]
    NOT?: UserProvinceScalarWhereWithAggregatesInput | UserProvinceScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserProvince"> | string
    provinceId?: IntWithAggregatesFilter<"UserProvince"> | number
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: IntFilter<"RefreshToken"> | number
    token?: StringFilter<"RefreshToken"> | string
    email?: StringFilter<"RefreshToken"> | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    email?: SortOrder
    revoked?: SortOrder
    expiresAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    email?: StringFilter<"RefreshToken"> | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    email?: SortOrder
    revoked?: SortOrder
    expiresAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _avg?: RefreshTokenAvgOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
    _sum?: RefreshTokenSumOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RefreshToken"> | number
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    email?: StringWithAggregatesFilter<"RefreshToken"> | string
    revoked?: BoolWithAggregatesFilter<"RefreshToken"> | boolean
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type OtpWhereInput = {
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    id?: StringFilter<"Otp"> | string
    email?: StringFilter<"Otp"> | string
    otp?: StringFilter<"Otp"> | string
    type?: EnumOTPTypeFilter<"Otp"> | $Enums.OTPType
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
    isUsed?: BoolFilter<"Otp"> | boolean
    createdAt?: DateTimeFilter<"Otp"> | Date | string
    attempts?: IntFilter<"Otp"> | number
    requestToken?: StringFilter<"Otp"> | string
  }

  export type OtpOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    attempts?: SortOrder
    requestToken?: SortOrder
  }

  export type OtpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    requestToken?: string
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    email?: StringFilter<"Otp"> | string
    otp?: StringFilter<"Otp"> | string
    type?: EnumOTPTypeFilter<"Otp"> | $Enums.OTPType
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
    isUsed?: BoolFilter<"Otp"> | boolean
    createdAt?: DateTimeFilter<"Otp"> | Date | string
    attempts?: IntFilter<"Otp"> | number
  }, "id" | "requestToken">

  export type OtpOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    attempts?: SortOrder
    requestToken?: SortOrder
    _count?: OtpCountOrderByAggregateInput
    _avg?: OtpAvgOrderByAggregateInput
    _max?: OtpMaxOrderByAggregateInput
    _min?: OtpMinOrderByAggregateInput
    _sum?: OtpSumOrderByAggregateInput
  }

  export type OtpScalarWhereWithAggregatesInput = {
    AND?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    OR?: OtpScalarWhereWithAggregatesInput[]
    NOT?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Otp"> | string
    email?: StringWithAggregatesFilter<"Otp"> | string
    otp?: StringWithAggregatesFilter<"Otp"> | string
    type?: EnumOTPTypeWithAggregatesFilter<"Otp"> | $Enums.OTPType
    expiresAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
    isUsed?: BoolWithAggregatesFilter<"Otp"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
    attempts?: IntWithAggregatesFilter<"Otp"> | number
    requestToken?: StringWithAggregatesFilter<"Otp"> | string
  }

  export type CategoriesWhereInput = {
    AND?: CategoriesWhereInput | CategoriesWhereInput[]
    OR?: CategoriesWhereInput[]
    NOT?: CategoriesWhereInput | CategoriesWhereInput[]
    id?: IntFilter<"Categories"> | number
    name?: StringFilter<"Categories"> | string
    createdAt?: DateTimeFilter<"Categories"> | Date | string
    EventCategories?: EventCategoriesListRelationFilter
  }

  export type CategoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    EventCategories?: EventCategoriesOrderByRelationAggregateInput
  }

  export type CategoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CategoriesWhereInput | CategoriesWhereInput[]
    OR?: CategoriesWhereInput[]
    NOT?: CategoriesWhereInput | CategoriesWhereInput[]
    name?: StringFilter<"Categories"> | string
    createdAt?: DateTimeFilter<"Categories"> | Date | string
    EventCategories?: EventCategoriesListRelationFilter
  }, "id">

  export type CategoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: CategoriesCountOrderByAggregateInput
    _avg?: CategoriesAvgOrderByAggregateInput
    _max?: CategoriesMaxOrderByAggregateInput
    _min?: CategoriesMinOrderByAggregateInput
    _sum?: CategoriesSumOrderByAggregateInput
  }

  export type CategoriesScalarWhereWithAggregatesInput = {
    AND?: CategoriesScalarWhereWithAggregatesInput | CategoriesScalarWhereWithAggregatesInput[]
    OR?: CategoriesScalarWhereWithAggregatesInput[]
    NOT?: CategoriesScalarWhereWithAggregatesInput | CategoriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Categories"> | number
    name?: StringWithAggregatesFilter<"Categories"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Categories"> | Date | string
  }

  export type EventCategoriesWhereInput = {
    AND?: EventCategoriesWhereInput | EventCategoriesWhereInput[]
    OR?: EventCategoriesWhereInput[]
    NOT?: EventCategoriesWhereInput | EventCategoriesWhereInput[]
    id?: IntFilter<"EventCategories"> | number
    eventId?: IntFilter<"EventCategories"> | number
    categoryId?: IntFilter<"EventCategories"> | number
    isSpecial?: BoolFilter<"EventCategories"> | boolean
    Categories?: XOR<CategoriesScalarRelationFilter, CategoriesWhereInput>
    Events?: XOR<EventsScalarRelationFilter, EventsWhereInput>
  }

  export type EventCategoriesOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    categoryId?: SortOrder
    isSpecial?: SortOrder
    Categories?: CategoriesOrderByWithRelationInput
    Events?: EventsOrderByWithRelationInput
  }

  export type EventCategoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EventCategoriesWhereInput | EventCategoriesWhereInput[]
    OR?: EventCategoriesWhereInput[]
    NOT?: EventCategoriesWhereInput | EventCategoriesWhereInput[]
    eventId?: IntFilter<"EventCategories"> | number
    categoryId?: IntFilter<"EventCategories"> | number
    isSpecial?: BoolFilter<"EventCategories"> | boolean
    Categories?: XOR<CategoriesScalarRelationFilter, CategoriesWhereInput>
    Events?: XOR<EventsScalarRelationFilter, EventsWhereInput>
  }, "id">

  export type EventCategoriesOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    categoryId?: SortOrder
    isSpecial?: SortOrder
    _count?: EventCategoriesCountOrderByAggregateInput
    _avg?: EventCategoriesAvgOrderByAggregateInput
    _max?: EventCategoriesMaxOrderByAggregateInput
    _min?: EventCategoriesMinOrderByAggregateInput
    _sum?: EventCategoriesSumOrderByAggregateInput
  }

  export type EventCategoriesScalarWhereWithAggregatesInput = {
    AND?: EventCategoriesScalarWhereWithAggregatesInput | EventCategoriesScalarWhereWithAggregatesInput[]
    OR?: EventCategoriesScalarWhereWithAggregatesInput[]
    NOT?: EventCategoriesScalarWhereWithAggregatesInput | EventCategoriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EventCategories"> | number
    eventId?: IntWithAggregatesFilter<"EventCategories"> | number
    categoryId?: IntWithAggregatesFilter<"EventCategories"> | number
    isSpecial?: BoolWithAggregatesFilter<"EventCategories"> | boolean
  }

  export type EventsWhereInput = {
    AND?: EventsWhereInput | EventsWhereInput[]
    OR?: EventsWhereInput[]
    NOT?: EventsWhereInput | EventsWhereInput[]
    id?: IntFilter<"Events"> | number
    title?: StringFilter<"Events"> | string
    description?: StringNullableFilter<"Events"> | string | null
    startDate?: DateTimeFilter<"Events"> | Date | string
    endDate?: DateTimeFilter<"Events"> | Date | string
    organizerId?: StringNullableFilter<"Events"> | string | null
    status?: StringFilter<"Events"> | string
    locationId?: IntFilter<"Events"> | number
    venue?: StringNullableFilter<"Events"> | string | null
    imgLogoId?: IntNullableFilter<"Events"> | number | null
    imgPosterId?: IntNullableFilter<"Events"> | number | null
    createdAt?: DateTimeFilter<"Events"> | Date | string
    minTicketPrice?: IntFilter<"Events"> | number
    isOnlyOnEve?: BoolFilter<"Events"> | boolean
    isSpecial?: BoolFilter<"Events"> | boolean
    lastScore?: DecimalFilter<"Events"> | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFilter<"Events"> | number
    weekClicks?: IntFilter<"Events"> | number
    EventCategories?: EventCategoriesListRelationFilter
    Images_Events_imgLogoIdToImages?: XOR<ImagesNullableScalarRelationFilter, ImagesWhereInput> | null
    Images_Events_imgPosterIdToImages?: XOR<ImagesNullableScalarRelationFilter, ImagesWhereInput> | null
    locations?: XOR<LocationsScalarRelationFilter, locationsWhereInput>
    users?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Showing?: ShowingListRelationFilter
  }

  export type EventsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    organizerId?: SortOrderInput | SortOrder
    status?: SortOrder
    locationId?: SortOrder
    venue?: SortOrderInput | SortOrder
    imgLogoId?: SortOrderInput | SortOrder
    imgPosterId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    minTicketPrice?: SortOrder
    isOnlyOnEve?: SortOrder
    isSpecial?: SortOrder
    lastScore?: SortOrder
    totalClicks?: SortOrder
    weekClicks?: SortOrder
    EventCategories?: EventCategoriesOrderByRelationAggregateInput
    Images_Events_imgLogoIdToImages?: ImagesOrderByWithRelationInput
    Images_Events_imgPosterIdToImages?: ImagesOrderByWithRelationInput
    locations?: locationsOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
    Showing?: ShowingOrderByRelationAggregateInput
  }

  export type EventsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EventsWhereInput | EventsWhereInput[]
    OR?: EventsWhereInput[]
    NOT?: EventsWhereInput | EventsWhereInput[]
    title?: StringFilter<"Events"> | string
    description?: StringNullableFilter<"Events"> | string | null
    startDate?: DateTimeFilter<"Events"> | Date | string
    endDate?: DateTimeFilter<"Events"> | Date | string
    organizerId?: StringNullableFilter<"Events"> | string | null
    status?: StringFilter<"Events"> | string
    locationId?: IntFilter<"Events"> | number
    venue?: StringNullableFilter<"Events"> | string | null
    imgLogoId?: IntNullableFilter<"Events"> | number | null
    imgPosterId?: IntNullableFilter<"Events"> | number | null
    createdAt?: DateTimeFilter<"Events"> | Date | string
    minTicketPrice?: IntFilter<"Events"> | number
    isOnlyOnEve?: BoolFilter<"Events"> | boolean
    isSpecial?: BoolFilter<"Events"> | boolean
    lastScore?: DecimalFilter<"Events"> | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFilter<"Events"> | number
    weekClicks?: IntFilter<"Events"> | number
    EventCategories?: EventCategoriesListRelationFilter
    Images_Events_imgLogoIdToImages?: XOR<ImagesNullableScalarRelationFilter, ImagesWhereInput> | null
    Images_Events_imgPosterIdToImages?: XOR<ImagesNullableScalarRelationFilter, ImagesWhereInput> | null
    locations?: XOR<LocationsScalarRelationFilter, locationsWhereInput>
    users?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Showing?: ShowingListRelationFilter
  }, "id">

  export type EventsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    organizerId?: SortOrderInput | SortOrder
    status?: SortOrder
    locationId?: SortOrder
    venue?: SortOrderInput | SortOrder
    imgLogoId?: SortOrderInput | SortOrder
    imgPosterId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    minTicketPrice?: SortOrder
    isOnlyOnEve?: SortOrder
    isSpecial?: SortOrder
    lastScore?: SortOrder
    totalClicks?: SortOrder
    weekClicks?: SortOrder
    _count?: EventsCountOrderByAggregateInput
    _avg?: EventsAvgOrderByAggregateInput
    _max?: EventsMaxOrderByAggregateInput
    _min?: EventsMinOrderByAggregateInput
    _sum?: EventsSumOrderByAggregateInput
  }

  export type EventsScalarWhereWithAggregatesInput = {
    AND?: EventsScalarWhereWithAggregatesInput | EventsScalarWhereWithAggregatesInput[]
    OR?: EventsScalarWhereWithAggregatesInput[]
    NOT?: EventsScalarWhereWithAggregatesInput | EventsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Events"> | number
    title?: StringWithAggregatesFilter<"Events"> | string
    description?: StringNullableWithAggregatesFilter<"Events"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Events"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Events"> | Date | string
    organizerId?: StringNullableWithAggregatesFilter<"Events"> | string | null
    status?: StringWithAggregatesFilter<"Events"> | string
    locationId?: IntWithAggregatesFilter<"Events"> | number
    venue?: StringNullableWithAggregatesFilter<"Events"> | string | null
    imgLogoId?: IntNullableWithAggregatesFilter<"Events"> | number | null
    imgPosterId?: IntNullableWithAggregatesFilter<"Events"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Events"> | Date | string
    minTicketPrice?: IntWithAggregatesFilter<"Events"> | number
    isOnlyOnEve?: BoolWithAggregatesFilter<"Events"> | boolean
    isSpecial?: BoolWithAggregatesFilter<"Events"> | boolean
    lastScore?: DecimalWithAggregatesFilter<"Events"> | Decimal | DecimalJsLike | number | string
    totalClicks?: IntWithAggregatesFilter<"Events"> | number
    weekClicks?: IntWithAggregatesFilter<"Events"> | number
  }

  export type ImagesWhereInput = {
    AND?: ImagesWhereInput | ImagesWhereInput[]
    OR?: ImagesWhereInput[]
    NOT?: ImagesWhereInput | ImagesWhereInput[]
    id?: IntFilter<"Images"> | number
    imageUrl?: StringFilter<"Images"> | string
    Events_Events_imgLogoIdToImages?: EventsListRelationFilter
    Events_Events_imgPosterIdToImages?: EventsListRelationFilter
  }

  export type ImagesOrderByWithRelationInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    Events_Events_imgLogoIdToImages?: EventsOrderByRelationAggregateInput
    Events_Events_imgPosterIdToImages?: EventsOrderByRelationAggregateInput
  }

  export type ImagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ImagesWhereInput | ImagesWhereInput[]
    OR?: ImagesWhereInput[]
    NOT?: ImagesWhereInput | ImagesWhereInput[]
    imageUrl?: StringFilter<"Images"> | string
    Events_Events_imgLogoIdToImages?: EventsListRelationFilter
    Events_Events_imgPosterIdToImages?: EventsListRelationFilter
  }, "id">

  export type ImagesOrderByWithAggregationInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    _count?: ImagesCountOrderByAggregateInput
    _avg?: ImagesAvgOrderByAggregateInput
    _max?: ImagesMaxOrderByAggregateInput
    _min?: ImagesMinOrderByAggregateInput
    _sum?: ImagesSumOrderByAggregateInput
  }

  export type ImagesScalarWhereWithAggregatesInput = {
    AND?: ImagesScalarWhereWithAggregatesInput | ImagesScalarWhereWithAggregatesInput[]
    OR?: ImagesScalarWhereWithAggregatesInput[]
    NOT?: ImagesScalarWhereWithAggregatesInput | ImagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Images"> | number
    imageUrl?: StringWithAggregatesFilter<"Images"> | string
  }

  export type districtsWhereInput = {
    AND?: districtsWhereInput | districtsWhereInput[]
    OR?: districtsWhereInput[]
    NOT?: districtsWhereInput | districtsWhereInput[]
    id?: IntFilter<"districts"> | number
    name?: StringFilter<"districts"> | string
    provinceId?: IntFilter<"districts"> | number
    createdAt?: DateTimeFilter<"districts"> | Date | string
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    locations?: LocationsListRelationFilter
  }

  export type districtsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    province?: ProvinceOrderByWithRelationInput
    locations?: locationsOrderByRelationAggregateInput
  }

  export type districtsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: districtsWhereInput | districtsWhereInput[]
    OR?: districtsWhereInput[]
    NOT?: districtsWhereInput | districtsWhereInput[]
    name?: StringFilter<"districts"> | string
    provinceId?: IntFilter<"districts"> | number
    createdAt?: DateTimeFilter<"districts"> | Date | string
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    locations?: LocationsListRelationFilter
  }, "id">

  export type districtsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    _count?: districtsCountOrderByAggregateInput
    _avg?: districtsAvgOrderByAggregateInput
    _max?: districtsMaxOrderByAggregateInput
    _min?: districtsMinOrderByAggregateInput
    _sum?: districtsSumOrderByAggregateInput
  }

  export type districtsScalarWhereWithAggregatesInput = {
    AND?: districtsScalarWhereWithAggregatesInput | districtsScalarWhereWithAggregatesInput[]
    OR?: districtsScalarWhereWithAggregatesInput[]
    NOT?: districtsScalarWhereWithAggregatesInput | districtsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"districts"> | number
    name?: StringWithAggregatesFilter<"districts"> | string
    provinceId?: IntWithAggregatesFilter<"districts"> | number
    createdAt?: DateTimeWithAggregatesFilter<"districts"> | Date | string
  }

  export type locationsWhereInput = {
    AND?: locationsWhereInput | locationsWhereInput[]
    OR?: locationsWhereInput[]
    NOT?: locationsWhereInput | locationsWhereInput[]
    id?: IntFilter<"locations"> | number
    street?: StringFilter<"locations"> | string
    ward?: StringFilter<"locations"> | string
    districtId?: IntFilter<"locations"> | number
    createdAt?: DateTimeFilter<"locations"> | Date | string
    Events?: EventsListRelationFilter
    districts?: XOR<DistrictsScalarRelationFilter, districtsWhereInput>
  }

  export type locationsOrderByWithRelationInput = {
    id?: SortOrder
    street?: SortOrder
    ward?: SortOrder
    districtId?: SortOrder
    createdAt?: SortOrder
    Events?: EventsOrderByRelationAggregateInput
    districts?: districtsOrderByWithRelationInput
  }

  export type locationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: locationsWhereInput | locationsWhereInput[]
    OR?: locationsWhereInput[]
    NOT?: locationsWhereInput | locationsWhereInput[]
    street?: StringFilter<"locations"> | string
    ward?: StringFilter<"locations"> | string
    districtId?: IntFilter<"locations"> | number
    createdAt?: DateTimeFilter<"locations"> | Date | string
    Events?: EventsListRelationFilter
    districts?: XOR<DistrictsScalarRelationFilter, districtsWhereInput>
  }, "id">

  export type locationsOrderByWithAggregationInput = {
    id?: SortOrder
    street?: SortOrder
    ward?: SortOrder
    districtId?: SortOrder
    createdAt?: SortOrder
    _count?: locationsCountOrderByAggregateInput
    _avg?: locationsAvgOrderByAggregateInput
    _max?: locationsMaxOrderByAggregateInput
    _min?: locationsMinOrderByAggregateInput
    _sum?: locationsSumOrderByAggregateInput
  }

  export type locationsScalarWhereWithAggregatesInput = {
    AND?: locationsScalarWhereWithAggregatesInput | locationsScalarWhereWithAggregatesInput[]
    OR?: locationsScalarWhereWithAggregatesInput[]
    NOT?: locationsScalarWhereWithAggregatesInput | locationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"locations"> | number
    street?: StringWithAggregatesFilter<"locations"> | string
    ward?: StringWithAggregatesFilter<"locations"> | string
    districtId?: IntWithAggregatesFilter<"locations"> | number
    createdAt?: DateTimeWithAggregatesFilter<"locations"> | Date | string
  }

  export type RowWhereInput = {
    AND?: RowWhereInput | RowWhereInput[]
    OR?: RowWhereInput[]
    NOT?: RowWhereInput | RowWhereInput[]
    id?: IntFilter<"Row"> | number
    name?: StringFilter<"Row"> | string
    sectionId?: IntFilter<"Row"> | number
    createdAt?: DateTimeFilter<"Row"> | Date | string
    Section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
    Seat?: SeatListRelationFilter
  }

  export type RowOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    Section?: SectionOrderByWithRelationInput
    Seat?: SeatOrderByRelationAggregateInput
  }

  export type RowWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RowWhereInput | RowWhereInput[]
    OR?: RowWhereInput[]
    NOT?: RowWhereInput | RowWhereInput[]
    name?: StringFilter<"Row"> | string
    sectionId?: IntFilter<"Row"> | number
    createdAt?: DateTimeFilter<"Row"> | Date | string
    Section?: XOR<SectionScalarRelationFilter, SectionWhereInput>
    Seat?: SeatListRelationFilter
  }, "id">

  export type RowOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
    _count?: RowCountOrderByAggregateInput
    _avg?: RowAvgOrderByAggregateInput
    _max?: RowMaxOrderByAggregateInput
    _min?: RowMinOrderByAggregateInput
    _sum?: RowSumOrderByAggregateInput
  }

  export type RowScalarWhereWithAggregatesInput = {
    AND?: RowScalarWhereWithAggregatesInput | RowScalarWhereWithAggregatesInput[]
    OR?: RowScalarWhereWithAggregatesInput[]
    NOT?: RowScalarWhereWithAggregatesInput | RowScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Row"> | number
    name?: StringWithAggregatesFilter<"Row"> | string
    sectionId?: IntWithAggregatesFilter<"Row"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Row"> | Date | string
  }

  export type SeatWhereInput = {
    AND?: SeatWhereInput | SeatWhereInput[]
    OR?: SeatWhereInput[]
    NOT?: SeatWhereInput | SeatWhereInput[]
    id?: IntFilter<"Seat"> | number
    name?: StringFilter<"Seat"> | string
    rowId?: IntFilter<"Seat"> | number
    positionX?: FloatFilter<"Seat"> | number
    positionY?: FloatFilter<"Seat"> | number
    createdAt?: DateTimeFilter<"Seat"> | Date | string
    position?: IntFilter<"Seat"> | number
    Row?: XOR<RowScalarRelationFilter, RowWhereInput>
    Ticket?: TicketListRelationFilter
  }

  export type SeatOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    rowId?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    createdAt?: SortOrder
    position?: SortOrder
    Row?: RowOrderByWithRelationInput
    Ticket?: TicketOrderByRelationAggregateInput
  }

  export type SeatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SeatWhereInput | SeatWhereInput[]
    OR?: SeatWhereInput[]
    NOT?: SeatWhereInput | SeatWhereInput[]
    name?: StringFilter<"Seat"> | string
    rowId?: IntFilter<"Seat"> | number
    positionX?: FloatFilter<"Seat"> | number
    positionY?: FloatFilter<"Seat"> | number
    createdAt?: DateTimeFilter<"Seat"> | Date | string
    position?: IntFilter<"Seat"> | number
    Row?: XOR<RowScalarRelationFilter, RowWhereInput>
    Ticket?: TicketListRelationFilter
  }, "id">

  export type SeatOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    rowId?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    createdAt?: SortOrder
    position?: SortOrder
    _count?: SeatCountOrderByAggregateInput
    _avg?: SeatAvgOrderByAggregateInput
    _max?: SeatMaxOrderByAggregateInput
    _min?: SeatMinOrderByAggregateInput
    _sum?: SeatSumOrderByAggregateInput
  }

  export type SeatScalarWhereWithAggregatesInput = {
    AND?: SeatScalarWhereWithAggregatesInput | SeatScalarWhereWithAggregatesInput[]
    OR?: SeatScalarWhereWithAggregatesInput[]
    NOT?: SeatScalarWhereWithAggregatesInput | SeatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Seat"> | number
    name?: StringWithAggregatesFilter<"Seat"> | string
    rowId?: IntWithAggregatesFilter<"Seat"> | number
    positionX?: FloatWithAggregatesFilter<"Seat"> | number
    positionY?: FloatWithAggregatesFilter<"Seat"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Seat"> | Date | string
    position?: IntWithAggregatesFilter<"Seat"> | number
  }

  export type SeatmapWhereInput = {
    AND?: SeatmapWhereInput | SeatmapWhereInput[]
    OR?: SeatmapWhereInput[]
    NOT?: SeatmapWhereInput | SeatmapWhereInput[]
    id?: IntFilter<"Seatmap"> | number
    name?: StringFilter<"Seatmap"> | string
    createdAt?: DateTimeFilter<"Seatmap"> | Date | string
    viewBox?: StringFilter<"Seatmap"> | string
    status?: IntFilter<"Seatmap"> | number
    Section?: SectionListRelationFilter
    Showing?: ShowingListRelationFilter
  }

  export type SeatmapOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    viewBox?: SortOrder
    status?: SortOrder
    Section?: SectionOrderByRelationAggregateInput
    Showing?: ShowingOrderByRelationAggregateInput
  }

  export type SeatmapWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SeatmapWhereInput | SeatmapWhereInput[]
    OR?: SeatmapWhereInput[]
    NOT?: SeatmapWhereInput | SeatmapWhereInput[]
    name?: StringFilter<"Seatmap"> | string
    createdAt?: DateTimeFilter<"Seatmap"> | Date | string
    viewBox?: StringFilter<"Seatmap"> | string
    status?: IntFilter<"Seatmap"> | number
    Section?: SectionListRelationFilter
    Showing?: ShowingListRelationFilter
  }, "id">

  export type SeatmapOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    viewBox?: SortOrder
    status?: SortOrder
    _count?: SeatmapCountOrderByAggregateInput
    _avg?: SeatmapAvgOrderByAggregateInput
    _max?: SeatmapMaxOrderByAggregateInput
    _min?: SeatmapMinOrderByAggregateInput
    _sum?: SeatmapSumOrderByAggregateInput
  }

  export type SeatmapScalarWhereWithAggregatesInput = {
    AND?: SeatmapScalarWhereWithAggregatesInput | SeatmapScalarWhereWithAggregatesInput[]
    OR?: SeatmapScalarWhereWithAggregatesInput[]
    NOT?: SeatmapScalarWhereWithAggregatesInput | SeatmapScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Seatmap"> | number
    name?: StringWithAggregatesFilter<"Seatmap"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Seatmap"> | Date | string
    viewBox?: StringWithAggregatesFilter<"Seatmap"> | string
    status?: IntWithAggregatesFilter<"Seatmap"> | number
  }

  export type SectionWhereInput = {
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    id?: IntFilter<"Section"> | number
    name?: StringFilter<"Section"> | string
    seatmapId?: IntFilter<"Section"> | number
    isStage?: BoolFilter<"Section"> | boolean
    element?: JsonFilter<"Section">
    attribute?: JsonFilter<"Section">
    createdAt?: DateTimeFilter<"Section"> | Date | string
    ticketTypeId?: StringFilter<"Section"> | string
    Row?: RowListRelationFilter
    Seatmap?: XOR<SeatmapScalarRelationFilter, SeatmapWhereInput>
  }

  export type SectionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    seatmapId?: SortOrder
    isStage?: SortOrder
    element?: SortOrder
    attribute?: SortOrder
    createdAt?: SortOrder
    ticketTypeId?: SortOrder
    Row?: RowOrderByRelationAggregateInput
    Seatmap?: SeatmapOrderByWithRelationInput
  }

  export type SectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    name?: StringFilter<"Section"> | string
    seatmapId?: IntFilter<"Section"> | number
    isStage?: BoolFilter<"Section"> | boolean
    element?: JsonFilter<"Section">
    attribute?: JsonFilter<"Section">
    createdAt?: DateTimeFilter<"Section"> | Date | string
    ticketTypeId?: StringFilter<"Section"> | string
    Row?: RowListRelationFilter
    Seatmap?: XOR<SeatmapScalarRelationFilter, SeatmapWhereInput>
  }, "id">

  export type SectionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    seatmapId?: SortOrder
    isStage?: SortOrder
    element?: SortOrder
    attribute?: SortOrder
    createdAt?: SortOrder
    ticketTypeId?: SortOrder
    _count?: SectionCountOrderByAggregateInput
    _avg?: SectionAvgOrderByAggregateInput
    _max?: SectionMaxOrderByAggregateInput
    _min?: SectionMinOrderByAggregateInput
    _sum?: SectionSumOrderByAggregateInput
  }

  export type SectionScalarWhereWithAggregatesInput = {
    AND?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    OR?: SectionScalarWhereWithAggregatesInput[]
    NOT?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Section"> | number
    name?: StringWithAggregatesFilter<"Section"> | string
    seatmapId?: IntWithAggregatesFilter<"Section"> | number
    isStage?: BoolWithAggregatesFilter<"Section"> | boolean
    element?: JsonWithAggregatesFilter<"Section">
    attribute?: JsonWithAggregatesFilter<"Section">
    createdAt?: DateTimeWithAggregatesFilter<"Section"> | Date | string
    ticketTypeId?: StringWithAggregatesFilter<"Section"> | string
  }

  export type ShowingWhereInput = {
    AND?: ShowingWhereInput | ShowingWhereInput[]
    OR?: ShowingWhereInput[]
    NOT?: ShowingWhereInput | ShowingWhereInput[]
    id?: StringFilter<"Showing"> | string
    eventId?: IntFilter<"Showing"> | number
    status?: StringFilter<"Showing"> | string
    isFree?: BoolFilter<"Showing"> | boolean
    isSalable?: BoolFilter<"Showing"> | boolean
    isPresale?: BoolFilter<"Showing"> | boolean
    seatMapId?: IntFilter<"Showing"> | number
    startTime?: DateTimeFilter<"Showing"> | Date | string
    endTime?: DateTimeFilter<"Showing"> | Date | string
    isEnabledQueueWaiting?: BoolFilter<"Showing"> | boolean
    showAllSeats?: BoolFilter<"Showing"> | boolean
    Events?: XOR<EventsScalarRelationFilter, EventsWhereInput>
    Seatmap?: XOR<SeatmapScalarRelationFilter, SeatmapWhereInput>
    Ticket?: TicketListRelationFilter
    TicketType?: TicketTypeListRelationFilter
  }

  export type ShowingOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    status?: SortOrder
    isFree?: SortOrder
    isSalable?: SortOrder
    isPresale?: SortOrder
    seatMapId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isEnabledQueueWaiting?: SortOrder
    showAllSeats?: SortOrder
    Events?: EventsOrderByWithRelationInput
    Seatmap?: SeatmapOrderByWithRelationInput
    Ticket?: TicketOrderByRelationAggregateInput
    TicketType?: TicketTypeOrderByRelationAggregateInput
  }

  export type ShowingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShowingWhereInput | ShowingWhereInput[]
    OR?: ShowingWhereInput[]
    NOT?: ShowingWhereInput | ShowingWhereInput[]
    eventId?: IntFilter<"Showing"> | number
    status?: StringFilter<"Showing"> | string
    isFree?: BoolFilter<"Showing"> | boolean
    isSalable?: BoolFilter<"Showing"> | boolean
    isPresale?: BoolFilter<"Showing"> | boolean
    seatMapId?: IntFilter<"Showing"> | number
    startTime?: DateTimeFilter<"Showing"> | Date | string
    endTime?: DateTimeFilter<"Showing"> | Date | string
    isEnabledQueueWaiting?: BoolFilter<"Showing"> | boolean
    showAllSeats?: BoolFilter<"Showing"> | boolean
    Events?: XOR<EventsScalarRelationFilter, EventsWhereInput>
    Seatmap?: XOR<SeatmapScalarRelationFilter, SeatmapWhereInput>
    Ticket?: TicketListRelationFilter
    TicketType?: TicketTypeListRelationFilter
  }, "id">

  export type ShowingOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    status?: SortOrder
    isFree?: SortOrder
    isSalable?: SortOrder
    isPresale?: SortOrder
    seatMapId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isEnabledQueueWaiting?: SortOrder
    showAllSeats?: SortOrder
    _count?: ShowingCountOrderByAggregateInput
    _avg?: ShowingAvgOrderByAggregateInput
    _max?: ShowingMaxOrderByAggregateInput
    _min?: ShowingMinOrderByAggregateInput
    _sum?: ShowingSumOrderByAggregateInput
  }

  export type ShowingScalarWhereWithAggregatesInput = {
    AND?: ShowingScalarWhereWithAggregatesInput | ShowingScalarWhereWithAggregatesInput[]
    OR?: ShowingScalarWhereWithAggregatesInput[]
    NOT?: ShowingScalarWhereWithAggregatesInput | ShowingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Showing"> | string
    eventId?: IntWithAggregatesFilter<"Showing"> | number
    status?: StringWithAggregatesFilter<"Showing"> | string
    isFree?: BoolWithAggregatesFilter<"Showing"> | boolean
    isSalable?: BoolWithAggregatesFilter<"Showing"> | boolean
    isPresale?: BoolWithAggregatesFilter<"Showing"> | boolean
    seatMapId?: IntWithAggregatesFilter<"Showing"> | number
    startTime?: DateTimeWithAggregatesFilter<"Showing"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Showing"> | Date | string
    isEnabledQueueWaiting?: BoolWithAggregatesFilter<"Showing"> | boolean
    showAllSeats?: BoolWithAggregatesFilter<"Showing"> | boolean
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: StringFilter<"Ticket"> | string
    seatId?: IntFilter<"Ticket"> | number
    showingId?: StringFilter<"Ticket"> | string
    ticketTypeId?: StringFilter<"Ticket"> | string
    status?: IntFilter<"Ticket"> | number
    price?: IntFilter<"Ticket"> | number
    userId?: IntNullableFilter<"Ticket"> | number | null
    purchasedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    qrCode?: StringNullableFilter<"Ticket"> | string | null
    Seat?: XOR<SeatScalarRelationFilter, SeatWhereInput>
    Showing?: XOR<ShowingScalarRelationFilter, ShowingWhereInput>
    TicketType?: XOR<TicketTypeScalarRelationFilter, TicketTypeWhereInput>
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    seatId?: SortOrder
    showingId?: SortOrder
    ticketTypeId?: SortOrder
    status?: SortOrder
    price?: SortOrder
    userId?: SortOrderInput | SortOrder
    purchasedAt?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    Seat?: SeatOrderByWithRelationInput
    Showing?: ShowingOrderByWithRelationInput
    TicketType?: TicketTypeOrderByWithRelationInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    seatId?: IntFilter<"Ticket"> | number
    showingId?: StringFilter<"Ticket"> | string
    ticketTypeId?: StringFilter<"Ticket"> | string
    status?: IntFilter<"Ticket"> | number
    price?: IntFilter<"Ticket"> | number
    userId?: IntNullableFilter<"Ticket"> | number | null
    purchasedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    qrCode?: StringNullableFilter<"Ticket"> | string | null
    Seat?: XOR<SeatScalarRelationFilter, SeatWhereInput>
    Showing?: XOR<ShowingScalarRelationFilter, ShowingWhereInput>
    TicketType?: XOR<TicketTypeScalarRelationFilter, TicketTypeWhereInput>
  }, "id">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    seatId?: SortOrder
    showingId?: SortOrder
    ticketTypeId?: SortOrder
    status?: SortOrder
    price?: SortOrder
    userId?: SortOrderInput | SortOrder
    purchasedAt?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    _count?: TicketCountOrderByAggregateInput
    _avg?: TicketAvgOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
    _sum?: TicketSumOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ticket"> | string
    seatId?: IntWithAggregatesFilter<"Ticket"> | number
    showingId?: StringWithAggregatesFilter<"Ticket"> | string
    ticketTypeId?: StringWithAggregatesFilter<"Ticket"> | string
    status?: IntWithAggregatesFilter<"Ticket"> | number
    price?: IntWithAggregatesFilter<"Ticket"> | number
    userId?: IntNullableWithAggregatesFilter<"Ticket"> | number | null
    purchasedAt?: DateTimeNullableWithAggregatesFilter<"Ticket"> | Date | string | null
    qrCode?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
  }

  export type TicketTypeWhereInput = {
    AND?: TicketTypeWhereInput | TicketTypeWhereInput[]
    OR?: TicketTypeWhereInput[]
    NOT?: TicketTypeWhereInput | TicketTypeWhereInput[]
    id?: StringFilter<"TicketType"> | string
    showingId?: StringFilter<"TicketType"> | string
    name?: StringFilter<"TicketType"> | string
    description?: StringFilter<"TicketType"> | string
    color?: StringFilter<"TicketType"> | string
    isFree?: BoolFilter<"TicketType"> | boolean
    price?: IntFilter<"TicketType"> | number
    originalPrice?: IntFilter<"TicketType"> | number
    maxQtyPerOrder?: IntFilter<"TicketType"> | number
    minQtyPerOrder?: IntFilter<"TicketType"> | number
    effectiveFrom?: DateTimeFilter<"TicketType"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"TicketType"> | Date | string | null
    position?: IntFilter<"TicketType"> | number
    status?: StringFilter<"TicketType"> | string
    imageUrl?: StringFilter<"TicketType"> | string
    isHidden?: BoolFilter<"TicketType"> | boolean
    Ticket?: TicketListRelationFilter
    Showing?: XOR<ShowingScalarRelationFilter, ShowingWhereInput>
  }

  export type TicketTypeOrderByWithRelationInput = {
    id?: SortOrder
    showingId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isFree?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    maxQtyPerOrder?: SortOrder
    minQtyPerOrder?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    position?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrder
    isHidden?: SortOrder
    Ticket?: TicketOrderByRelationAggregateInput
    Showing?: ShowingOrderByWithRelationInput
  }

  export type TicketTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketTypeWhereInput | TicketTypeWhereInput[]
    OR?: TicketTypeWhereInput[]
    NOT?: TicketTypeWhereInput | TicketTypeWhereInput[]
    showingId?: StringFilter<"TicketType"> | string
    name?: StringFilter<"TicketType"> | string
    description?: StringFilter<"TicketType"> | string
    color?: StringFilter<"TicketType"> | string
    isFree?: BoolFilter<"TicketType"> | boolean
    price?: IntFilter<"TicketType"> | number
    originalPrice?: IntFilter<"TicketType"> | number
    maxQtyPerOrder?: IntFilter<"TicketType"> | number
    minQtyPerOrder?: IntFilter<"TicketType"> | number
    effectiveFrom?: DateTimeFilter<"TicketType"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"TicketType"> | Date | string | null
    position?: IntFilter<"TicketType"> | number
    status?: StringFilter<"TicketType"> | string
    imageUrl?: StringFilter<"TicketType"> | string
    isHidden?: BoolFilter<"TicketType"> | boolean
    Ticket?: TicketListRelationFilter
    Showing?: XOR<ShowingScalarRelationFilter, ShowingWhereInput>
  }, "id">

  export type TicketTypeOrderByWithAggregationInput = {
    id?: SortOrder
    showingId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isFree?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    maxQtyPerOrder?: SortOrder
    minQtyPerOrder?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    position?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrder
    isHidden?: SortOrder
    _count?: TicketTypeCountOrderByAggregateInput
    _avg?: TicketTypeAvgOrderByAggregateInput
    _max?: TicketTypeMaxOrderByAggregateInput
    _min?: TicketTypeMinOrderByAggregateInput
    _sum?: TicketTypeSumOrderByAggregateInput
  }

  export type TicketTypeScalarWhereWithAggregatesInput = {
    AND?: TicketTypeScalarWhereWithAggregatesInput | TicketTypeScalarWhereWithAggregatesInput[]
    OR?: TicketTypeScalarWhereWithAggregatesInput[]
    NOT?: TicketTypeScalarWhereWithAggregatesInput | TicketTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketType"> | string
    showingId?: StringWithAggregatesFilter<"TicketType"> | string
    name?: StringWithAggregatesFilter<"TicketType"> | string
    description?: StringWithAggregatesFilter<"TicketType"> | string
    color?: StringWithAggregatesFilter<"TicketType"> | string
    isFree?: BoolWithAggregatesFilter<"TicketType"> | boolean
    price?: IntWithAggregatesFilter<"TicketType"> | number
    originalPrice?: IntWithAggregatesFilter<"TicketType"> | number
    maxQtyPerOrder?: IntWithAggregatesFilter<"TicketType"> | number
    minQtyPerOrder?: IntWithAggregatesFilter<"TicketType"> | number
    effectiveFrom?: DateTimeWithAggregatesFilter<"TicketType"> | Date | string
    effectiveTo?: DateTimeNullableWithAggregatesFilter<"TicketType"> | Date | string | null
    position?: IntWithAggregatesFilter<"TicketType"> | number
    status?: StringWithAggregatesFilter<"TicketType"> | string
    imageUrl?: StringWithAggregatesFilter<"TicketType"> | string
    isHidden?: BoolWithAggregatesFilter<"TicketType"> | boolean
  }

  export type UserCreateInput = {
    id: string
    name: string
    email: string
    phone: string
    password: string
    created_at?: Date | string
    Events?: EventsCreateNestedManyWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    userProvince?: UserProvinceCreateNestedManyWithoutUserInput
    role?: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    name: string
    email: string
    phone: string
    password: string
    role_id?: number | null
    created_at?: Date | string
    Events?: EventsUncheckedCreateNestedManyWithoutUsersInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    userProvince?: UserProvinceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Events?: EventsUpdateManyWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    userProvince?: UserProvinceUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Events?: EventsUncheckedUpdateManyWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    userProvince?: UserProvinceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    name: string
    email: string
    phone: string
    password: string
    role_id?: number | null
    created_at?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id: number
    role_name: string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id: number
    role_name: string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id: number
    role_name: string
  }

  export type RoleUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
  }

  export type ProvinceCreateInput = {
    name: string
    created_at?: Date | string
    districts?: districtsCreateNestedManyWithoutProvinceInput
    userProvince?: UserProvinceCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateInput = {
    id?: number
    name: string
    created_at?: Date | string
    districts?: districtsUncheckedCreateNestedManyWithoutProvinceInput
    userProvince?: UserProvinceUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    districts?: districtsUpdateManyWithoutProvinceNestedInput
    userProvince?: UserProvinceUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    districts?: districtsUncheckedUpdateManyWithoutProvinceNestedInput
    userProvince?: UserProvinceUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceCreateManyInput = {
    id?: number
    name: string
    created_at?: Date | string
  }

  export type ProvinceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProvinceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProvinceCreateInput = {
    province: ProvinceCreateNestedOneWithoutUserProvinceInput
    user: UserCreateNestedOneWithoutUserProvinceInput
  }

  export type UserProvinceUncheckedCreateInput = {
    userId: string
    provinceId: number
  }

  export type UserProvinceUpdateInput = {
    province?: ProvinceUpdateOneRequiredWithoutUserProvinceNestedInput
    user?: UserUpdateOneRequiredWithoutUserProvinceNestedInput
  }

  export type UserProvinceUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    provinceId?: IntFieldUpdateOperationsInput | number
  }

  export type UserProvinceCreateManyInput = {
    userId: string
    provinceId: number
  }

  export type UserProvinceUpdateManyMutationInput = {

  }

  export type UserProvinceUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    provinceId?: IntFieldUpdateOperationsInput | number
  }

  export type RefreshTokenCreateInput = {
    token: string
    revoked?: boolean
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: number
    token: string
    email: string
    revoked?: boolean
    expiresAt: Date | string
  }

  export type RefreshTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: number
    token: string
    email: string
    revoked?: boolean
    expiresAt: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpCreateInput = {
    id: string
    email: string
    otp: string
    type: $Enums.OTPType
    expiresAt: Date | string
    isUsed?: boolean
    createdAt?: Date | string
    attempts: number
    requestToken: string
  }

  export type OtpUncheckedCreateInput = {
    id: string
    email: string
    otp: string
    type: $Enums.OTPType
    expiresAt: Date | string
    isUsed?: boolean
    createdAt?: Date | string
    attempts: number
    requestToken: string
  }

  export type OtpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    type?: EnumOTPTypeFieldUpdateOperationsInput | $Enums.OTPType
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: IntFieldUpdateOperationsInput | number
    requestToken?: StringFieldUpdateOperationsInput | string
  }

  export type OtpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    type?: EnumOTPTypeFieldUpdateOperationsInput | $Enums.OTPType
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: IntFieldUpdateOperationsInput | number
    requestToken?: StringFieldUpdateOperationsInput | string
  }

  export type OtpCreateManyInput = {
    id: string
    email: string
    otp: string
    type: $Enums.OTPType
    expiresAt: Date | string
    isUsed?: boolean
    createdAt?: Date | string
    attempts: number
    requestToken: string
  }

  export type OtpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    type?: EnumOTPTypeFieldUpdateOperationsInput | $Enums.OTPType
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: IntFieldUpdateOperationsInput | number
    requestToken?: StringFieldUpdateOperationsInput | string
  }

  export type OtpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    type?: EnumOTPTypeFieldUpdateOperationsInput | $Enums.OTPType
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: IntFieldUpdateOperationsInput | number
    requestToken?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesCreateInput = {
    name: string
    createdAt?: Date | string
    EventCategories?: EventCategoriesCreateNestedManyWithoutCategoriesInput
  }

  export type CategoriesUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    EventCategories?: EventCategoriesUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoriesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EventCategories?: EventCategoriesUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EventCategories?: EventCategoriesUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoriesCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type CategoriesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCategoriesCreateInput = {
    isSpecial?: boolean
    Categories: CategoriesCreateNestedOneWithoutEventCategoriesInput
    Events: EventsCreateNestedOneWithoutEventCategoriesInput
  }

  export type EventCategoriesUncheckedCreateInput = {
    id?: number
    eventId: number
    categoryId: number
    isSpecial?: boolean
  }

  export type EventCategoriesUpdateInput = {
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    Categories?: CategoriesUpdateOneRequiredWithoutEventCategoriesNestedInput
    Events?: EventsUpdateOneRequiredWithoutEventCategoriesNestedInput
  }

  export type EventCategoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventCategoriesCreateManyInput = {
    id?: number
    eventId: number
    categoryId: number
    isSpecial?: boolean
  }

  export type EventCategoriesUpdateManyMutationInput = {
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventCategoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventsCreateInput = {
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status: string
    venue?: string | null
    createdAt?: Date | string
    minTicketPrice?: number
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore: Decimal | DecimalJsLike | number | string
    totalClicks?: number
    weekClicks?: number
    EventCategories?: EventCategoriesCreateNestedManyWithoutEventsInput
    Images_Events_imgLogoIdToImages?: ImagesCreateNestedOneWithoutEvents_Events_imgLogoIdToImagesInput
    Images_Events_imgPosterIdToImages?: ImagesCreateNestedOneWithoutEvents_Events_imgPosterIdToImagesInput
    locations: locationsCreateNestedOneWithoutEventsInput
    users?: UserCreateNestedOneWithoutEventsInput
    Showing?: ShowingCreateNestedManyWithoutEventsInput
  }

  export type EventsUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    organizerId?: string | null
    status: string
    locationId: number
    venue?: string | null
    imgLogoId?: number | null
    imgPosterId?: number | null
    createdAt?: Date | string
    minTicketPrice?: number
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore: Decimal | DecimalJsLike | number | string
    totalClicks?: number
    weekClicks?: number
    EventCategories?: EventCategoriesUncheckedCreateNestedManyWithoutEventsInput
    Showing?: ShowingUncheckedCreateNestedManyWithoutEventsInput
  }

  export type EventsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minTicketPrice?: IntFieldUpdateOperationsInput | number
    isOnlyOnEve?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    lastScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFieldUpdateOperationsInput | number
    weekClicks?: IntFieldUpdateOperationsInput | number
    EventCategories?: EventCategoriesUpdateManyWithoutEventsNestedInput
    Images_Events_imgLogoIdToImages?: ImagesUpdateOneWithoutEvents_Events_imgLogoIdToImagesNestedInput
    Images_Events_imgPosterIdToImages?: ImagesUpdateOneWithoutEvents_Events_imgPosterIdToImagesNestedInput
    locations?: locationsUpdateOneRequiredWithoutEventsNestedInput
    users?: UserUpdateOneWithoutEventsNestedInput
    Showing?: ShowingUpdateManyWithoutEventsNestedInput
  }

  export type EventsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    organizerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    imgLogoId?: NullableIntFieldUpdateOperationsInput | number | null
    imgPosterId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minTicketPrice?: IntFieldUpdateOperationsInput | number
    isOnlyOnEve?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    lastScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFieldUpdateOperationsInput | number
    weekClicks?: IntFieldUpdateOperationsInput | number
    EventCategories?: EventCategoriesUncheckedUpdateManyWithoutEventsNestedInput
    Showing?: ShowingUncheckedUpdateManyWithoutEventsNestedInput
  }

  export type EventsCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    organizerId?: string | null
    status: string
    locationId: number
    venue?: string | null
    imgLogoId?: number | null
    imgPosterId?: number | null
    createdAt?: Date | string
    minTicketPrice?: number
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore: Decimal | DecimalJsLike | number | string
    totalClicks?: number
    weekClicks?: number
  }

  export type EventsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minTicketPrice?: IntFieldUpdateOperationsInput | number
    isOnlyOnEve?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    lastScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFieldUpdateOperationsInput | number
    weekClicks?: IntFieldUpdateOperationsInput | number
  }

  export type EventsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    organizerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    imgLogoId?: NullableIntFieldUpdateOperationsInput | number | null
    imgPosterId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minTicketPrice?: IntFieldUpdateOperationsInput | number
    isOnlyOnEve?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    lastScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFieldUpdateOperationsInput | number
    weekClicks?: IntFieldUpdateOperationsInput | number
  }

  export type ImagesCreateInput = {
    imageUrl: string
    Events_Events_imgLogoIdToImages?: EventsCreateNestedManyWithoutImages_Events_imgLogoIdToImagesInput
    Events_Events_imgPosterIdToImages?: EventsCreateNestedManyWithoutImages_Events_imgPosterIdToImagesInput
  }

  export type ImagesUncheckedCreateInput = {
    id?: number
    imageUrl: string
    Events_Events_imgLogoIdToImages?: EventsUncheckedCreateNestedManyWithoutImages_Events_imgLogoIdToImagesInput
    Events_Events_imgPosterIdToImages?: EventsUncheckedCreateNestedManyWithoutImages_Events_imgPosterIdToImagesInput
  }

  export type ImagesUpdateInput = {
    imageUrl?: StringFieldUpdateOperationsInput | string
    Events_Events_imgLogoIdToImages?: EventsUpdateManyWithoutImages_Events_imgLogoIdToImagesNestedInput
    Events_Events_imgPosterIdToImages?: EventsUpdateManyWithoutImages_Events_imgPosterIdToImagesNestedInput
  }

  export type ImagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    Events_Events_imgLogoIdToImages?: EventsUncheckedUpdateManyWithoutImages_Events_imgLogoIdToImagesNestedInput
    Events_Events_imgPosterIdToImages?: EventsUncheckedUpdateManyWithoutImages_Events_imgPosterIdToImagesNestedInput
  }

  export type ImagesCreateManyInput = {
    id?: number
    imageUrl: string
  }

  export type ImagesUpdateManyMutationInput = {
    imageUrl?: StringFieldUpdateOperationsInput | string
  }

  export type ImagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
  }

  export type districtsCreateInput = {
    name: string
    createdAt?: Date | string
    province: ProvinceCreateNestedOneWithoutDistrictsInput
    locations?: locationsCreateNestedManyWithoutDistrictsInput
  }

  export type districtsUncheckedCreateInput = {
    id?: number
    name: string
    provinceId: number
    createdAt?: Date | string
    locations?: locationsUncheckedCreateNestedManyWithoutDistrictsInput
  }

  export type districtsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutDistrictsNestedInput
    locations?: locationsUpdateManyWithoutDistrictsNestedInput
  }

  export type districtsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    provinceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: locationsUncheckedUpdateManyWithoutDistrictsNestedInput
  }

  export type districtsCreateManyInput = {
    id?: number
    name: string
    provinceId: number
    createdAt?: Date | string
  }

  export type districtsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type districtsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    provinceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type locationsCreateInput = {
    street: string
    ward: string
    createdAt?: Date | string
    Events?: EventsCreateNestedManyWithoutLocationsInput
    districts: districtsCreateNestedOneWithoutLocationsInput
  }

  export type locationsUncheckedCreateInput = {
    id?: number
    street: string
    ward: string
    districtId: number
    createdAt?: Date | string
    Events?: EventsUncheckedCreateNestedManyWithoutLocationsInput
  }

  export type locationsUpdateInput = {
    street?: StringFieldUpdateOperationsInput | string
    ward?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Events?: EventsUpdateManyWithoutLocationsNestedInput
    districts?: districtsUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type locationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    ward?: StringFieldUpdateOperationsInput | string
    districtId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Events?: EventsUncheckedUpdateManyWithoutLocationsNestedInput
  }

  export type locationsCreateManyInput = {
    id?: number
    street: string
    ward: string
    districtId: number
    createdAt?: Date | string
  }

  export type locationsUpdateManyMutationInput = {
    street?: StringFieldUpdateOperationsInput | string
    ward?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type locationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    ward?: StringFieldUpdateOperationsInput | string
    districtId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RowCreateInput = {
    name: string
    createdAt?: Date | string
    Section: SectionCreateNestedOneWithoutRowInput
    Seat?: SeatCreateNestedManyWithoutRowInput
  }

  export type RowUncheckedCreateInput = {
    id?: number
    name: string
    sectionId: number
    createdAt?: Date | string
    Seat?: SeatUncheckedCreateNestedManyWithoutRowInput
  }

  export type RowUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Section?: SectionUpdateOneRequiredWithoutRowNestedInput
    Seat?: SeatUpdateManyWithoutRowNestedInput
  }

  export type RowUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    sectionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Seat?: SeatUncheckedUpdateManyWithoutRowNestedInput
  }

  export type RowCreateManyInput = {
    id?: number
    name: string
    sectionId: number
    createdAt?: Date | string
  }

  export type RowUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RowUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    sectionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatCreateInput = {
    name: string
    positionX: number
    positionY: number
    createdAt?: Date | string
    position: number
    Row: RowCreateNestedOneWithoutSeatInput
    Ticket?: TicketCreateNestedManyWithoutSeatInput
  }

  export type SeatUncheckedCreateInput = {
    id?: number
    name: string
    rowId: number
    positionX: number
    positionY: number
    createdAt?: Date | string
    position: number
    Ticket?: TicketUncheckedCreateNestedManyWithoutSeatInput
  }

  export type SeatUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: IntFieldUpdateOperationsInput | number
    Row?: RowUpdateOneRequiredWithoutSeatNestedInput
    Ticket?: TicketUpdateManyWithoutSeatNestedInput
  }

  export type SeatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rowId?: IntFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: IntFieldUpdateOperationsInput | number
    Ticket?: TicketUncheckedUpdateManyWithoutSeatNestedInput
  }

  export type SeatCreateManyInput = {
    id?: number
    name: string
    rowId: number
    positionX: number
    positionY: number
    createdAt?: Date | string
    position: number
  }

  export type SeatUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type SeatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rowId?: IntFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type SeatmapCreateInput = {
    name: string
    createdAt?: Date | string
    viewBox: string
    status: number
    Section?: SectionCreateNestedManyWithoutSeatmapInput
    Showing?: ShowingCreateNestedManyWithoutSeatmapInput
  }

  export type SeatmapUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    viewBox: string
    status: number
    Section?: SectionUncheckedCreateNestedManyWithoutSeatmapInput
    Showing?: ShowingUncheckedCreateNestedManyWithoutSeatmapInput
  }

  export type SeatmapUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewBox?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    Section?: SectionUpdateManyWithoutSeatmapNestedInput
    Showing?: ShowingUpdateManyWithoutSeatmapNestedInput
  }

  export type SeatmapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewBox?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    Section?: SectionUncheckedUpdateManyWithoutSeatmapNestedInput
    Showing?: ShowingUncheckedUpdateManyWithoutSeatmapNestedInput
  }

  export type SeatmapCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    viewBox: string
    status: number
  }

  export type SeatmapUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewBox?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type SeatmapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewBox?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type SectionCreateInput = {
    name: string
    isStage: boolean
    element: JsonNullValueInput | InputJsonValue
    attribute: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    ticketTypeId: string
    Row?: RowCreateNestedManyWithoutSectionInput
    Seatmap: SeatmapCreateNestedOneWithoutSectionInput
  }

  export type SectionUncheckedCreateInput = {
    id?: number
    name: string
    seatmapId: number
    isStage: boolean
    element: JsonNullValueInput | InputJsonValue
    attribute: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    ticketTypeId: string
    Row?: RowUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isStage?: BoolFieldUpdateOperationsInput | boolean
    element?: JsonNullValueInput | InputJsonValue
    attribute?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketTypeId?: StringFieldUpdateOperationsInput | string
    Row?: RowUpdateManyWithoutSectionNestedInput
    Seatmap?: SeatmapUpdateOneRequiredWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    seatmapId?: IntFieldUpdateOperationsInput | number
    isStage?: BoolFieldUpdateOperationsInput | boolean
    element?: JsonNullValueInput | InputJsonValue
    attribute?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketTypeId?: StringFieldUpdateOperationsInput | string
    Row?: RowUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionCreateManyInput = {
    id?: number
    name: string
    seatmapId: number
    isStage: boolean
    element: JsonNullValueInput | InputJsonValue
    attribute: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    ticketTypeId: string
  }

  export type SectionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isStage?: BoolFieldUpdateOperationsInput | boolean
    element?: JsonNullValueInput | InputJsonValue
    attribute?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type SectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    seatmapId?: IntFieldUpdateOperationsInput | number
    isStage?: BoolFieldUpdateOperationsInput | boolean
    element?: JsonNullValueInput | InputJsonValue
    attribute?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type ShowingCreateInput = {
    id: string
    status: string
    isFree: boolean
    isSalable: boolean
    isPresale: boolean
    startTime: Date | string
    endTime: Date | string
    isEnabledQueueWaiting: boolean
    showAllSeats: boolean
    Events: EventsCreateNestedOneWithoutShowingInput
    Seatmap: SeatmapCreateNestedOneWithoutShowingInput
    Ticket?: TicketCreateNestedManyWithoutShowingInput
    TicketType?: TicketTypeCreateNestedManyWithoutShowingInput
  }

  export type ShowingUncheckedCreateInput = {
    id: string
    eventId: number
    status: string
    isFree: boolean
    isSalable: boolean
    isPresale: boolean
    seatMapId: number
    startTime: Date | string
    endTime: Date | string
    isEnabledQueueWaiting: boolean
    showAllSeats: boolean
    Ticket?: TicketUncheckedCreateNestedManyWithoutShowingInput
    TicketType?: TicketTypeUncheckedCreateNestedManyWithoutShowingInput
  }

  export type ShowingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    isSalable?: BoolFieldUpdateOperationsInput | boolean
    isPresale?: BoolFieldUpdateOperationsInput | boolean
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnabledQueueWaiting?: BoolFieldUpdateOperationsInput | boolean
    showAllSeats?: BoolFieldUpdateOperationsInput | boolean
    Events?: EventsUpdateOneRequiredWithoutShowingNestedInput
    Seatmap?: SeatmapUpdateOneRequiredWithoutShowingNestedInput
    Ticket?: TicketUpdateManyWithoutShowingNestedInput
    TicketType?: TicketTypeUpdateManyWithoutShowingNestedInput
  }

  export type ShowingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    isSalable?: BoolFieldUpdateOperationsInput | boolean
    isPresale?: BoolFieldUpdateOperationsInput | boolean
    seatMapId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnabledQueueWaiting?: BoolFieldUpdateOperationsInput | boolean
    showAllSeats?: BoolFieldUpdateOperationsInput | boolean
    Ticket?: TicketUncheckedUpdateManyWithoutShowingNestedInput
    TicketType?: TicketTypeUncheckedUpdateManyWithoutShowingNestedInput
  }

  export type ShowingCreateManyInput = {
    id: string
    eventId: number
    status: string
    isFree: boolean
    isSalable: boolean
    isPresale: boolean
    seatMapId: number
    startTime: Date | string
    endTime: Date | string
    isEnabledQueueWaiting: boolean
    showAllSeats: boolean
  }

  export type ShowingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    isSalable?: BoolFieldUpdateOperationsInput | boolean
    isPresale?: BoolFieldUpdateOperationsInput | boolean
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnabledQueueWaiting?: BoolFieldUpdateOperationsInput | boolean
    showAllSeats?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ShowingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    isSalable?: BoolFieldUpdateOperationsInput | boolean
    isPresale?: BoolFieldUpdateOperationsInput | boolean
    seatMapId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnabledQueueWaiting?: BoolFieldUpdateOperationsInput | boolean
    showAllSeats?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TicketCreateInput = {
    id?: string
    status: number
    price: number
    userId?: number | null
    purchasedAt?: Date | string | null
    qrCode?: string | null
    Seat: SeatCreateNestedOneWithoutTicketInput
    Showing: ShowingCreateNestedOneWithoutTicketInput
    TicketType: TicketTypeCreateNestedOneWithoutTicketInput
  }

  export type TicketUncheckedCreateInput = {
    id?: string
    seatId: number
    showingId: string
    ticketTypeId: string
    status: number
    price: number
    userId?: number | null
    purchasedAt?: Date | string | null
    qrCode?: string | null
  }

  export type TicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    Seat?: SeatUpdateOneRequiredWithoutTicketNestedInput
    Showing?: ShowingUpdateOneRequiredWithoutTicketNestedInput
    TicketType?: TicketTypeUpdateOneRequiredWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatId?: IntFieldUpdateOperationsInput | number
    showingId?: StringFieldUpdateOperationsInput | string
    ticketTypeId?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketCreateManyInput = {
    id?: string
    seatId: number
    showingId: string
    ticketTypeId: string
    status: number
    price: number
    userId?: number | null
    purchasedAt?: Date | string | null
    qrCode?: string | null
  }

  export type TicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatId?: IntFieldUpdateOperationsInput | number
    showingId?: StringFieldUpdateOperationsInput | string
    ticketTypeId?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketTypeCreateInput = {
    id: string
    name: string
    description: string
    color: string
    isFree: boolean
    price: number
    originalPrice: number
    maxQtyPerOrder: number
    minQtyPerOrder: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    position: number
    status: string
    imageUrl: string
    isHidden?: boolean
    Ticket?: TicketCreateNestedManyWithoutTicketTypeInput
    Showing: ShowingCreateNestedOneWithoutTicketTypeInput
  }

  export type TicketTypeUncheckedCreateInput = {
    id: string
    showingId: string
    name: string
    description: string
    color: string
    isFree: boolean
    price: number
    originalPrice: number
    maxQtyPerOrder: number
    minQtyPerOrder: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    position: number
    status: string
    imageUrl: string
    isHidden?: boolean
    Ticket?: TicketUncheckedCreateNestedManyWithoutTicketTypeInput
  }

  export type TicketTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: IntFieldUpdateOperationsInput | number
    maxQtyPerOrder?: IntFieldUpdateOperationsInput | number
    minQtyPerOrder?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    Ticket?: TicketUpdateManyWithoutTicketTypeNestedInput
    Showing?: ShowingUpdateOneRequiredWithoutTicketTypeNestedInput
  }

  export type TicketTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    showingId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: IntFieldUpdateOperationsInput | number
    maxQtyPerOrder?: IntFieldUpdateOperationsInput | number
    minQtyPerOrder?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    Ticket?: TicketUncheckedUpdateManyWithoutTicketTypeNestedInput
  }

  export type TicketTypeCreateManyInput = {
    id: string
    showingId: string
    name: string
    description: string
    color: string
    isFree: boolean
    price: number
    originalPrice: number
    maxQtyPerOrder: number
    minQtyPerOrder: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    position: number
    status: string
    imageUrl: string
    isHidden?: boolean
  }

  export type TicketTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: IntFieldUpdateOperationsInput | number
    maxQtyPerOrder?: IntFieldUpdateOperationsInput | number
    minQtyPerOrder?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TicketTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    showingId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: IntFieldUpdateOperationsInput | number
    maxQtyPerOrder?: IntFieldUpdateOperationsInput | number
    minQtyPerOrder?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EventsListRelationFilter = {
    every?: EventsWhereInput
    some?: EventsWhereInput
    none?: EventsWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type UserProvinceListRelationFilter = {
    every?: UserProvinceWhereInput
    some?: UserProvinceWhereInput
    none?: UserProvinceWhereInput
  }

  export type RoleNullableScalarRelationFilter = {
    is?: RoleWhereInput | null
    isNot?: RoleWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EventsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProvinceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    role_name?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    role_name?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    role_name?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DistrictsListRelationFilter = {
    every?: districtsWhereInput
    some?: districtsWhereInput
    none?: districtsWhereInput
  }

  export type districtsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProvinceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type ProvinceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProvinceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type ProvinceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type ProvinceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProvinceScalarRelationFilter = {
    is?: ProvinceWhereInput
    isNot?: ProvinceWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserProvinceUserIdProvinceIdCompoundUniqueInput = {
    userId: string
    provinceId: number
  }

  export type UserProvinceCountOrderByAggregateInput = {
    userId?: SortOrder
    provinceId?: SortOrder
  }

  export type UserProvinceAvgOrderByAggregateInput = {
    provinceId?: SortOrder
  }

  export type UserProvinceMaxOrderByAggregateInput = {
    userId?: SortOrder
    provinceId?: SortOrder
  }

  export type UserProvinceMinOrderByAggregateInput = {
    userId?: SortOrder
    provinceId?: SortOrder
  }

  export type UserProvinceSumOrderByAggregateInput = {
    provinceId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    email?: SortOrder
    revoked?: SortOrder
    expiresAt?: SortOrder
  }

  export type RefreshTokenAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    email?: SortOrder
    revoked?: SortOrder
    expiresAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    email?: SortOrder
    revoked?: SortOrder
    expiresAt?: SortOrder
  }

  export type RefreshTokenSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumOTPTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OTPType | EnumOTPTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OTPType[] | ListEnumOTPTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OTPType[] | ListEnumOTPTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOTPTypeFilter<$PrismaModel> | $Enums.OTPType
  }

  export type OtpCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    attempts?: SortOrder
    requestToken?: SortOrder
  }

  export type OtpAvgOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type OtpMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    attempts?: SortOrder
    requestToken?: SortOrder
  }

  export type OtpMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    attempts?: SortOrder
    requestToken?: SortOrder
  }

  export type OtpSumOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type EnumOTPTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OTPType | EnumOTPTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OTPType[] | ListEnumOTPTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OTPType[] | ListEnumOTPTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOTPTypeWithAggregatesFilter<$PrismaModel> | $Enums.OTPType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOTPTypeFilter<$PrismaModel>
    _max?: NestedEnumOTPTypeFilter<$PrismaModel>
  }

  export type EventCategoriesListRelationFilter = {
    every?: EventCategoriesWhereInput
    some?: EventCategoriesWhereInput
    none?: EventCategoriesWhereInput
  }

  export type EventCategoriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type CategoriesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type CategoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type CategoriesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoriesScalarRelationFilter = {
    is?: CategoriesWhereInput
    isNot?: CategoriesWhereInput
  }

  export type EventsScalarRelationFilter = {
    is?: EventsWhereInput
    isNot?: EventsWhereInput
  }

  export type EventCategoriesCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    categoryId?: SortOrder
    isSpecial?: SortOrder
  }

  export type EventCategoriesAvgOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    categoryId?: SortOrder
  }

  export type EventCategoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    categoryId?: SortOrder
    isSpecial?: SortOrder
  }

  export type EventCategoriesMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    categoryId?: SortOrder
    isSpecial?: SortOrder
  }

  export type EventCategoriesSumOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    categoryId?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ImagesNullableScalarRelationFilter = {
    is?: ImagesWhereInput | null
    isNot?: ImagesWhereInput | null
  }

  export type LocationsScalarRelationFilter = {
    is?: locationsWhereInput
    isNot?: locationsWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ShowingListRelationFilter = {
    every?: ShowingWhereInput
    some?: ShowingWhereInput
    none?: ShowingWhereInput
  }

  export type ShowingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    organizerId?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    venue?: SortOrder
    imgLogoId?: SortOrder
    imgPosterId?: SortOrder
    createdAt?: SortOrder
    minTicketPrice?: SortOrder
    isOnlyOnEve?: SortOrder
    isSpecial?: SortOrder
    lastScore?: SortOrder
    totalClicks?: SortOrder
    weekClicks?: SortOrder
  }

  export type EventsAvgOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    imgLogoId?: SortOrder
    imgPosterId?: SortOrder
    minTicketPrice?: SortOrder
    lastScore?: SortOrder
    totalClicks?: SortOrder
    weekClicks?: SortOrder
  }

  export type EventsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    organizerId?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    venue?: SortOrder
    imgLogoId?: SortOrder
    imgPosterId?: SortOrder
    createdAt?: SortOrder
    minTicketPrice?: SortOrder
    isOnlyOnEve?: SortOrder
    isSpecial?: SortOrder
    lastScore?: SortOrder
    totalClicks?: SortOrder
    weekClicks?: SortOrder
  }

  export type EventsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    organizerId?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    venue?: SortOrder
    imgLogoId?: SortOrder
    imgPosterId?: SortOrder
    createdAt?: SortOrder
    minTicketPrice?: SortOrder
    isOnlyOnEve?: SortOrder
    isSpecial?: SortOrder
    lastScore?: SortOrder
    totalClicks?: SortOrder
    weekClicks?: SortOrder
  }

  export type EventsSumOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    imgLogoId?: SortOrder
    imgPosterId?: SortOrder
    minTicketPrice?: SortOrder
    lastScore?: SortOrder
    totalClicks?: SortOrder
    weekClicks?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ImagesCountOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
  }

  export type ImagesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ImagesMaxOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
  }

  export type ImagesMinOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
  }

  export type ImagesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LocationsListRelationFilter = {
    every?: locationsWhereInput
    some?: locationsWhereInput
    none?: locationsWhereInput
  }

  export type locationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type districtsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
  }

  export type districtsAvgOrderByAggregateInput = {
    id?: SortOrder
    provinceId?: SortOrder
  }

  export type districtsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
  }

  export type districtsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
  }

  export type districtsSumOrderByAggregateInput = {
    id?: SortOrder
    provinceId?: SortOrder
  }

  export type DistrictsScalarRelationFilter = {
    is?: districtsWhereInput
    isNot?: districtsWhereInput
  }

  export type locationsCountOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    ward?: SortOrder
    districtId?: SortOrder
    createdAt?: SortOrder
  }

  export type locationsAvgOrderByAggregateInput = {
    id?: SortOrder
    districtId?: SortOrder
  }

  export type locationsMaxOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    ward?: SortOrder
    districtId?: SortOrder
    createdAt?: SortOrder
  }

  export type locationsMinOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    ward?: SortOrder
    districtId?: SortOrder
    createdAt?: SortOrder
  }

  export type locationsSumOrderByAggregateInput = {
    id?: SortOrder
    districtId?: SortOrder
  }

  export type SectionScalarRelationFilter = {
    is?: SectionWhereInput
    isNot?: SectionWhereInput
  }

  export type SeatListRelationFilter = {
    every?: SeatWhereInput
    some?: SeatWhereInput
    none?: SeatWhereInput
  }

  export type SeatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RowCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RowAvgOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
  }

  export type RowMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RowMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sectionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RowSumOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type RowScalarRelationFilter = {
    is?: RowWhereInput
    isNot?: RowWhereInput
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeatCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rowId?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    createdAt?: SortOrder
    position?: SortOrder
  }

  export type SeatAvgOrderByAggregateInput = {
    id?: SortOrder
    rowId?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    position?: SortOrder
  }

  export type SeatMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rowId?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    createdAt?: SortOrder
    position?: SortOrder
  }

  export type SeatMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rowId?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    createdAt?: SortOrder
    position?: SortOrder
  }

  export type SeatSumOrderByAggregateInput = {
    id?: SortOrder
    rowId?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    position?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type SectionListRelationFilter = {
    every?: SectionWhereInput
    some?: SectionWhereInput
    none?: SectionWhereInput
  }

  export type SectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeatmapCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    viewBox?: SortOrder
    status?: SortOrder
  }

  export type SeatmapAvgOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type SeatmapMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    viewBox?: SortOrder
    status?: SortOrder
  }

  export type SeatmapMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    viewBox?: SortOrder
    status?: SortOrder
  }

  export type SeatmapSumOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type RowListRelationFilter = {
    every?: RowWhereInput
    some?: RowWhereInput
    none?: RowWhereInput
  }

  export type SeatmapScalarRelationFilter = {
    is?: SeatmapWhereInput
    isNot?: SeatmapWhereInput
  }

  export type RowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SectionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    seatmapId?: SortOrder
    isStage?: SortOrder
    element?: SortOrder
    attribute?: SortOrder
    createdAt?: SortOrder
    ticketTypeId?: SortOrder
  }

  export type SectionAvgOrderByAggregateInput = {
    id?: SortOrder
    seatmapId?: SortOrder
  }

  export type SectionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    seatmapId?: SortOrder
    isStage?: SortOrder
    createdAt?: SortOrder
    ticketTypeId?: SortOrder
  }

  export type SectionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    seatmapId?: SortOrder
    isStage?: SortOrder
    createdAt?: SortOrder
    ticketTypeId?: SortOrder
  }

  export type SectionSumOrderByAggregateInput = {
    id?: SortOrder
    seatmapId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type TicketTypeListRelationFilter = {
    every?: TicketTypeWhereInput
    some?: TicketTypeWhereInput
    none?: TicketTypeWhereInput
  }

  export type TicketTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShowingCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    status?: SortOrder
    isFree?: SortOrder
    isSalable?: SortOrder
    isPresale?: SortOrder
    seatMapId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isEnabledQueueWaiting?: SortOrder
    showAllSeats?: SortOrder
  }

  export type ShowingAvgOrderByAggregateInput = {
    eventId?: SortOrder
    seatMapId?: SortOrder
  }

  export type ShowingMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    status?: SortOrder
    isFree?: SortOrder
    isSalable?: SortOrder
    isPresale?: SortOrder
    seatMapId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isEnabledQueueWaiting?: SortOrder
    showAllSeats?: SortOrder
  }

  export type ShowingMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    status?: SortOrder
    isFree?: SortOrder
    isSalable?: SortOrder
    isPresale?: SortOrder
    seatMapId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isEnabledQueueWaiting?: SortOrder
    showAllSeats?: SortOrder
  }

  export type ShowingSumOrderByAggregateInput = {
    eventId?: SortOrder
    seatMapId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SeatScalarRelationFilter = {
    is?: SeatWhereInput
    isNot?: SeatWhereInput
  }

  export type ShowingScalarRelationFilter = {
    is?: ShowingWhereInput
    isNot?: ShowingWhereInput
  }

  export type TicketTypeScalarRelationFilter = {
    is?: TicketTypeWhereInput
    isNot?: TicketTypeWhereInput
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    seatId?: SortOrder
    showingId?: SortOrder
    ticketTypeId?: SortOrder
    status?: SortOrder
    price?: SortOrder
    userId?: SortOrder
    purchasedAt?: SortOrder
    qrCode?: SortOrder
  }

  export type TicketAvgOrderByAggregateInput = {
    seatId?: SortOrder
    status?: SortOrder
    price?: SortOrder
    userId?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    seatId?: SortOrder
    showingId?: SortOrder
    ticketTypeId?: SortOrder
    status?: SortOrder
    price?: SortOrder
    userId?: SortOrder
    purchasedAt?: SortOrder
    qrCode?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    seatId?: SortOrder
    showingId?: SortOrder
    ticketTypeId?: SortOrder
    status?: SortOrder
    price?: SortOrder
    userId?: SortOrder
    purchasedAt?: SortOrder
    qrCode?: SortOrder
  }

  export type TicketSumOrderByAggregateInput = {
    seatId?: SortOrder
    status?: SortOrder
    price?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type TicketTypeCountOrderByAggregateInput = {
    id?: SortOrder
    showingId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isFree?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    maxQtyPerOrder?: SortOrder
    minQtyPerOrder?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    position?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrder
    isHidden?: SortOrder
  }

  export type TicketTypeAvgOrderByAggregateInput = {
    price?: SortOrder
    originalPrice?: SortOrder
    maxQtyPerOrder?: SortOrder
    minQtyPerOrder?: SortOrder
    position?: SortOrder
  }

  export type TicketTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    showingId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isFree?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    maxQtyPerOrder?: SortOrder
    minQtyPerOrder?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    position?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrder
    isHidden?: SortOrder
  }

  export type TicketTypeMinOrderByAggregateInput = {
    id?: SortOrder
    showingId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isFree?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    maxQtyPerOrder?: SortOrder
    minQtyPerOrder?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    position?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrder
    isHidden?: SortOrder
  }

  export type TicketTypeSumOrderByAggregateInput = {
    price?: SortOrder
    originalPrice?: SortOrder
    maxQtyPerOrder?: SortOrder
    minQtyPerOrder?: SortOrder
    position?: SortOrder
  }

  export type EventsCreateNestedManyWithoutUsersInput = {
    create?: XOR<EventsCreateWithoutUsersInput, EventsUncheckedCreateWithoutUsersInput> | EventsCreateWithoutUsersInput[] | EventsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutUsersInput | EventsCreateOrConnectWithoutUsersInput[]
    createMany?: EventsCreateManyUsersInputEnvelope
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type UserProvinceCreateNestedManyWithoutUserInput = {
    create?: XOR<UserProvinceCreateWithoutUserInput, UserProvinceUncheckedCreateWithoutUserInput> | UserProvinceCreateWithoutUserInput[] | UserProvinceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProvinceCreateOrConnectWithoutUserInput | UserProvinceCreateOrConnectWithoutUserInput[]
    createMany?: UserProvinceCreateManyUserInputEnvelope
    connect?: UserProvinceWhereUniqueInput | UserProvinceWhereUniqueInput[]
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type EventsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<EventsCreateWithoutUsersInput, EventsUncheckedCreateWithoutUsersInput> | EventsCreateWithoutUsersInput[] | EventsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutUsersInput | EventsCreateOrConnectWithoutUsersInput[]
    createMany?: EventsCreateManyUsersInputEnvelope
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type UserProvinceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserProvinceCreateWithoutUserInput, UserProvinceUncheckedCreateWithoutUserInput> | UserProvinceCreateWithoutUserInput[] | UserProvinceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProvinceCreateOrConnectWithoutUserInput | UserProvinceCreateOrConnectWithoutUserInput[]
    createMany?: UserProvinceCreateManyUserInputEnvelope
    connect?: UserProvinceWhereUniqueInput | UserProvinceWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EventsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<EventsCreateWithoutUsersInput, EventsUncheckedCreateWithoutUsersInput> | EventsCreateWithoutUsersInput[] | EventsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutUsersInput | EventsCreateOrConnectWithoutUsersInput[]
    upsert?: EventsUpsertWithWhereUniqueWithoutUsersInput | EventsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: EventsCreateManyUsersInputEnvelope
    set?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    disconnect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    delete?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    update?: EventsUpdateWithWhereUniqueWithoutUsersInput | EventsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: EventsUpdateManyWithWhereWithoutUsersInput | EventsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: EventsScalarWhereInput | EventsScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type UserProvinceUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserProvinceCreateWithoutUserInput, UserProvinceUncheckedCreateWithoutUserInput> | UserProvinceCreateWithoutUserInput[] | UserProvinceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProvinceCreateOrConnectWithoutUserInput | UserProvinceCreateOrConnectWithoutUserInput[]
    upsert?: UserProvinceUpsertWithWhereUniqueWithoutUserInput | UserProvinceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserProvinceCreateManyUserInputEnvelope
    set?: UserProvinceWhereUniqueInput | UserProvinceWhereUniqueInput[]
    disconnect?: UserProvinceWhereUniqueInput | UserProvinceWhereUniqueInput[]
    delete?: UserProvinceWhereUniqueInput | UserProvinceWhereUniqueInput[]
    connect?: UserProvinceWhereUniqueInput | UserProvinceWhereUniqueInput[]
    update?: UserProvinceUpdateWithWhereUniqueWithoutUserInput | UserProvinceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserProvinceUpdateManyWithWhereWithoutUserInput | UserProvinceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserProvinceScalarWhereInput | UserProvinceScalarWhereInput[]
  }

  export type RoleUpdateOneWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    disconnect?: RoleWhereInput | boolean
    delete?: RoleWhereInput | boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EventsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<EventsCreateWithoutUsersInput, EventsUncheckedCreateWithoutUsersInput> | EventsCreateWithoutUsersInput[] | EventsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutUsersInput | EventsCreateOrConnectWithoutUsersInput[]
    upsert?: EventsUpsertWithWhereUniqueWithoutUsersInput | EventsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: EventsCreateManyUsersInputEnvelope
    set?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    disconnect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    delete?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    update?: EventsUpdateWithWhereUniqueWithoutUsersInput | EventsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: EventsUpdateManyWithWhereWithoutUsersInput | EventsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: EventsScalarWhereInput | EventsScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type UserProvinceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserProvinceCreateWithoutUserInput, UserProvinceUncheckedCreateWithoutUserInput> | UserProvinceCreateWithoutUserInput[] | UserProvinceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProvinceCreateOrConnectWithoutUserInput | UserProvinceCreateOrConnectWithoutUserInput[]
    upsert?: UserProvinceUpsertWithWhereUniqueWithoutUserInput | UserProvinceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserProvinceCreateManyUserInputEnvelope
    set?: UserProvinceWhereUniqueInput | UserProvinceWhereUniqueInput[]
    disconnect?: UserProvinceWhereUniqueInput | UserProvinceWhereUniqueInput[]
    delete?: UserProvinceWhereUniqueInput | UserProvinceWhereUniqueInput[]
    connect?: UserProvinceWhereUniqueInput | UserProvinceWhereUniqueInput[]
    update?: UserProvinceUpdateWithWhereUniqueWithoutUserInput | UserProvinceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserProvinceUpdateManyWithWhereWithoutUserInput | UserProvinceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserProvinceScalarWhereInput | UserProvinceScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type districtsCreateNestedManyWithoutProvinceInput = {
    create?: XOR<districtsCreateWithoutProvinceInput, districtsUncheckedCreateWithoutProvinceInput> | districtsCreateWithoutProvinceInput[] | districtsUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: districtsCreateOrConnectWithoutProvinceInput | districtsCreateOrConnectWithoutProvinceInput[]
    createMany?: districtsCreateManyProvinceInputEnvelope
    connect?: districtsWhereUniqueInput | districtsWhereUniqueInput[]
  }

  export type UserProvinceCreateNestedManyWithoutProvinceInput = {
    create?: XOR<UserProvinceCreateWithoutProvinceInput, UserProvinceUncheckedCreateWithoutProvinceInput> | UserProvinceCreateWithoutProvinceInput[] | UserProvinceUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: UserProvinceCreateOrConnectWithoutProvinceInput | UserProvinceCreateOrConnectWithoutProvinceInput[]
    createMany?: UserProvinceCreateManyProvinceInputEnvelope
    connect?: UserProvinceWhereUniqueInput | UserProvinceWhereUniqueInput[]
  }

  export type districtsUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<districtsCreateWithoutProvinceInput, districtsUncheckedCreateWithoutProvinceInput> | districtsCreateWithoutProvinceInput[] | districtsUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: districtsCreateOrConnectWithoutProvinceInput | districtsCreateOrConnectWithoutProvinceInput[]
    createMany?: districtsCreateManyProvinceInputEnvelope
    connect?: districtsWhereUniqueInput | districtsWhereUniqueInput[]
  }

  export type UserProvinceUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<UserProvinceCreateWithoutProvinceInput, UserProvinceUncheckedCreateWithoutProvinceInput> | UserProvinceCreateWithoutProvinceInput[] | UserProvinceUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: UserProvinceCreateOrConnectWithoutProvinceInput | UserProvinceCreateOrConnectWithoutProvinceInput[]
    createMany?: UserProvinceCreateManyProvinceInputEnvelope
    connect?: UserProvinceWhereUniqueInput | UserProvinceWhereUniqueInput[]
  }

  export type districtsUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<districtsCreateWithoutProvinceInput, districtsUncheckedCreateWithoutProvinceInput> | districtsCreateWithoutProvinceInput[] | districtsUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: districtsCreateOrConnectWithoutProvinceInput | districtsCreateOrConnectWithoutProvinceInput[]
    upsert?: districtsUpsertWithWhereUniqueWithoutProvinceInput | districtsUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: districtsCreateManyProvinceInputEnvelope
    set?: districtsWhereUniqueInput | districtsWhereUniqueInput[]
    disconnect?: districtsWhereUniqueInput | districtsWhereUniqueInput[]
    delete?: districtsWhereUniqueInput | districtsWhereUniqueInput[]
    connect?: districtsWhereUniqueInput | districtsWhereUniqueInput[]
    update?: districtsUpdateWithWhereUniqueWithoutProvinceInput | districtsUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: districtsUpdateManyWithWhereWithoutProvinceInput | districtsUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: districtsScalarWhereInput | districtsScalarWhereInput[]
  }

  export type UserProvinceUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<UserProvinceCreateWithoutProvinceInput, UserProvinceUncheckedCreateWithoutProvinceInput> | UserProvinceCreateWithoutProvinceInput[] | UserProvinceUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: UserProvinceCreateOrConnectWithoutProvinceInput | UserProvinceCreateOrConnectWithoutProvinceInput[]
    upsert?: UserProvinceUpsertWithWhereUniqueWithoutProvinceInput | UserProvinceUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: UserProvinceCreateManyProvinceInputEnvelope
    set?: UserProvinceWhereUniqueInput | UserProvinceWhereUniqueInput[]
    disconnect?: UserProvinceWhereUniqueInput | UserProvinceWhereUniqueInput[]
    delete?: UserProvinceWhereUniqueInput | UserProvinceWhereUniqueInput[]
    connect?: UserProvinceWhereUniqueInput | UserProvinceWhereUniqueInput[]
    update?: UserProvinceUpdateWithWhereUniqueWithoutProvinceInput | UserProvinceUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: UserProvinceUpdateManyWithWhereWithoutProvinceInput | UserProvinceUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: UserProvinceScalarWhereInput | UserProvinceScalarWhereInput[]
  }

  export type districtsUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<districtsCreateWithoutProvinceInput, districtsUncheckedCreateWithoutProvinceInput> | districtsCreateWithoutProvinceInput[] | districtsUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: districtsCreateOrConnectWithoutProvinceInput | districtsCreateOrConnectWithoutProvinceInput[]
    upsert?: districtsUpsertWithWhereUniqueWithoutProvinceInput | districtsUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: districtsCreateManyProvinceInputEnvelope
    set?: districtsWhereUniqueInput | districtsWhereUniqueInput[]
    disconnect?: districtsWhereUniqueInput | districtsWhereUniqueInput[]
    delete?: districtsWhereUniqueInput | districtsWhereUniqueInput[]
    connect?: districtsWhereUniqueInput | districtsWhereUniqueInput[]
    update?: districtsUpdateWithWhereUniqueWithoutProvinceInput | districtsUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: districtsUpdateManyWithWhereWithoutProvinceInput | districtsUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: districtsScalarWhereInput | districtsScalarWhereInput[]
  }

  export type UserProvinceUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<UserProvinceCreateWithoutProvinceInput, UserProvinceUncheckedCreateWithoutProvinceInput> | UserProvinceCreateWithoutProvinceInput[] | UserProvinceUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: UserProvinceCreateOrConnectWithoutProvinceInput | UserProvinceCreateOrConnectWithoutProvinceInput[]
    upsert?: UserProvinceUpsertWithWhereUniqueWithoutProvinceInput | UserProvinceUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: UserProvinceCreateManyProvinceInputEnvelope
    set?: UserProvinceWhereUniqueInput | UserProvinceWhereUniqueInput[]
    disconnect?: UserProvinceWhereUniqueInput | UserProvinceWhereUniqueInput[]
    delete?: UserProvinceWhereUniqueInput | UserProvinceWhereUniqueInput[]
    connect?: UserProvinceWhereUniqueInput | UserProvinceWhereUniqueInput[]
    update?: UserProvinceUpdateWithWhereUniqueWithoutProvinceInput | UserProvinceUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: UserProvinceUpdateManyWithWhereWithoutProvinceInput | UserProvinceUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: UserProvinceScalarWhereInput | UserProvinceScalarWhereInput[]
  }

  export type ProvinceCreateNestedOneWithoutUserProvinceInput = {
    create?: XOR<ProvinceCreateWithoutUserProvinceInput, ProvinceUncheckedCreateWithoutUserProvinceInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutUserProvinceInput
    connect?: ProvinceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserProvinceInput = {
    create?: XOR<UserCreateWithoutUserProvinceInput, UserUncheckedCreateWithoutUserProvinceInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProvinceInput
    connect?: UserWhereUniqueInput
  }

  export type ProvinceUpdateOneRequiredWithoutUserProvinceNestedInput = {
    create?: XOR<ProvinceCreateWithoutUserProvinceInput, ProvinceUncheckedCreateWithoutUserProvinceInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutUserProvinceInput
    upsert?: ProvinceUpsertWithoutUserProvinceInput
    connect?: ProvinceWhereUniqueInput
    update?: XOR<XOR<ProvinceUpdateToOneWithWhereWithoutUserProvinceInput, ProvinceUpdateWithoutUserProvinceInput>, ProvinceUncheckedUpdateWithoutUserProvinceInput>
  }

  export type UserUpdateOneRequiredWithoutUserProvinceNestedInput = {
    create?: XOR<UserCreateWithoutUserProvinceInput, UserUncheckedCreateWithoutUserProvinceInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProvinceInput
    upsert?: UserUpsertWithoutUserProvinceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserProvinceInput, UserUpdateWithoutUserProvinceInput>, UserUncheckedUpdateWithoutUserProvinceInput>
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type EnumOTPTypeFieldUpdateOperationsInput = {
    set?: $Enums.OTPType
  }

  export type EventCategoriesCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<EventCategoriesCreateWithoutCategoriesInput, EventCategoriesUncheckedCreateWithoutCategoriesInput> | EventCategoriesCreateWithoutCategoriesInput[] | EventCategoriesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: EventCategoriesCreateOrConnectWithoutCategoriesInput | EventCategoriesCreateOrConnectWithoutCategoriesInput[]
    createMany?: EventCategoriesCreateManyCategoriesInputEnvelope
    connect?: EventCategoriesWhereUniqueInput | EventCategoriesWhereUniqueInput[]
  }

  export type EventCategoriesUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<EventCategoriesCreateWithoutCategoriesInput, EventCategoriesUncheckedCreateWithoutCategoriesInput> | EventCategoriesCreateWithoutCategoriesInput[] | EventCategoriesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: EventCategoriesCreateOrConnectWithoutCategoriesInput | EventCategoriesCreateOrConnectWithoutCategoriesInput[]
    createMany?: EventCategoriesCreateManyCategoriesInputEnvelope
    connect?: EventCategoriesWhereUniqueInput | EventCategoriesWhereUniqueInput[]
  }

  export type EventCategoriesUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<EventCategoriesCreateWithoutCategoriesInput, EventCategoriesUncheckedCreateWithoutCategoriesInput> | EventCategoriesCreateWithoutCategoriesInput[] | EventCategoriesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: EventCategoriesCreateOrConnectWithoutCategoriesInput | EventCategoriesCreateOrConnectWithoutCategoriesInput[]
    upsert?: EventCategoriesUpsertWithWhereUniqueWithoutCategoriesInput | EventCategoriesUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: EventCategoriesCreateManyCategoriesInputEnvelope
    set?: EventCategoriesWhereUniqueInput | EventCategoriesWhereUniqueInput[]
    disconnect?: EventCategoriesWhereUniqueInput | EventCategoriesWhereUniqueInput[]
    delete?: EventCategoriesWhereUniqueInput | EventCategoriesWhereUniqueInput[]
    connect?: EventCategoriesWhereUniqueInput | EventCategoriesWhereUniqueInput[]
    update?: EventCategoriesUpdateWithWhereUniqueWithoutCategoriesInput | EventCategoriesUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: EventCategoriesUpdateManyWithWhereWithoutCategoriesInput | EventCategoriesUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: EventCategoriesScalarWhereInput | EventCategoriesScalarWhereInput[]
  }

  export type EventCategoriesUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<EventCategoriesCreateWithoutCategoriesInput, EventCategoriesUncheckedCreateWithoutCategoriesInput> | EventCategoriesCreateWithoutCategoriesInput[] | EventCategoriesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: EventCategoriesCreateOrConnectWithoutCategoriesInput | EventCategoriesCreateOrConnectWithoutCategoriesInput[]
    upsert?: EventCategoriesUpsertWithWhereUniqueWithoutCategoriesInput | EventCategoriesUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: EventCategoriesCreateManyCategoriesInputEnvelope
    set?: EventCategoriesWhereUniqueInput | EventCategoriesWhereUniqueInput[]
    disconnect?: EventCategoriesWhereUniqueInput | EventCategoriesWhereUniqueInput[]
    delete?: EventCategoriesWhereUniqueInput | EventCategoriesWhereUniqueInput[]
    connect?: EventCategoriesWhereUniqueInput | EventCategoriesWhereUniqueInput[]
    update?: EventCategoriesUpdateWithWhereUniqueWithoutCategoriesInput | EventCategoriesUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: EventCategoriesUpdateManyWithWhereWithoutCategoriesInput | EventCategoriesUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: EventCategoriesScalarWhereInput | EventCategoriesScalarWhereInput[]
  }

  export type CategoriesCreateNestedOneWithoutEventCategoriesInput = {
    create?: XOR<CategoriesCreateWithoutEventCategoriesInput, CategoriesUncheckedCreateWithoutEventCategoriesInput>
    connectOrCreate?: CategoriesCreateOrConnectWithoutEventCategoriesInput
    connect?: CategoriesWhereUniqueInput
  }

  export type EventsCreateNestedOneWithoutEventCategoriesInput = {
    create?: XOR<EventsCreateWithoutEventCategoriesInput, EventsUncheckedCreateWithoutEventCategoriesInput>
    connectOrCreate?: EventsCreateOrConnectWithoutEventCategoriesInput
    connect?: EventsWhereUniqueInput
  }

  export type CategoriesUpdateOneRequiredWithoutEventCategoriesNestedInput = {
    create?: XOR<CategoriesCreateWithoutEventCategoriesInput, CategoriesUncheckedCreateWithoutEventCategoriesInput>
    connectOrCreate?: CategoriesCreateOrConnectWithoutEventCategoriesInput
    upsert?: CategoriesUpsertWithoutEventCategoriesInput
    connect?: CategoriesWhereUniqueInput
    update?: XOR<XOR<CategoriesUpdateToOneWithWhereWithoutEventCategoriesInput, CategoriesUpdateWithoutEventCategoriesInput>, CategoriesUncheckedUpdateWithoutEventCategoriesInput>
  }

  export type EventsUpdateOneRequiredWithoutEventCategoriesNestedInput = {
    create?: XOR<EventsCreateWithoutEventCategoriesInput, EventsUncheckedCreateWithoutEventCategoriesInput>
    connectOrCreate?: EventsCreateOrConnectWithoutEventCategoriesInput
    upsert?: EventsUpsertWithoutEventCategoriesInput
    connect?: EventsWhereUniqueInput
    update?: XOR<XOR<EventsUpdateToOneWithWhereWithoutEventCategoriesInput, EventsUpdateWithoutEventCategoriesInput>, EventsUncheckedUpdateWithoutEventCategoriesInput>
  }

  export type EventCategoriesCreateNestedManyWithoutEventsInput = {
    create?: XOR<EventCategoriesCreateWithoutEventsInput, EventCategoriesUncheckedCreateWithoutEventsInput> | EventCategoriesCreateWithoutEventsInput[] | EventCategoriesUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: EventCategoriesCreateOrConnectWithoutEventsInput | EventCategoriesCreateOrConnectWithoutEventsInput[]
    createMany?: EventCategoriesCreateManyEventsInputEnvelope
    connect?: EventCategoriesWhereUniqueInput | EventCategoriesWhereUniqueInput[]
  }

  export type ImagesCreateNestedOneWithoutEvents_Events_imgLogoIdToImagesInput = {
    create?: XOR<ImagesCreateWithoutEvents_Events_imgLogoIdToImagesInput, ImagesUncheckedCreateWithoutEvents_Events_imgLogoIdToImagesInput>
    connectOrCreate?: ImagesCreateOrConnectWithoutEvents_Events_imgLogoIdToImagesInput
    connect?: ImagesWhereUniqueInput
  }

  export type ImagesCreateNestedOneWithoutEvents_Events_imgPosterIdToImagesInput = {
    create?: XOR<ImagesCreateWithoutEvents_Events_imgPosterIdToImagesInput, ImagesUncheckedCreateWithoutEvents_Events_imgPosterIdToImagesInput>
    connectOrCreate?: ImagesCreateOrConnectWithoutEvents_Events_imgPosterIdToImagesInput
    connect?: ImagesWhereUniqueInput
  }

  export type locationsCreateNestedOneWithoutEventsInput = {
    create?: XOR<locationsCreateWithoutEventsInput, locationsUncheckedCreateWithoutEventsInput>
    connectOrCreate?: locationsCreateOrConnectWithoutEventsInput
    connect?: locationsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEventsInput = {
    create?: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsInput
    connect?: UserWhereUniqueInput
  }

  export type ShowingCreateNestedManyWithoutEventsInput = {
    create?: XOR<ShowingCreateWithoutEventsInput, ShowingUncheckedCreateWithoutEventsInput> | ShowingCreateWithoutEventsInput[] | ShowingUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: ShowingCreateOrConnectWithoutEventsInput | ShowingCreateOrConnectWithoutEventsInput[]
    createMany?: ShowingCreateManyEventsInputEnvelope
    connect?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
  }

  export type EventCategoriesUncheckedCreateNestedManyWithoutEventsInput = {
    create?: XOR<EventCategoriesCreateWithoutEventsInput, EventCategoriesUncheckedCreateWithoutEventsInput> | EventCategoriesCreateWithoutEventsInput[] | EventCategoriesUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: EventCategoriesCreateOrConnectWithoutEventsInput | EventCategoriesCreateOrConnectWithoutEventsInput[]
    createMany?: EventCategoriesCreateManyEventsInputEnvelope
    connect?: EventCategoriesWhereUniqueInput | EventCategoriesWhereUniqueInput[]
  }

  export type ShowingUncheckedCreateNestedManyWithoutEventsInput = {
    create?: XOR<ShowingCreateWithoutEventsInput, ShowingUncheckedCreateWithoutEventsInput> | ShowingCreateWithoutEventsInput[] | ShowingUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: ShowingCreateOrConnectWithoutEventsInput | ShowingCreateOrConnectWithoutEventsInput[]
    createMany?: ShowingCreateManyEventsInputEnvelope
    connect?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EventCategoriesUpdateManyWithoutEventsNestedInput = {
    create?: XOR<EventCategoriesCreateWithoutEventsInput, EventCategoriesUncheckedCreateWithoutEventsInput> | EventCategoriesCreateWithoutEventsInput[] | EventCategoriesUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: EventCategoriesCreateOrConnectWithoutEventsInput | EventCategoriesCreateOrConnectWithoutEventsInput[]
    upsert?: EventCategoriesUpsertWithWhereUniqueWithoutEventsInput | EventCategoriesUpsertWithWhereUniqueWithoutEventsInput[]
    createMany?: EventCategoriesCreateManyEventsInputEnvelope
    set?: EventCategoriesWhereUniqueInput | EventCategoriesWhereUniqueInput[]
    disconnect?: EventCategoriesWhereUniqueInput | EventCategoriesWhereUniqueInput[]
    delete?: EventCategoriesWhereUniqueInput | EventCategoriesWhereUniqueInput[]
    connect?: EventCategoriesWhereUniqueInput | EventCategoriesWhereUniqueInput[]
    update?: EventCategoriesUpdateWithWhereUniqueWithoutEventsInput | EventCategoriesUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: EventCategoriesUpdateManyWithWhereWithoutEventsInput | EventCategoriesUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: EventCategoriesScalarWhereInput | EventCategoriesScalarWhereInput[]
  }

  export type ImagesUpdateOneWithoutEvents_Events_imgLogoIdToImagesNestedInput = {
    create?: XOR<ImagesCreateWithoutEvents_Events_imgLogoIdToImagesInput, ImagesUncheckedCreateWithoutEvents_Events_imgLogoIdToImagesInput>
    connectOrCreate?: ImagesCreateOrConnectWithoutEvents_Events_imgLogoIdToImagesInput
    upsert?: ImagesUpsertWithoutEvents_Events_imgLogoIdToImagesInput
    disconnect?: ImagesWhereInput | boolean
    delete?: ImagesWhereInput | boolean
    connect?: ImagesWhereUniqueInput
    update?: XOR<XOR<ImagesUpdateToOneWithWhereWithoutEvents_Events_imgLogoIdToImagesInput, ImagesUpdateWithoutEvents_Events_imgLogoIdToImagesInput>, ImagesUncheckedUpdateWithoutEvents_Events_imgLogoIdToImagesInput>
  }

  export type ImagesUpdateOneWithoutEvents_Events_imgPosterIdToImagesNestedInput = {
    create?: XOR<ImagesCreateWithoutEvents_Events_imgPosterIdToImagesInput, ImagesUncheckedCreateWithoutEvents_Events_imgPosterIdToImagesInput>
    connectOrCreate?: ImagesCreateOrConnectWithoutEvents_Events_imgPosterIdToImagesInput
    upsert?: ImagesUpsertWithoutEvents_Events_imgPosterIdToImagesInput
    disconnect?: ImagesWhereInput | boolean
    delete?: ImagesWhereInput | boolean
    connect?: ImagesWhereUniqueInput
    update?: XOR<XOR<ImagesUpdateToOneWithWhereWithoutEvents_Events_imgPosterIdToImagesInput, ImagesUpdateWithoutEvents_Events_imgPosterIdToImagesInput>, ImagesUncheckedUpdateWithoutEvents_Events_imgPosterIdToImagesInput>
  }

  export type locationsUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<locationsCreateWithoutEventsInput, locationsUncheckedCreateWithoutEventsInput>
    connectOrCreate?: locationsCreateOrConnectWithoutEventsInput
    upsert?: locationsUpsertWithoutEventsInput
    connect?: locationsWhereUniqueInput
    update?: XOR<XOR<locationsUpdateToOneWithWhereWithoutEventsInput, locationsUpdateWithoutEventsInput>, locationsUncheckedUpdateWithoutEventsInput>
  }

  export type UserUpdateOneWithoutEventsNestedInput = {
    create?: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsInput
    upsert?: UserUpsertWithoutEventsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventsInput, UserUpdateWithoutEventsInput>, UserUncheckedUpdateWithoutEventsInput>
  }

  export type ShowingUpdateManyWithoutEventsNestedInput = {
    create?: XOR<ShowingCreateWithoutEventsInput, ShowingUncheckedCreateWithoutEventsInput> | ShowingCreateWithoutEventsInput[] | ShowingUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: ShowingCreateOrConnectWithoutEventsInput | ShowingCreateOrConnectWithoutEventsInput[]
    upsert?: ShowingUpsertWithWhereUniqueWithoutEventsInput | ShowingUpsertWithWhereUniqueWithoutEventsInput[]
    createMany?: ShowingCreateManyEventsInputEnvelope
    set?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    disconnect?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    delete?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    connect?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    update?: ShowingUpdateWithWhereUniqueWithoutEventsInput | ShowingUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: ShowingUpdateManyWithWhereWithoutEventsInput | ShowingUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: ShowingScalarWhereInput | ShowingScalarWhereInput[]
  }

  export type EventCategoriesUncheckedUpdateManyWithoutEventsNestedInput = {
    create?: XOR<EventCategoriesCreateWithoutEventsInput, EventCategoriesUncheckedCreateWithoutEventsInput> | EventCategoriesCreateWithoutEventsInput[] | EventCategoriesUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: EventCategoriesCreateOrConnectWithoutEventsInput | EventCategoriesCreateOrConnectWithoutEventsInput[]
    upsert?: EventCategoriesUpsertWithWhereUniqueWithoutEventsInput | EventCategoriesUpsertWithWhereUniqueWithoutEventsInput[]
    createMany?: EventCategoriesCreateManyEventsInputEnvelope
    set?: EventCategoriesWhereUniqueInput | EventCategoriesWhereUniqueInput[]
    disconnect?: EventCategoriesWhereUniqueInput | EventCategoriesWhereUniqueInput[]
    delete?: EventCategoriesWhereUniqueInput | EventCategoriesWhereUniqueInput[]
    connect?: EventCategoriesWhereUniqueInput | EventCategoriesWhereUniqueInput[]
    update?: EventCategoriesUpdateWithWhereUniqueWithoutEventsInput | EventCategoriesUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: EventCategoriesUpdateManyWithWhereWithoutEventsInput | EventCategoriesUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: EventCategoriesScalarWhereInput | EventCategoriesScalarWhereInput[]
  }

  export type ShowingUncheckedUpdateManyWithoutEventsNestedInput = {
    create?: XOR<ShowingCreateWithoutEventsInput, ShowingUncheckedCreateWithoutEventsInput> | ShowingCreateWithoutEventsInput[] | ShowingUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: ShowingCreateOrConnectWithoutEventsInput | ShowingCreateOrConnectWithoutEventsInput[]
    upsert?: ShowingUpsertWithWhereUniqueWithoutEventsInput | ShowingUpsertWithWhereUniqueWithoutEventsInput[]
    createMany?: ShowingCreateManyEventsInputEnvelope
    set?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    disconnect?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    delete?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    connect?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    update?: ShowingUpdateWithWhereUniqueWithoutEventsInput | ShowingUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: ShowingUpdateManyWithWhereWithoutEventsInput | ShowingUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: ShowingScalarWhereInput | ShowingScalarWhereInput[]
  }

  export type EventsCreateNestedManyWithoutImages_Events_imgLogoIdToImagesInput = {
    create?: XOR<EventsCreateWithoutImages_Events_imgLogoIdToImagesInput, EventsUncheckedCreateWithoutImages_Events_imgLogoIdToImagesInput> | EventsCreateWithoutImages_Events_imgLogoIdToImagesInput[] | EventsUncheckedCreateWithoutImages_Events_imgLogoIdToImagesInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutImages_Events_imgLogoIdToImagesInput | EventsCreateOrConnectWithoutImages_Events_imgLogoIdToImagesInput[]
    createMany?: EventsCreateManyImages_Events_imgLogoIdToImagesInputEnvelope
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
  }

  export type EventsCreateNestedManyWithoutImages_Events_imgPosterIdToImagesInput = {
    create?: XOR<EventsCreateWithoutImages_Events_imgPosterIdToImagesInput, EventsUncheckedCreateWithoutImages_Events_imgPosterIdToImagesInput> | EventsCreateWithoutImages_Events_imgPosterIdToImagesInput[] | EventsUncheckedCreateWithoutImages_Events_imgPosterIdToImagesInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutImages_Events_imgPosterIdToImagesInput | EventsCreateOrConnectWithoutImages_Events_imgPosterIdToImagesInput[]
    createMany?: EventsCreateManyImages_Events_imgPosterIdToImagesInputEnvelope
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
  }

  export type EventsUncheckedCreateNestedManyWithoutImages_Events_imgLogoIdToImagesInput = {
    create?: XOR<EventsCreateWithoutImages_Events_imgLogoIdToImagesInput, EventsUncheckedCreateWithoutImages_Events_imgLogoIdToImagesInput> | EventsCreateWithoutImages_Events_imgLogoIdToImagesInput[] | EventsUncheckedCreateWithoutImages_Events_imgLogoIdToImagesInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutImages_Events_imgLogoIdToImagesInput | EventsCreateOrConnectWithoutImages_Events_imgLogoIdToImagesInput[]
    createMany?: EventsCreateManyImages_Events_imgLogoIdToImagesInputEnvelope
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
  }

  export type EventsUncheckedCreateNestedManyWithoutImages_Events_imgPosterIdToImagesInput = {
    create?: XOR<EventsCreateWithoutImages_Events_imgPosterIdToImagesInput, EventsUncheckedCreateWithoutImages_Events_imgPosterIdToImagesInput> | EventsCreateWithoutImages_Events_imgPosterIdToImagesInput[] | EventsUncheckedCreateWithoutImages_Events_imgPosterIdToImagesInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutImages_Events_imgPosterIdToImagesInput | EventsCreateOrConnectWithoutImages_Events_imgPosterIdToImagesInput[]
    createMany?: EventsCreateManyImages_Events_imgPosterIdToImagesInputEnvelope
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
  }

  export type EventsUpdateManyWithoutImages_Events_imgLogoIdToImagesNestedInput = {
    create?: XOR<EventsCreateWithoutImages_Events_imgLogoIdToImagesInput, EventsUncheckedCreateWithoutImages_Events_imgLogoIdToImagesInput> | EventsCreateWithoutImages_Events_imgLogoIdToImagesInput[] | EventsUncheckedCreateWithoutImages_Events_imgLogoIdToImagesInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutImages_Events_imgLogoIdToImagesInput | EventsCreateOrConnectWithoutImages_Events_imgLogoIdToImagesInput[]
    upsert?: EventsUpsertWithWhereUniqueWithoutImages_Events_imgLogoIdToImagesInput | EventsUpsertWithWhereUniqueWithoutImages_Events_imgLogoIdToImagesInput[]
    createMany?: EventsCreateManyImages_Events_imgLogoIdToImagesInputEnvelope
    set?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    disconnect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    delete?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    update?: EventsUpdateWithWhereUniqueWithoutImages_Events_imgLogoIdToImagesInput | EventsUpdateWithWhereUniqueWithoutImages_Events_imgLogoIdToImagesInput[]
    updateMany?: EventsUpdateManyWithWhereWithoutImages_Events_imgLogoIdToImagesInput | EventsUpdateManyWithWhereWithoutImages_Events_imgLogoIdToImagesInput[]
    deleteMany?: EventsScalarWhereInput | EventsScalarWhereInput[]
  }

  export type EventsUpdateManyWithoutImages_Events_imgPosterIdToImagesNestedInput = {
    create?: XOR<EventsCreateWithoutImages_Events_imgPosterIdToImagesInput, EventsUncheckedCreateWithoutImages_Events_imgPosterIdToImagesInput> | EventsCreateWithoutImages_Events_imgPosterIdToImagesInput[] | EventsUncheckedCreateWithoutImages_Events_imgPosterIdToImagesInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutImages_Events_imgPosterIdToImagesInput | EventsCreateOrConnectWithoutImages_Events_imgPosterIdToImagesInput[]
    upsert?: EventsUpsertWithWhereUniqueWithoutImages_Events_imgPosterIdToImagesInput | EventsUpsertWithWhereUniqueWithoutImages_Events_imgPosterIdToImagesInput[]
    createMany?: EventsCreateManyImages_Events_imgPosterIdToImagesInputEnvelope
    set?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    disconnect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    delete?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    update?: EventsUpdateWithWhereUniqueWithoutImages_Events_imgPosterIdToImagesInput | EventsUpdateWithWhereUniqueWithoutImages_Events_imgPosterIdToImagesInput[]
    updateMany?: EventsUpdateManyWithWhereWithoutImages_Events_imgPosterIdToImagesInput | EventsUpdateManyWithWhereWithoutImages_Events_imgPosterIdToImagesInput[]
    deleteMany?: EventsScalarWhereInput | EventsScalarWhereInput[]
  }

  export type EventsUncheckedUpdateManyWithoutImages_Events_imgLogoIdToImagesNestedInput = {
    create?: XOR<EventsCreateWithoutImages_Events_imgLogoIdToImagesInput, EventsUncheckedCreateWithoutImages_Events_imgLogoIdToImagesInput> | EventsCreateWithoutImages_Events_imgLogoIdToImagesInput[] | EventsUncheckedCreateWithoutImages_Events_imgLogoIdToImagesInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutImages_Events_imgLogoIdToImagesInput | EventsCreateOrConnectWithoutImages_Events_imgLogoIdToImagesInput[]
    upsert?: EventsUpsertWithWhereUniqueWithoutImages_Events_imgLogoIdToImagesInput | EventsUpsertWithWhereUniqueWithoutImages_Events_imgLogoIdToImagesInput[]
    createMany?: EventsCreateManyImages_Events_imgLogoIdToImagesInputEnvelope
    set?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    disconnect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    delete?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    update?: EventsUpdateWithWhereUniqueWithoutImages_Events_imgLogoIdToImagesInput | EventsUpdateWithWhereUniqueWithoutImages_Events_imgLogoIdToImagesInput[]
    updateMany?: EventsUpdateManyWithWhereWithoutImages_Events_imgLogoIdToImagesInput | EventsUpdateManyWithWhereWithoutImages_Events_imgLogoIdToImagesInput[]
    deleteMany?: EventsScalarWhereInput | EventsScalarWhereInput[]
  }

  export type EventsUncheckedUpdateManyWithoutImages_Events_imgPosterIdToImagesNestedInput = {
    create?: XOR<EventsCreateWithoutImages_Events_imgPosterIdToImagesInput, EventsUncheckedCreateWithoutImages_Events_imgPosterIdToImagesInput> | EventsCreateWithoutImages_Events_imgPosterIdToImagesInput[] | EventsUncheckedCreateWithoutImages_Events_imgPosterIdToImagesInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutImages_Events_imgPosterIdToImagesInput | EventsCreateOrConnectWithoutImages_Events_imgPosterIdToImagesInput[]
    upsert?: EventsUpsertWithWhereUniqueWithoutImages_Events_imgPosterIdToImagesInput | EventsUpsertWithWhereUniqueWithoutImages_Events_imgPosterIdToImagesInput[]
    createMany?: EventsCreateManyImages_Events_imgPosterIdToImagesInputEnvelope
    set?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    disconnect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    delete?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    update?: EventsUpdateWithWhereUniqueWithoutImages_Events_imgPosterIdToImagesInput | EventsUpdateWithWhereUniqueWithoutImages_Events_imgPosterIdToImagesInput[]
    updateMany?: EventsUpdateManyWithWhereWithoutImages_Events_imgPosterIdToImagesInput | EventsUpdateManyWithWhereWithoutImages_Events_imgPosterIdToImagesInput[]
    deleteMany?: EventsScalarWhereInput | EventsScalarWhereInput[]
  }

  export type ProvinceCreateNestedOneWithoutDistrictsInput = {
    create?: XOR<ProvinceCreateWithoutDistrictsInput, ProvinceUncheckedCreateWithoutDistrictsInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutDistrictsInput
    connect?: ProvinceWhereUniqueInput
  }

  export type locationsCreateNestedManyWithoutDistrictsInput = {
    create?: XOR<locationsCreateWithoutDistrictsInput, locationsUncheckedCreateWithoutDistrictsInput> | locationsCreateWithoutDistrictsInput[] | locationsUncheckedCreateWithoutDistrictsInput[]
    connectOrCreate?: locationsCreateOrConnectWithoutDistrictsInput | locationsCreateOrConnectWithoutDistrictsInput[]
    createMany?: locationsCreateManyDistrictsInputEnvelope
    connect?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
  }

  export type locationsUncheckedCreateNestedManyWithoutDistrictsInput = {
    create?: XOR<locationsCreateWithoutDistrictsInput, locationsUncheckedCreateWithoutDistrictsInput> | locationsCreateWithoutDistrictsInput[] | locationsUncheckedCreateWithoutDistrictsInput[]
    connectOrCreate?: locationsCreateOrConnectWithoutDistrictsInput | locationsCreateOrConnectWithoutDistrictsInput[]
    createMany?: locationsCreateManyDistrictsInputEnvelope
    connect?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
  }

  export type ProvinceUpdateOneRequiredWithoutDistrictsNestedInput = {
    create?: XOR<ProvinceCreateWithoutDistrictsInput, ProvinceUncheckedCreateWithoutDistrictsInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutDistrictsInput
    upsert?: ProvinceUpsertWithoutDistrictsInput
    connect?: ProvinceWhereUniqueInput
    update?: XOR<XOR<ProvinceUpdateToOneWithWhereWithoutDistrictsInput, ProvinceUpdateWithoutDistrictsInput>, ProvinceUncheckedUpdateWithoutDistrictsInput>
  }

  export type locationsUpdateManyWithoutDistrictsNestedInput = {
    create?: XOR<locationsCreateWithoutDistrictsInput, locationsUncheckedCreateWithoutDistrictsInput> | locationsCreateWithoutDistrictsInput[] | locationsUncheckedCreateWithoutDistrictsInput[]
    connectOrCreate?: locationsCreateOrConnectWithoutDistrictsInput | locationsCreateOrConnectWithoutDistrictsInput[]
    upsert?: locationsUpsertWithWhereUniqueWithoutDistrictsInput | locationsUpsertWithWhereUniqueWithoutDistrictsInput[]
    createMany?: locationsCreateManyDistrictsInputEnvelope
    set?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    disconnect?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    delete?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    connect?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    update?: locationsUpdateWithWhereUniqueWithoutDistrictsInput | locationsUpdateWithWhereUniqueWithoutDistrictsInput[]
    updateMany?: locationsUpdateManyWithWhereWithoutDistrictsInput | locationsUpdateManyWithWhereWithoutDistrictsInput[]
    deleteMany?: locationsScalarWhereInput | locationsScalarWhereInput[]
  }

  export type locationsUncheckedUpdateManyWithoutDistrictsNestedInput = {
    create?: XOR<locationsCreateWithoutDistrictsInput, locationsUncheckedCreateWithoutDistrictsInput> | locationsCreateWithoutDistrictsInput[] | locationsUncheckedCreateWithoutDistrictsInput[]
    connectOrCreate?: locationsCreateOrConnectWithoutDistrictsInput | locationsCreateOrConnectWithoutDistrictsInput[]
    upsert?: locationsUpsertWithWhereUniqueWithoutDistrictsInput | locationsUpsertWithWhereUniqueWithoutDistrictsInput[]
    createMany?: locationsCreateManyDistrictsInputEnvelope
    set?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    disconnect?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    delete?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    connect?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    update?: locationsUpdateWithWhereUniqueWithoutDistrictsInput | locationsUpdateWithWhereUniqueWithoutDistrictsInput[]
    updateMany?: locationsUpdateManyWithWhereWithoutDistrictsInput | locationsUpdateManyWithWhereWithoutDistrictsInput[]
    deleteMany?: locationsScalarWhereInput | locationsScalarWhereInput[]
  }

  export type EventsCreateNestedManyWithoutLocationsInput = {
    create?: XOR<EventsCreateWithoutLocationsInput, EventsUncheckedCreateWithoutLocationsInput> | EventsCreateWithoutLocationsInput[] | EventsUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutLocationsInput | EventsCreateOrConnectWithoutLocationsInput[]
    createMany?: EventsCreateManyLocationsInputEnvelope
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
  }

  export type districtsCreateNestedOneWithoutLocationsInput = {
    create?: XOR<districtsCreateWithoutLocationsInput, districtsUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: districtsCreateOrConnectWithoutLocationsInput
    connect?: districtsWhereUniqueInput
  }

  export type EventsUncheckedCreateNestedManyWithoutLocationsInput = {
    create?: XOR<EventsCreateWithoutLocationsInput, EventsUncheckedCreateWithoutLocationsInput> | EventsCreateWithoutLocationsInput[] | EventsUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutLocationsInput | EventsCreateOrConnectWithoutLocationsInput[]
    createMany?: EventsCreateManyLocationsInputEnvelope
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
  }

  export type EventsUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<EventsCreateWithoutLocationsInput, EventsUncheckedCreateWithoutLocationsInput> | EventsCreateWithoutLocationsInput[] | EventsUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutLocationsInput | EventsCreateOrConnectWithoutLocationsInput[]
    upsert?: EventsUpsertWithWhereUniqueWithoutLocationsInput | EventsUpsertWithWhereUniqueWithoutLocationsInput[]
    createMany?: EventsCreateManyLocationsInputEnvelope
    set?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    disconnect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    delete?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    update?: EventsUpdateWithWhereUniqueWithoutLocationsInput | EventsUpdateWithWhereUniqueWithoutLocationsInput[]
    updateMany?: EventsUpdateManyWithWhereWithoutLocationsInput | EventsUpdateManyWithWhereWithoutLocationsInput[]
    deleteMany?: EventsScalarWhereInput | EventsScalarWhereInput[]
  }

  export type districtsUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<districtsCreateWithoutLocationsInput, districtsUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: districtsCreateOrConnectWithoutLocationsInput
    upsert?: districtsUpsertWithoutLocationsInput
    connect?: districtsWhereUniqueInput
    update?: XOR<XOR<districtsUpdateToOneWithWhereWithoutLocationsInput, districtsUpdateWithoutLocationsInput>, districtsUncheckedUpdateWithoutLocationsInput>
  }

  export type EventsUncheckedUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<EventsCreateWithoutLocationsInput, EventsUncheckedCreateWithoutLocationsInput> | EventsCreateWithoutLocationsInput[] | EventsUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: EventsCreateOrConnectWithoutLocationsInput | EventsCreateOrConnectWithoutLocationsInput[]
    upsert?: EventsUpsertWithWhereUniqueWithoutLocationsInput | EventsUpsertWithWhereUniqueWithoutLocationsInput[]
    createMany?: EventsCreateManyLocationsInputEnvelope
    set?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    disconnect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    delete?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    connect?: EventsWhereUniqueInput | EventsWhereUniqueInput[]
    update?: EventsUpdateWithWhereUniqueWithoutLocationsInput | EventsUpdateWithWhereUniqueWithoutLocationsInput[]
    updateMany?: EventsUpdateManyWithWhereWithoutLocationsInput | EventsUpdateManyWithWhereWithoutLocationsInput[]
    deleteMany?: EventsScalarWhereInput | EventsScalarWhereInput[]
  }

  export type SectionCreateNestedOneWithoutRowInput = {
    create?: XOR<SectionCreateWithoutRowInput, SectionUncheckedCreateWithoutRowInput>
    connectOrCreate?: SectionCreateOrConnectWithoutRowInput
    connect?: SectionWhereUniqueInput
  }

  export type SeatCreateNestedManyWithoutRowInput = {
    create?: XOR<SeatCreateWithoutRowInput, SeatUncheckedCreateWithoutRowInput> | SeatCreateWithoutRowInput[] | SeatUncheckedCreateWithoutRowInput[]
    connectOrCreate?: SeatCreateOrConnectWithoutRowInput | SeatCreateOrConnectWithoutRowInput[]
    createMany?: SeatCreateManyRowInputEnvelope
    connect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
  }

  export type SeatUncheckedCreateNestedManyWithoutRowInput = {
    create?: XOR<SeatCreateWithoutRowInput, SeatUncheckedCreateWithoutRowInput> | SeatCreateWithoutRowInput[] | SeatUncheckedCreateWithoutRowInput[]
    connectOrCreate?: SeatCreateOrConnectWithoutRowInput | SeatCreateOrConnectWithoutRowInput[]
    createMany?: SeatCreateManyRowInputEnvelope
    connect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
  }

  export type SectionUpdateOneRequiredWithoutRowNestedInput = {
    create?: XOR<SectionCreateWithoutRowInput, SectionUncheckedCreateWithoutRowInput>
    connectOrCreate?: SectionCreateOrConnectWithoutRowInput
    upsert?: SectionUpsertWithoutRowInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutRowInput, SectionUpdateWithoutRowInput>, SectionUncheckedUpdateWithoutRowInput>
  }

  export type SeatUpdateManyWithoutRowNestedInput = {
    create?: XOR<SeatCreateWithoutRowInput, SeatUncheckedCreateWithoutRowInput> | SeatCreateWithoutRowInput[] | SeatUncheckedCreateWithoutRowInput[]
    connectOrCreate?: SeatCreateOrConnectWithoutRowInput | SeatCreateOrConnectWithoutRowInput[]
    upsert?: SeatUpsertWithWhereUniqueWithoutRowInput | SeatUpsertWithWhereUniqueWithoutRowInput[]
    createMany?: SeatCreateManyRowInputEnvelope
    set?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    disconnect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    delete?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    connect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    update?: SeatUpdateWithWhereUniqueWithoutRowInput | SeatUpdateWithWhereUniqueWithoutRowInput[]
    updateMany?: SeatUpdateManyWithWhereWithoutRowInput | SeatUpdateManyWithWhereWithoutRowInput[]
    deleteMany?: SeatScalarWhereInput | SeatScalarWhereInput[]
  }

  export type SeatUncheckedUpdateManyWithoutRowNestedInput = {
    create?: XOR<SeatCreateWithoutRowInput, SeatUncheckedCreateWithoutRowInput> | SeatCreateWithoutRowInput[] | SeatUncheckedCreateWithoutRowInput[]
    connectOrCreate?: SeatCreateOrConnectWithoutRowInput | SeatCreateOrConnectWithoutRowInput[]
    upsert?: SeatUpsertWithWhereUniqueWithoutRowInput | SeatUpsertWithWhereUniqueWithoutRowInput[]
    createMany?: SeatCreateManyRowInputEnvelope
    set?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    disconnect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    delete?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    connect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    update?: SeatUpdateWithWhereUniqueWithoutRowInput | SeatUpdateWithWhereUniqueWithoutRowInput[]
    updateMany?: SeatUpdateManyWithWhereWithoutRowInput | SeatUpdateManyWithWhereWithoutRowInput[]
    deleteMany?: SeatScalarWhereInput | SeatScalarWhereInput[]
  }

  export type RowCreateNestedOneWithoutSeatInput = {
    create?: XOR<RowCreateWithoutSeatInput, RowUncheckedCreateWithoutSeatInput>
    connectOrCreate?: RowCreateOrConnectWithoutSeatInput
    connect?: RowWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutSeatInput = {
    create?: XOR<TicketCreateWithoutSeatInput, TicketUncheckedCreateWithoutSeatInput> | TicketCreateWithoutSeatInput[] | TicketUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSeatInput | TicketCreateOrConnectWithoutSeatInput[]
    createMany?: TicketCreateManySeatInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutSeatInput = {
    create?: XOR<TicketCreateWithoutSeatInput, TicketUncheckedCreateWithoutSeatInput> | TicketCreateWithoutSeatInput[] | TicketUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSeatInput | TicketCreateOrConnectWithoutSeatInput[]
    createMany?: TicketCreateManySeatInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RowUpdateOneRequiredWithoutSeatNestedInput = {
    create?: XOR<RowCreateWithoutSeatInput, RowUncheckedCreateWithoutSeatInput>
    connectOrCreate?: RowCreateOrConnectWithoutSeatInput
    upsert?: RowUpsertWithoutSeatInput
    connect?: RowWhereUniqueInput
    update?: XOR<XOR<RowUpdateToOneWithWhereWithoutSeatInput, RowUpdateWithoutSeatInput>, RowUncheckedUpdateWithoutSeatInput>
  }

  export type TicketUpdateManyWithoutSeatNestedInput = {
    create?: XOR<TicketCreateWithoutSeatInput, TicketUncheckedCreateWithoutSeatInput> | TicketCreateWithoutSeatInput[] | TicketUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSeatInput | TicketCreateOrConnectWithoutSeatInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutSeatInput | TicketUpsertWithWhereUniqueWithoutSeatInput[]
    createMany?: TicketCreateManySeatInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutSeatInput | TicketUpdateWithWhereUniqueWithoutSeatInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutSeatInput | TicketUpdateManyWithWhereWithoutSeatInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutSeatNestedInput = {
    create?: XOR<TicketCreateWithoutSeatInput, TicketUncheckedCreateWithoutSeatInput> | TicketCreateWithoutSeatInput[] | TicketUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSeatInput | TicketCreateOrConnectWithoutSeatInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutSeatInput | TicketUpsertWithWhereUniqueWithoutSeatInput[]
    createMany?: TicketCreateManySeatInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutSeatInput | TicketUpdateWithWhereUniqueWithoutSeatInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutSeatInput | TicketUpdateManyWithWhereWithoutSeatInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type SectionCreateNestedManyWithoutSeatmapInput = {
    create?: XOR<SectionCreateWithoutSeatmapInput, SectionUncheckedCreateWithoutSeatmapInput> | SectionCreateWithoutSeatmapInput[] | SectionUncheckedCreateWithoutSeatmapInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutSeatmapInput | SectionCreateOrConnectWithoutSeatmapInput[]
    createMany?: SectionCreateManySeatmapInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type ShowingCreateNestedManyWithoutSeatmapInput = {
    create?: XOR<ShowingCreateWithoutSeatmapInput, ShowingUncheckedCreateWithoutSeatmapInput> | ShowingCreateWithoutSeatmapInput[] | ShowingUncheckedCreateWithoutSeatmapInput[]
    connectOrCreate?: ShowingCreateOrConnectWithoutSeatmapInput | ShowingCreateOrConnectWithoutSeatmapInput[]
    createMany?: ShowingCreateManySeatmapInputEnvelope
    connect?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
  }

  export type SectionUncheckedCreateNestedManyWithoutSeatmapInput = {
    create?: XOR<SectionCreateWithoutSeatmapInput, SectionUncheckedCreateWithoutSeatmapInput> | SectionCreateWithoutSeatmapInput[] | SectionUncheckedCreateWithoutSeatmapInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutSeatmapInput | SectionCreateOrConnectWithoutSeatmapInput[]
    createMany?: SectionCreateManySeatmapInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type ShowingUncheckedCreateNestedManyWithoutSeatmapInput = {
    create?: XOR<ShowingCreateWithoutSeatmapInput, ShowingUncheckedCreateWithoutSeatmapInput> | ShowingCreateWithoutSeatmapInput[] | ShowingUncheckedCreateWithoutSeatmapInput[]
    connectOrCreate?: ShowingCreateOrConnectWithoutSeatmapInput | ShowingCreateOrConnectWithoutSeatmapInput[]
    createMany?: ShowingCreateManySeatmapInputEnvelope
    connect?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
  }

  export type SectionUpdateManyWithoutSeatmapNestedInput = {
    create?: XOR<SectionCreateWithoutSeatmapInput, SectionUncheckedCreateWithoutSeatmapInput> | SectionCreateWithoutSeatmapInput[] | SectionUncheckedCreateWithoutSeatmapInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutSeatmapInput | SectionCreateOrConnectWithoutSeatmapInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutSeatmapInput | SectionUpsertWithWhereUniqueWithoutSeatmapInput[]
    createMany?: SectionCreateManySeatmapInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutSeatmapInput | SectionUpdateWithWhereUniqueWithoutSeatmapInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutSeatmapInput | SectionUpdateManyWithWhereWithoutSeatmapInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type ShowingUpdateManyWithoutSeatmapNestedInput = {
    create?: XOR<ShowingCreateWithoutSeatmapInput, ShowingUncheckedCreateWithoutSeatmapInput> | ShowingCreateWithoutSeatmapInput[] | ShowingUncheckedCreateWithoutSeatmapInput[]
    connectOrCreate?: ShowingCreateOrConnectWithoutSeatmapInput | ShowingCreateOrConnectWithoutSeatmapInput[]
    upsert?: ShowingUpsertWithWhereUniqueWithoutSeatmapInput | ShowingUpsertWithWhereUniqueWithoutSeatmapInput[]
    createMany?: ShowingCreateManySeatmapInputEnvelope
    set?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    disconnect?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    delete?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    connect?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    update?: ShowingUpdateWithWhereUniqueWithoutSeatmapInput | ShowingUpdateWithWhereUniqueWithoutSeatmapInput[]
    updateMany?: ShowingUpdateManyWithWhereWithoutSeatmapInput | ShowingUpdateManyWithWhereWithoutSeatmapInput[]
    deleteMany?: ShowingScalarWhereInput | ShowingScalarWhereInput[]
  }

  export type SectionUncheckedUpdateManyWithoutSeatmapNestedInput = {
    create?: XOR<SectionCreateWithoutSeatmapInput, SectionUncheckedCreateWithoutSeatmapInput> | SectionCreateWithoutSeatmapInput[] | SectionUncheckedCreateWithoutSeatmapInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutSeatmapInput | SectionCreateOrConnectWithoutSeatmapInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutSeatmapInput | SectionUpsertWithWhereUniqueWithoutSeatmapInput[]
    createMany?: SectionCreateManySeatmapInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutSeatmapInput | SectionUpdateWithWhereUniqueWithoutSeatmapInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutSeatmapInput | SectionUpdateManyWithWhereWithoutSeatmapInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type ShowingUncheckedUpdateManyWithoutSeatmapNestedInput = {
    create?: XOR<ShowingCreateWithoutSeatmapInput, ShowingUncheckedCreateWithoutSeatmapInput> | ShowingCreateWithoutSeatmapInput[] | ShowingUncheckedCreateWithoutSeatmapInput[]
    connectOrCreate?: ShowingCreateOrConnectWithoutSeatmapInput | ShowingCreateOrConnectWithoutSeatmapInput[]
    upsert?: ShowingUpsertWithWhereUniqueWithoutSeatmapInput | ShowingUpsertWithWhereUniqueWithoutSeatmapInput[]
    createMany?: ShowingCreateManySeatmapInputEnvelope
    set?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    disconnect?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    delete?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    connect?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    update?: ShowingUpdateWithWhereUniqueWithoutSeatmapInput | ShowingUpdateWithWhereUniqueWithoutSeatmapInput[]
    updateMany?: ShowingUpdateManyWithWhereWithoutSeatmapInput | ShowingUpdateManyWithWhereWithoutSeatmapInput[]
    deleteMany?: ShowingScalarWhereInput | ShowingScalarWhereInput[]
  }

  export type RowCreateNestedManyWithoutSectionInput = {
    create?: XOR<RowCreateWithoutSectionInput, RowUncheckedCreateWithoutSectionInput> | RowCreateWithoutSectionInput[] | RowUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: RowCreateOrConnectWithoutSectionInput | RowCreateOrConnectWithoutSectionInput[]
    createMany?: RowCreateManySectionInputEnvelope
    connect?: RowWhereUniqueInput | RowWhereUniqueInput[]
  }

  export type SeatmapCreateNestedOneWithoutSectionInput = {
    create?: XOR<SeatmapCreateWithoutSectionInput, SeatmapUncheckedCreateWithoutSectionInput>
    connectOrCreate?: SeatmapCreateOrConnectWithoutSectionInput
    connect?: SeatmapWhereUniqueInput
  }

  export type RowUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<RowCreateWithoutSectionInput, RowUncheckedCreateWithoutSectionInput> | RowCreateWithoutSectionInput[] | RowUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: RowCreateOrConnectWithoutSectionInput | RowCreateOrConnectWithoutSectionInput[]
    createMany?: RowCreateManySectionInputEnvelope
    connect?: RowWhereUniqueInput | RowWhereUniqueInput[]
  }

  export type RowUpdateManyWithoutSectionNestedInput = {
    create?: XOR<RowCreateWithoutSectionInput, RowUncheckedCreateWithoutSectionInput> | RowCreateWithoutSectionInput[] | RowUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: RowCreateOrConnectWithoutSectionInput | RowCreateOrConnectWithoutSectionInput[]
    upsert?: RowUpsertWithWhereUniqueWithoutSectionInput | RowUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: RowCreateManySectionInputEnvelope
    set?: RowWhereUniqueInput | RowWhereUniqueInput[]
    disconnect?: RowWhereUniqueInput | RowWhereUniqueInput[]
    delete?: RowWhereUniqueInput | RowWhereUniqueInput[]
    connect?: RowWhereUniqueInput | RowWhereUniqueInput[]
    update?: RowUpdateWithWhereUniqueWithoutSectionInput | RowUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: RowUpdateManyWithWhereWithoutSectionInput | RowUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: RowScalarWhereInput | RowScalarWhereInput[]
  }

  export type SeatmapUpdateOneRequiredWithoutSectionNestedInput = {
    create?: XOR<SeatmapCreateWithoutSectionInput, SeatmapUncheckedCreateWithoutSectionInput>
    connectOrCreate?: SeatmapCreateOrConnectWithoutSectionInput
    upsert?: SeatmapUpsertWithoutSectionInput
    connect?: SeatmapWhereUniqueInput
    update?: XOR<XOR<SeatmapUpdateToOneWithWhereWithoutSectionInput, SeatmapUpdateWithoutSectionInput>, SeatmapUncheckedUpdateWithoutSectionInput>
  }

  export type RowUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<RowCreateWithoutSectionInput, RowUncheckedCreateWithoutSectionInput> | RowCreateWithoutSectionInput[] | RowUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: RowCreateOrConnectWithoutSectionInput | RowCreateOrConnectWithoutSectionInput[]
    upsert?: RowUpsertWithWhereUniqueWithoutSectionInput | RowUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: RowCreateManySectionInputEnvelope
    set?: RowWhereUniqueInput | RowWhereUniqueInput[]
    disconnect?: RowWhereUniqueInput | RowWhereUniqueInput[]
    delete?: RowWhereUniqueInput | RowWhereUniqueInput[]
    connect?: RowWhereUniqueInput | RowWhereUniqueInput[]
    update?: RowUpdateWithWhereUniqueWithoutSectionInput | RowUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: RowUpdateManyWithWhereWithoutSectionInput | RowUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: RowScalarWhereInput | RowScalarWhereInput[]
  }

  export type EventsCreateNestedOneWithoutShowingInput = {
    create?: XOR<EventsCreateWithoutShowingInput, EventsUncheckedCreateWithoutShowingInput>
    connectOrCreate?: EventsCreateOrConnectWithoutShowingInput
    connect?: EventsWhereUniqueInput
  }

  export type SeatmapCreateNestedOneWithoutShowingInput = {
    create?: XOR<SeatmapCreateWithoutShowingInput, SeatmapUncheckedCreateWithoutShowingInput>
    connectOrCreate?: SeatmapCreateOrConnectWithoutShowingInput
    connect?: SeatmapWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutShowingInput = {
    create?: XOR<TicketCreateWithoutShowingInput, TicketUncheckedCreateWithoutShowingInput> | TicketCreateWithoutShowingInput[] | TicketUncheckedCreateWithoutShowingInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutShowingInput | TicketCreateOrConnectWithoutShowingInput[]
    createMany?: TicketCreateManyShowingInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketTypeCreateNestedManyWithoutShowingInput = {
    create?: XOR<TicketTypeCreateWithoutShowingInput, TicketTypeUncheckedCreateWithoutShowingInput> | TicketTypeCreateWithoutShowingInput[] | TicketTypeUncheckedCreateWithoutShowingInput[]
    connectOrCreate?: TicketTypeCreateOrConnectWithoutShowingInput | TicketTypeCreateOrConnectWithoutShowingInput[]
    createMany?: TicketTypeCreateManyShowingInputEnvelope
    connect?: TicketTypeWhereUniqueInput | TicketTypeWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutShowingInput = {
    create?: XOR<TicketCreateWithoutShowingInput, TicketUncheckedCreateWithoutShowingInput> | TicketCreateWithoutShowingInput[] | TicketUncheckedCreateWithoutShowingInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutShowingInput | TicketCreateOrConnectWithoutShowingInput[]
    createMany?: TicketCreateManyShowingInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketTypeUncheckedCreateNestedManyWithoutShowingInput = {
    create?: XOR<TicketTypeCreateWithoutShowingInput, TicketTypeUncheckedCreateWithoutShowingInput> | TicketTypeCreateWithoutShowingInput[] | TicketTypeUncheckedCreateWithoutShowingInput[]
    connectOrCreate?: TicketTypeCreateOrConnectWithoutShowingInput | TicketTypeCreateOrConnectWithoutShowingInput[]
    createMany?: TicketTypeCreateManyShowingInputEnvelope
    connect?: TicketTypeWhereUniqueInput | TicketTypeWhereUniqueInput[]
  }

  export type EventsUpdateOneRequiredWithoutShowingNestedInput = {
    create?: XOR<EventsCreateWithoutShowingInput, EventsUncheckedCreateWithoutShowingInput>
    connectOrCreate?: EventsCreateOrConnectWithoutShowingInput
    upsert?: EventsUpsertWithoutShowingInput
    connect?: EventsWhereUniqueInput
    update?: XOR<XOR<EventsUpdateToOneWithWhereWithoutShowingInput, EventsUpdateWithoutShowingInput>, EventsUncheckedUpdateWithoutShowingInput>
  }

  export type SeatmapUpdateOneRequiredWithoutShowingNestedInput = {
    create?: XOR<SeatmapCreateWithoutShowingInput, SeatmapUncheckedCreateWithoutShowingInput>
    connectOrCreate?: SeatmapCreateOrConnectWithoutShowingInput
    upsert?: SeatmapUpsertWithoutShowingInput
    connect?: SeatmapWhereUniqueInput
    update?: XOR<XOR<SeatmapUpdateToOneWithWhereWithoutShowingInput, SeatmapUpdateWithoutShowingInput>, SeatmapUncheckedUpdateWithoutShowingInput>
  }

  export type TicketUpdateManyWithoutShowingNestedInput = {
    create?: XOR<TicketCreateWithoutShowingInput, TicketUncheckedCreateWithoutShowingInput> | TicketCreateWithoutShowingInput[] | TicketUncheckedCreateWithoutShowingInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutShowingInput | TicketCreateOrConnectWithoutShowingInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutShowingInput | TicketUpsertWithWhereUniqueWithoutShowingInput[]
    createMany?: TicketCreateManyShowingInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutShowingInput | TicketUpdateWithWhereUniqueWithoutShowingInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutShowingInput | TicketUpdateManyWithWhereWithoutShowingInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketTypeUpdateManyWithoutShowingNestedInput = {
    create?: XOR<TicketTypeCreateWithoutShowingInput, TicketTypeUncheckedCreateWithoutShowingInput> | TicketTypeCreateWithoutShowingInput[] | TicketTypeUncheckedCreateWithoutShowingInput[]
    connectOrCreate?: TicketTypeCreateOrConnectWithoutShowingInput | TicketTypeCreateOrConnectWithoutShowingInput[]
    upsert?: TicketTypeUpsertWithWhereUniqueWithoutShowingInput | TicketTypeUpsertWithWhereUniqueWithoutShowingInput[]
    createMany?: TicketTypeCreateManyShowingInputEnvelope
    set?: TicketTypeWhereUniqueInput | TicketTypeWhereUniqueInput[]
    disconnect?: TicketTypeWhereUniqueInput | TicketTypeWhereUniqueInput[]
    delete?: TicketTypeWhereUniqueInput | TicketTypeWhereUniqueInput[]
    connect?: TicketTypeWhereUniqueInput | TicketTypeWhereUniqueInput[]
    update?: TicketTypeUpdateWithWhereUniqueWithoutShowingInput | TicketTypeUpdateWithWhereUniqueWithoutShowingInput[]
    updateMany?: TicketTypeUpdateManyWithWhereWithoutShowingInput | TicketTypeUpdateManyWithWhereWithoutShowingInput[]
    deleteMany?: TicketTypeScalarWhereInput | TicketTypeScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutShowingNestedInput = {
    create?: XOR<TicketCreateWithoutShowingInput, TicketUncheckedCreateWithoutShowingInput> | TicketCreateWithoutShowingInput[] | TicketUncheckedCreateWithoutShowingInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutShowingInput | TicketCreateOrConnectWithoutShowingInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutShowingInput | TicketUpsertWithWhereUniqueWithoutShowingInput[]
    createMany?: TicketCreateManyShowingInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutShowingInput | TicketUpdateWithWhereUniqueWithoutShowingInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutShowingInput | TicketUpdateManyWithWhereWithoutShowingInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketTypeUncheckedUpdateManyWithoutShowingNestedInput = {
    create?: XOR<TicketTypeCreateWithoutShowingInput, TicketTypeUncheckedCreateWithoutShowingInput> | TicketTypeCreateWithoutShowingInput[] | TicketTypeUncheckedCreateWithoutShowingInput[]
    connectOrCreate?: TicketTypeCreateOrConnectWithoutShowingInput | TicketTypeCreateOrConnectWithoutShowingInput[]
    upsert?: TicketTypeUpsertWithWhereUniqueWithoutShowingInput | TicketTypeUpsertWithWhereUniqueWithoutShowingInput[]
    createMany?: TicketTypeCreateManyShowingInputEnvelope
    set?: TicketTypeWhereUniqueInput | TicketTypeWhereUniqueInput[]
    disconnect?: TicketTypeWhereUniqueInput | TicketTypeWhereUniqueInput[]
    delete?: TicketTypeWhereUniqueInput | TicketTypeWhereUniqueInput[]
    connect?: TicketTypeWhereUniqueInput | TicketTypeWhereUniqueInput[]
    update?: TicketTypeUpdateWithWhereUniqueWithoutShowingInput | TicketTypeUpdateWithWhereUniqueWithoutShowingInput[]
    updateMany?: TicketTypeUpdateManyWithWhereWithoutShowingInput | TicketTypeUpdateManyWithWhereWithoutShowingInput[]
    deleteMany?: TicketTypeScalarWhereInput | TicketTypeScalarWhereInput[]
  }

  export type SeatCreateNestedOneWithoutTicketInput = {
    create?: XOR<SeatCreateWithoutTicketInput, SeatUncheckedCreateWithoutTicketInput>
    connectOrCreate?: SeatCreateOrConnectWithoutTicketInput
    connect?: SeatWhereUniqueInput
  }

  export type ShowingCreateNestedOneWithoutTicketInput = {
    create?: XOR<ShowingCreateWithoutTicketInput, ShowingUncheckedCreateWithoutTicketInput>
    connectOrCreate?: ShowingCreateOrConnectWithoutTicketInput
    connect?: ShowingWhereUniqueInput
  }

  export type TicketTypeCreateNestedOneWithoutTicketInput = {
    create?: XOR<TicketTypeCreateWithoutTicketInput, TicketTypeUncheckedCreateWithoutTicketInput>
    connectOrCreate?: TicketTypeCreateOrConnectWithoutTicketInput
    connect?: TicketTypeWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type SeatUpdateOneRequiredWithoutTicketNestedInput = {
    create?: XOR<SeatCreateWithoutTicketInput, SeatUncheckedCreateWithoutTicketInput>
    connectOrCreate?: SeatCreateOrConnectWithoutTicketInput
    upsert?: SeatUpsertWithoutTicketInput
    connect?: SeatWhereUniqueInput
    update?: XOR<XOR<SeatUpdateToOneWithWhereWithoutTicketInput, SeatUpdateWithoutTicketInput>, SeatUncheckedUpdateWithoutTicketInput>
  }

  export type ShowingUpdateOneRequiredWithoutTicketNestedInput = {
    create?: XOR<ShowingCreateWithoutTicketInput, ShowingUncheckedCreateWithoutTicketInput>
    connectOrCreate?: ShowingCreateOrConnectWithoutTicketInput
    upsert?: ShowingUpsertWithoutTicketInput
    connect?: ShowingWhereUniqueInput
    update?: XOR<XOR<ShowingUpdateToOneWithWhereWithoutTicketInput, ShowingUpdateWithoutTicketInput>, ShowingUncheckedUpdateWithoutTicketInput>
  }

  export type TicketTypeUpdateOneRequiredWithoutTicketNestedInput = {
    create?: XOR<TicketTypeCreateWithoutTicketInput, TicketTypeUncheckedCreateWithoutTicketInput>
    connectOrCreate?: TicketTypeCreateOrConnectWithoutTicketInput
    upsert?: TicketTypeUpsertWithoutTicketInput
    connect?: TicketTypeWhereUniqueInput
    update?: XOR<XOR<TicketTypeUpdateToOneWithWhereWithoutTicketInput, TicketTypeUpdateWithoutTicketInput>, TicketTypeUncheckedUpdateWithoutTicketInput>
  }

  export type TicketCreateNestedManyWithoutTicketTypeInput = {
    create?: XOR<TicketCreateWithoutTicketTypeInput, TicketUncheckedCreateWithoutTicketTypeInput> | TicketCreateWithoutTicketTypeInput[] | TicketUncheckedCreateWithoutTicketTypeInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTicketTypeInput | TicketCreateOrConnectWithoutTicketTypeInput[]
    createMany?: TicketCreateManyTicketTypeInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type ShowingCreateNestedOneWithoutTicketTypeInput = {
    create?: XOR<ShowingCreateWithoutTicketTypeInput, ShowingUncheckedCreateWithoutTicketTypeInput>
    connectOrCreate?: ShowingCreateOrConnectWithoutTicketTypeInput
    connect?: ShowingWhereUniqueInput
  }

  export type TicketUncheckedCreateNestedManyWithoutTicketTypeInput = {
    create?: XOR<TicketCreateWithoutTicketTypeInput, TicketUncheckedCreateWithoutTicketTypeInput> | TicketCreateWithoutTicketTypeInput[] | TicketUncheckedCreateWithoutTicketTypeInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTicketTypeInput | TicketCreateOrConnectWithoutTicketTypeInput[]
    createMany?: TicketCreateManyTicketTypeInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUpdateManyWithoutTicketTypeNestedInput = {
    create?: XOR<TicketCreateWithoutTicketTypeInput, TicketUncheckedCreateWithoutTicketTypeInput> | TicketCreateWithoutTicketTypeInput[] | TicketUncheckedCreateWithoutTicketTypeInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTicketTypeInput | TicketCreateOrConnectWithoutTicketTypeInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutTicketTypeInput | TicketUpsertWithWhereUniqueWithoutTicketTypeInput[]
    createMany?: TicketCreateManyTicketTypeInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutTicketTypeInput | TicketUpdateWithWhereUniqueWithoutTicketTypeInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutTicketTypeInput | TicketUpdateManyWithWhereWithoutTicketTypeInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type ShowingUpdateOneRequiredWithoutTicketTypeNestedInput = {
    create?: XOR<ShowingCreateWithoutTicketTypeInput, ShowingUncheckedCreateWithoutTicketTypeInput>
    connectOrCreate?: ShowingCreateOrConnectWithoutTicketTypeInput
    upsert?: ShowingUpsertWithoutTicketTypeInput
    connect?: ShowingWhereUniqueInput
    update?: XOR<XOR<ShowingUpdateToOneWithWhereWithoutTicketTypeInput, ShowingUpdateWithoutTicketTypeInput>, ShowingUncheckedUpdateWithoutTicketTypeInput>
  }

  export type TicketUncheckedUpdateManyWithoutTicketTypeNestedInput = {
    create?: XOR<TicketCreateWithoutTicketTypeInput, TicketUncheckedCreateWithoutTicketTypeInput> | TicketCreateWithoutTicketTypeInput[] | TicketUncheckedCreateWithoutTicketTypeInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTicketTypeInput | TicketCreateOrConnectWithoutTicketTypeInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutTicketTypeInput | TicketUpsertWithWhereUniqueWithoutTicketTypeInput[]
    createMany?: TicketCreateManyTicketTypeInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutTicketTypeInput | TicketUpdateWithWhereUniqueWithoutTicketTypeInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutTicketTypeInput | TicketUpdateManyWithWhereWithoutTicketTypeInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumOTPTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OTPType | EnumOTPTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OTPType[] | ListEnumOTPTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OTPType[] | ListEnumOTPTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOTPTypeFilter<$PrismaModel> | $Enums.OTPType
  }

  export type NestedEnumOTPTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OTPType | EnumOTPTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OTPType[] | ListEnumOTPTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OTPType[] | ListEnumOTPTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOTPTypeWithAggregatesFilter<$PrismaModel> | $Enums.OTPType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOTPTypeFilter<$PrismaModel>
    _max?: NestedEnumOTPTypeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EventsCreateWithoutUsersInput = {
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status: string
    venue?: string | null
    createdAt?: Date | string
    minTicketPrice?: number
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore: Decimal | DecimalJsLike | number | string
    totalClicks?: number
    weekClicks?: number
    EventCategories?: EventCategoriesCreateNestedManyWithoutEventsInput
    Images_Events_imgLogoIdToImages?: ImagesCreateNestedOneWithoutEvents_Events_imgLogoIdToImagesInput
    Images_Events_imgPosterIdToImages?: ImagesCreateNestedOneWithoutEvents_Events_imgPosterIdToImagesInput
    locations: locationsCreateNestedOneWithoutEventsInput
    Showing?: ShowingCreateNestedManyWithoutEventsInput
  }

  export type EventsUncheckedCreateWithoutUsersInput = {
    id?: number
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status: string
    locationId: number
    venue?: string | null
    imgLogoId?: number | null
    imgPosterId?: number | null
    createdAt?: Date | string
    minTicketPrice?: number
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore: Decimal | DecimalJsLike | number | string
    totalClicks?: number
    weekClicks?: number
    EventCategories?: EventCategoriesUncheckedCreateNestedManyWithoutEventsInput
    Showing?: ShowingUncheckedCreateNestedManyWithoutEventsInput
  }

  export type EventsCreateOrConnectWithoutUsersInput = {
    where: EventsWhereUniqueInput
    create: XOR<EventsCreateWithoutUsersInput, EventsUncheckedCreateWithoutUsersInput>
  }

  export type EventsCreateManyUsersInputEnvelope = {
    data: EventsCreateManyUsersInput | EventsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    token: string
    revoked?: boolean
    expiresAt: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    revoked?: boolean
    expiresAt: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserProvinceCreateWithoutUserInput = {
    province: ProvinceCreateNestedOneWithoutUserProvinceInput
  }

  export type UserProvinceUncheckedCreateWithoutUserInput = {
    provinceId: number
  }

  export type UserProvinceCreateOrConnectWithoutUserInput = {
    where: UserProvinceWhereUniqueInput
    create: XOR<UserProvinceCreateWithoutUserInput, UserProvinceUncheckedCreateWithoutUserInput>
  }

  export type UserProvinceCreateManyUserInputEnvelope = {
    data: UserProvinceCreateManyUserInput | UserProvinceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoleCreateWithoutUsersInput = {
    id: number
    role_name: string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id: number
    role_name: string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type EventsUpsertWithWhereUniqueWithoutUsersInput = {
    where: EventsWhereUniqueInput
    update: XOR<EventsUpdateWithoutUsersInput, EventsUncheckedUpdateWithoutUsersInput>
    create: XOR<EventsCreateWithoutUsersInput, EventsUncheckedCreateWithoutUsersInput>
  }

  export type EventsUpdateWithWhereUniqueWithoutUsersInput = {
    where: EventsWhereUniqueInput
    data: XOR<EventsUpdateWithoutUsersInput, EventsUncheckedUpdateWithoutUsersInput>
  }

  export type EventsUpdateManyWithWhereWithoutUsersInput = {
    where: EventsScalarWhereInput
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyWithoutUsersInput>
  }

  export type EventsScalarWhereInput = {
    AND?: EventsScalarWhereInput | EventsScalarWhereInput[]
    OR?: EventsScalarWhereInput[]
    NOT?: EventsScalarWhereInput | EventsScalarWhereInput[]
    id?: IntFilter<"Events"> | number
    title?: StringFilter<"Events"> | string
    description?: StringNullableFilter<"Events"> | string | null
    startDate?: DateTimeFilter<"Events"> | Date | string
    endDate?: DateTimeFilter<"Events"> | Date | string
    organizerId?: StringNullableFilter<"Events"> | string | null
    status?: StringFilter<"Events"> | string
    locationId?: IntFilter<"Events"> | number
    venue?: StringNullableFilter<"Events"> | string | null
    imgLogoId?: IntNullableFilter<"Events"> | number | null
    imgPosterId?: IntNullableFilter<"Events"> | number | null
    createdAt?: DateTimeFilter<"Events"> | Date | string
    minTicketPrice?: IntFilter<"Events"> | number
    isOnlyOnEve?: BoolFilter<"Events"> | boolean
    isSpecial?: BoolFilter<"Events"> | boolean
    lastScore?: DecimalFilter<"Events"> | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFilter<"Events"> | number
    weekClicks?: IntFilter<"Events"> | number
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: IntFilter<"RefreshToken"> | number
    token?: StringFilter<"RefreshToken"> | string
    email?: StringFilter<"RefreshToken"> | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type UserProvinceUpsertWithWhereUniqueWithoutUserInput = {
    where: UserProvinceWhereUniqueInput
    update: XOR<UserProvinceUpdateWithoutUserInput, UserProvinceUncheckedUpdateWithoutUserInput>
    create: XOR<UserProvinceCreateWithoutUserInput, UserProvinceUncheckedCreateWithoutUserInput>
  }

  export type UserProvinceUpdateWithWhereUniqueWithoutUserInput = {
    where: UserProvinceWhereUniqueInput
    data: XOR<UserProvinceUpdateWithoutUserInput, UserProvinceUncheckedUpdateWithoutUserInput>
  }

  export type UserProvinceUpdateManyWithWhereWithoutUserInput = {
    where: UserProvinceScalarWhereInput
    data: XOR<UserProvinceUpdateManyMutationInput, UserProvinceUncheckedUpdateManyWithoutUserInput>
  }

  export type UserProvinceScalarWhereInput = {
    AND?: UserProvinceScalarWhereInput | UserProvinceScalarWhereInput[]
    OR?: UserProvinceScalarWhereInput[]
    NOT?: UserProvinceScalarWhereInput | UserProvinceScalarWhereInput[]
    userId?: StringFilter<"UserProvince"> | string
    provinceId?: IntFilter<"UserProvince"> | number
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutRoleInput = {
    id: string
    name: string
    email: string
    phone: string
    password: string
    created_at?: Date | string
    Events?: EventsCreateNestedManyWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    userProvince?: UserProvinceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id: string
    name: string
    email: string
    phone: string
    password: string
    created_at?: Date | string
    Events?: EventsUncheckedCreateNestedManyWithoutUsersInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    userProvince?: UserProvinceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role_id?: IntNullableFilter<"User"> | number | null
    created_at?: DateTimeFilter<"User"> | Date | string
  }

  export type districtsCreateWithoutProvinceInput = {
    name: string
    createdAt?: Date | string
    locations?: locationsCreateNestedManyWithoutDistrictsInput
  }

  export type districtsUncheckedCreateWithoutProvinceInput = {
    id?: number
    name: string
    createdAt?: Date | string
    locations?: locationsUncheckedCreateNestedManyWithoutDistrictsInput
  }

  export type districtsCreateOrConnectWithoutProvinceInput = {
    where: districtsWhereUniqueInput
    create: XOR<districtsCreateWithoutProvinceInput, districtsUncheckedCreateWithoutProvinceInput>
  }

  export type districtsCreateManyProvinceInputEnvelope = {
    data: districtsCreateManyProvinceInput | districtsCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type UserProvinceCreateWithoutProvinceInput = {
    user: UserCreateNestedOneWithoutUserProvinceInput
  }

  export type UserProvinceUncheckedCreateWithoutProvinceInput = {
    userId: string
  }

  export type UserProvinceCreateOrConnectWithoutProvinceInput = {
    where: UserProvinceWhereUniqueInput
    create: XOR<UserProvinceCreateWithoutProvinceInput, UserProvinceUncheckedCreateWithoutProvinceInput>
  }

  export type UserProvinceCreateManyProvinceInputEnvelope = {
    data: UserProvinceCreateManyProvinceInput | UserProvinceCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type districtsUpsertWithWhereUniqueWithoutProvinceInput = {
    where: districtsWhereUniqueInput
    update: XOR<districtsUpdateWithoutProvinceInput, districtsUncheckedUpdateWithoutProvinceInput>
    create: XOR<districtsCreateWithoutProvinceInput, districtsUncheckedCreateWithoutProvinceInput>
  }

  export type districtsUpdateWithWhereUniqueWithoutProvinceInput = {
    where: districtsWhereUniqueInput
    data: XOR<districtsUpdateWithoutProvinceInput, districtsUncheckedUpdateWithoutProvinceInput>
  }

  export type districtsUpdateManyWithWhereWithoutProvinceInput = {
    where: districtsScalarWhereInput
    data: XOR<districtsUpdateManyMutationInput, districtsUncheckedUpdateManyWithoutProvinceInput>
  }

  export type districtsScalarWhereInput = {
    AND?: districtsScalarWhereInput | districtsScalarWhereInput[]
    OR?: districtsScalarWhereInput[]
    NOT?: districtsScalarWhereInput | districtsScalarWhereInput[]
    id?: IntFilter<"districts"> | number
    name?: StringFilter<"districts"> | string
    provinceId?: IntFilter<"districts"> | number
    createdAt?: DateTimeFilter<"districts"> | Date | string
  }

  export type UserProvinceUpsertWithWhereUniqueWithoutProvinceInput = {
    where: UserProvinceWhereUniqueInput
    update: XOR<UserProvinceUpdateWithoutProvinceInput, UserProvinceUncheckedUpdateWithoutProvinceInput>
    create: XOR<UserProvinceCreateWithoutProvinceInput, UserProvinceUncheckedCreateWithoutProvinceInput>
  }

  export type UserProvinceUpdateWithWhereUniqueWithoutProvinceInput = {
    where: UserProvinceWhereUniqueInput
    data: XOR<UserProvinceUpdateWithoutProvinceInput, UserProvinceUncheckedUpdateWithoutProvinceInput>
  }

  export type UserProvinceUpdateManyWithWhereWithoutProvinceInput = {
    where: UserProvinceScalarWhereInput
    data: XOR<UserProvinceUpdateManyMutationInput, UserProvinceUncheckedUpdateManyWithoutProvinceInput>
  }

  export type ProvinceCreateWithoutUserProvinceInput = {
    name: string
    created_at?: Date | string
    districts?: districtsCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateWithoutUserProvinceInput = {
    id?: number
    name: string
    created_at?: Date | string
    districts?: districtsUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceCreateOrConnectWithoutUserProvinceInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutUserProvinceInput, ProvinceUncheckedCreateWithoutUserProvinceInput>
  }

  export type UserCreateWithoutUserProvinceInput = {
    id: string
    name: string
    email: string
    phone: string
    password: string
    created_at?: Date | string
    Events?: EventsCreateNestedManyWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    role?: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutUserProvinceInput = {
    id: string
    name: string
    email: string
    phone: string
    password: string
    role_id?: number | null
    created_at?: Date | string
    Events?: EventsUncheckedCreateNestedManyWithoutUsersInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserProvinceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserProvinceInput, UserUncheckedCreateWithoutUserProvinceInput>
  }

  export type ProvinceUpsertWithoutUserProvinceInput = {
    update: XOR<ProvinceUpdateWithoutUserProvinceInput, ProvinceUncheckedUpdateWithoutUserProvinceInput>
    create: XOR<ProvinceCreateWithoutUserProvinceInput, ProvinceUncheckedCreateWithoutUserProvinceInput>
    where?: ProvinceWhereInput
  }

  export type ProvinceUpdateToOneWithWhereWithoutUserProvinceInput = {
    where?: ProvinceWhereInput
    data: XOR<ProvinceUpdateWithoutUserProvinceInput, ProvinceUncheckedUpdateWithoutUserProvinceInput>
  }

  export type ProvinceUpdateWithoutUserProvinceInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    districts?: districtsUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceUncheckedUpdateWithoutUserProvinceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    districts?: districtsUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type UserUpsertWithoutUserProvinceInput = {
    update: XOR<UserUpdateWithoutUserProvinceInput, UserUncheckedUpdateWithoutUserProvinceInput>
    create: XOR<UserCreateWithoutUserProvinceInput, UserUncheckedCreateWithoutUserProvinceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserProvinceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserProvinceInput, UserUncheckedUpdateWithoutUserProvinceInput>
  }

  export type UserUpdateWithoutUserProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Events?: EventsUpdateManyWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutUserProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Events?: EventsUncheckedUpdateManyWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id: string
    name: string
    email: string
    phone: string
    password: string
    created_at?: Date | string
    Events?: EventsCreateNestedManyWithoutUsersInput
    userProvince?: UserProvinceCreateNestedManyWithoutUserInput
    role?: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id: string
    name: string
    email: string
    phone: string
    password: string
    role_id?: number | null
    created_at?: Date | string
    Events?: EventsUncheckedCreateNestedManyWithoutUsersInput
    userProvince?: UserProvinceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Events?: EventsUpdateManyWithoutUsersNestedInput
    userProvince?: UserProvinceUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Events?: EventsUncheckedUpdateManyWithoutUsersNestedInput
    userProvince?: UserProvinceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EventCategoriesCreateWithoutCategoriesInput = {
    isSpecial?: boolean
    Events: EventsCreateNestedOneWithoutEventCategoriesInput
  }

  export type EventCategoriesUncheckedCreateWithoutCategoriesInput = {
    id?: number
    eventId: number
    isSpecial?: boolean
  }

  export type EventCategoriesCreateOrConnectWithoutCategoriesInput = {
    where: EventCategoriesWhereUniqueInput
    create: XOR<EventCategoriesCreateWithoutCategoriesInput, EventCategoriesUncheckedCreateWithoutCategoriesInput>
  }

  export type EventCategoriesCreateManyCategoriesInputEnvelope = {
    data: EventCategoriesCreateManyCategoriesInput | EventCategoriesCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type EventCategoriesUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: EventCategoriesWhereUniqueInput
    update: XOR<EventCategoriesUpdateWithoutCategoriesInput, EventCategoriesUncheckedUpdateWithoutCategoriesInput>
    create: XOR<EventCategoriesCreateWithoutCategoriesInput, EventCategoriesUncheckedCreateWithoutCategoriesInput>
  }

  export type EventCategoriesUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: EventCategoriesWhereUniqueInput
    data: XOR<EventCategoriesUpdateWithoutCategoriesInput, EventCategoriesUncheckedUpdateWithoutCategoriesInput>
  }

  export type EventCategoriesUpdateManyWithWhereWithoutCategoriesInput = {
    where: EventCategoriesScalarWhereInput
    data: XOR<EventCategoriesUpdateManyMutationInput, EventCategoriesUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type EventCategoriesScalarWhereInput = {
    AND?: EventCategoriesScalarWhereInput | EventCategoriesScalarWhereInput[]
    OR?: EventCategoriesScalarWhereInput[]
    NOT?: EventCategoriesScalarWhereInput | EventCategoriesScalarWhereInput[]
    id?: IntFilter<"EventCategories"> | number
    eventId?: IntFilter<"EventCategories"> | number
    categoryId?: IntFilter<"EventCategories"> | number
    isSpecial?: BoolFilter<"EventCategories"> | boolean
  }

  export type CategoriesCreateWithoutEventCategoriesInput = {
    name: string
    createdAt?: Date | string
  }

  export type CategoriesUncheckedCreateWithoutEventCategoriesInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type CategoriesCreateOrConnectWithoutEventCategoriesInput = {
    where: CategoriesWhereUniqueInput
    create: XOR<CategoriesCreateWithoutEventCategoriesInput, CategoriesUncheckedCreateWithoutEventCategoriesInput>
  }

  export type EventsCreateWithoutEventCategoriesInput = {
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status: string
    venue?: string | null
    createdAt?: Date | string
    minTicketPrice?: number
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore: Decimal | DecimalJsLike | number | string
    totalClicks?: number
    weekClicks?: number
    Images_Events_imgLogoIdToImages?: ImagesCreateNestedOneWithoutEvents_Events_imgLogoIdToImagesInput
    Images_Events_imgPosterIdToImages?: ImagesCreateNestedOneWithoutEvents_Events_imgPosterIdToImagesInput
    locations: locationsCreateNestedOneWithoutEventsInput
    users?: UserCreateNestedOneWithoutEventsInput
    Showing?: ShowingCreateNestedManyWithoutEventsInput
  }

  export type EventsUncheckedCreateWithoutEventCategoriesInput = {
    id?: number
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    organizerId?: string | null
    status: string
    locationId: number
    venue?: string | null
    imgLogoId?: number | null
    imgPosterId?: number | null
    createdAt?: Date | string
    minTicketPrice?: number
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore: Decimal | DecimalJsLike | number | string
    totalClicks?: number
    weekClicks?: number
    Showing?: ShowingUncheckedCreateNestedManyWithoutEventsInput
  }

  export type EventsCreateOrConnectWithoutEventCategoriesInput = {
    where: EventsWhereUniqueInput
    create: XOR<EventsCreateWithoutEventCategoriesInput, EventsUncheckedCreateWithoutEventCategoriesInput>
  }

  export type CategoriesUpsertWithoutEventCategoriesInput = {
    update: XOR<CategoriesUpdateWithoutEventCategoriesInput, CategoriesUncheckedUpdateWithoutEventCategoriesInput>
    create: XOR<CategoriesCreateWithoutEventCategoriesInput, CategoriesUncheckedCreateWithoutEventCategoriesInput>
    where?: CategoriesWhereInput
  }

  export type CategoriesUpdateToOneWithWhereWithoutEventCategoriesInput = {
    where?: CategoriesWhereInput
    data: XOR<CategoriesUpdateWithoutEventCategoriesInput, CategoriesUncheckedUpdateWithoutEventCategoriesInput>
  }

  export type CategoriesUpdateWithoutEventCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoriesUncheckedUpdateWithoutEventCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsUpsertWithoutEventCategoriesInput = {
    update: XOR<EventsUpdateWithoutEventCategoriesInput, EventsUncheckedUpdateWithoutEventCategoriesInput>
    create: XOR<EventsCreateWithoutEventCategoriesInput, EventsUncheckedCreateWithoutEventCategoriesInput>
    where?: EventsWhereInput
  }

  export type EventsUpdateToOneWithWhereWithoutEventCategoriesInput = {
    where?: EventsWhereInput
    data: XOR<EventsUpdateWithoutEventCategoriesInput, EventsUncheckedUpdateWithoutEventCategoriesInput>
  }

  export type EventsUpdateWithoutEventCategoriesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minTicketPrice?: IntFieldUpdateOperationsInput | number
    isOnlyOnEve?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    lastScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFieldUpdateOperationsInput | number
    weekClicks?: IntFieldUpdateOperationsInput | number
    Images_Events_imgLogoIdToImages?: ImagesUpdateOneWithoutEvents_Events_imgLogoIdToImagesNestedInput
    Images_Events_imgPosterIdToImages?: ImagesUpdateOneWithoutEvents_Events_imgPosterIdToImagesNestedInput
    locations?: locationsUpdateOneRequiredWithoutEventsNestedInput
    users?: UserUpdateOneWithoutEventsNestedInput
    Showing?: ShowingUpdateManyWithoutEventsNestedInput
  }

  export type EventsUncheckedUpdateWithoutEventCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    organizerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    imgLogoId?: NullableIntFieldUpdateOperationsInput | number | null
    imgPosterId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minTicketPrice?: IntFieldUpdateOperationsInput | number
    isOnlyOnEve?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    lastScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFieldUpdateOperationsInput | number
    weekClicks?: IntFieldUpdateOperationsInput | number
    Showing?: ShowingUncheckedUpdateManyWithoutEventsNestedInput
  }

  export type EventCategoriesCreateWithoutEventsInput = {
    isSpecial?: boolean
    Categories: CategoriesCreateNestedOneWithoutEventCategoriesInput
  }

  export type EventCategoriesUncheckedCreateWithoutEventsInput = {
    id?: number
    categoryId: number
    isSpecial?: boolean
  }

  export type EventCategoriesCreateOrConnectWithoutEventsInput = {
    where: EventCategoriesWhereUniqueInput
    create: XOR<EventCategoriesCreateWithoutEventsInput, EventCategoriesUncheckedCreateWithoutEventsInput>
  }

  export type EventCategoriesCreateManyEventsInputEnvelope = {
    data: EventCategoriesCreateManyEventsInput | EventCategoriesCreateManyEventsInput[]
    skipDuplicates?: boolean
  }

  export type ImagesCreateWithoutEvents_Events_imgLogoIdToImagesInput = {
    imageUrl: string
    Events_Events_imgPosterIdToImages?: EventsCreateNestedManyWithoutImages_Events_imgPosterIdToImagesInput
  }

  export type ImagesUncheckedCreateWithoutEvents_Events_imgLogoIdToImagesInput = {
    id?: number
    imageUrl: string
    Events_Events_imgPosterIdToImages?: EventsUncheckedCreateNestedManyWithoutImages_Events_imgPosterIdToImagesInput
  }

  export type ImagesCreateOrConnectWithoutEvents_Events_imgLogoIdToImagesInput = {
    where: ImagesWhereUniqueInput
    create: XOR<ImagesCreateWithoutEvents_Events_imgLogoIdToImagesInput, ImagesUncheckedCreateWithoutEvents_Events_imgLogoIdToImagesInput>
  }

  export type ImagesCreateWithoutEvents_Events_imgPosterIdToImagesInput = {
    imageUrl: string
    Events_Events_imgLogoIdToImages?: EventsCreateNestedManyWithoutImages_Events_imgLogoIdToImagesInput
  }

  export type ImagesUncheckedCreateWithoutEvents_Events_imgPosterIdToImagesInput = {
    id?: number
    imageUrl: string
    Events_Events_imgLogoIdToImages?: EventsUncheckedCreateNestedManyWithoutImages_Events_imgLogoIdToImagesInput
  }

  export type ImagesCreateOrConnectWithoutEvents_Events_imgPosterIdToImagesInput = {
    where: ImagesWhereUniqueInput
    create: XOR<ImagesCreateWithoutEvents_Events_imgPosterIdToImagesInput, ImagesUncheckedCreateWithoutEvents_Events_imgPosterIdToImagesInput>
  }

  export type locationsCreateWithoutEventsInput = {
    street: string
    ward: string
    createdAt?: Date | string
    districts: districtsCreateNestedOneWithoutLocationsInput
  }

  export type locationsUncheckedCreateWithoutEventsInput = {
    id?: number
    street: string
    ward: string
    districtId: number
    createdAt?: Date | string
  }

  export type locationsCreateOrConnectWithoutEventsInput = {
    where: locationsWhereUniqueInput
    create: XOR<locationsCreateWithoutEventsInput, locationsUncheckedCreateWithoutEventsInput>
  }

  export type UserCreateWithoutEventsInput = {
    id: string
    name: string
    email: string
    phone: string
    password: string
    created_at?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    userProvince?: UserProvinceCreateNestedManyWithoutUserInput
    role?: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutEventsInput = {
    id: string
    name: string
    email: string
    phone: string
    password: string
    role_id?: number | null
    created_at?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    userProvince?: UserProvinceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
  }

  export type ShowingCreateWithoutEventsInput = {
    id: string
    status: string
    isFree: boolean
    isSalable: boolean
    isPresale: boolean
    startTime: Date | string
    endTime: Date | string
    isEnabledQueueWaiting: boolean
    showAllSeats: boolean
    Seatmap: SeatmapCreateNestedOneWithoutShowingInput
    Ticket?: TicketCreateNestedManyWithoutShowingInput
    TicketType?: TicketTypeCreateNestedManyWithoutShowingInput
  }

  export type ShowingUncheckedCreateWithoutEventsInput = {
    id: string
    status: string
    isFree: boolean
    isSalable: boolean
    isPresale: boolean
    seatMapId: number
    startTime: Date | string
    endTime: Date | string
    isEnabledQueueWaiting: boolean
    showAllSeats: boolean
    Ticket?: TicketUncheckedCreateNestedManyWithoutShowingInput
    TicketType?: TicketTypeUncheckedCreateNestedManyWithoutShowingInput
  }

  export type ShowingCreateOrConnectWithoutEventsInput = {
    where: ShowingWhereUniqueInput
    create: XOR<ShowingCreateWithoutEventsInput, ShowingUncheckedCreateWithoutEventsInput>
  }

  export type ShowingCreateManyEventsInputEnvelope = {
    data: ShowingCreateManyEventsInput | ShowingCreateManyEventsInput[]
    skipDuplicates?: boolean
  }

  export type EventCategoriesUpsertWithWhereUniqueWithoutEventsInput = {
    where: EventCategoriesWhereUniqueInput
    update: XOR<EventCategoriesUpdateWithoutEventsInput, EventCategoriesUncheckedUpdateWithoutEventsInput>
    create: XOR<EventCategoriesCreateWithoutEventsInput, EventCategoriesUncheckedCreateWithoutEventsInput>
  }

  export type EventCategoriesUpdateWithWhereUniqueWithoutEventsInput = {
    where: EventCategoriesWhereUniqueInput
    data: XOR<EventCategoriesUpdateWithoutEventsInput, EventCategoriesUncheckedUpdateWithoutEventsInput>
  }

  export type EventCategoriesUpdateManyWithWhereWithoutEventsInput = {
    where: EventCategoriesScalarWhereInput
    data: XOR<EventCategoriesUpdateManyMutationInput, EventCategoriesUncheckedUpdateManyWithoutEventsInput>
  }

  export type ImagesUpsertWithoutEvents_Events_imgLogoIdToImagesInput = {
    update: XOR<ImagesUpdateWithoutEvents_Events_imgLogoIdToImagesInput, ImagesUncheckedUpdateWithoutEvents_Events_imgLogoIdToImagesInput>
    create: XOR<ImagesCreateWithoutEvents_Events_imgLogoIdToImagesInput, ImagesUncheckedCreateWithoutEvents_Events_imgLogoIdToImagesInput>
    where?: ImagesWhereInput
  }

  export type ImagesUpdateToOneWithWhereWithoutEvents_Events_imgLogoIdToImagesInput = {
    where?: ImagesWhereInput
    data: XOR<ImagesUpdateWithoutEvents_Events_imgLogoIdToImagesInput, ImagesUncheckedUpdateWithoutEvents_Events_imgLogoIdToImagesInput>
  }

  export type ImagesUpdateWithoutEvents_Events_imgLogoIdToImagesInput = {
    imageUrl?: StringFieldUpdateOperationsInput | string
    Events_Events_imgPosterIdToImages?: EventsUpdateManyWithoutImages_Events_imgPosterIdToImagesNestedInput
  }

  export type ImagesUncheckedUpdateWithoutEvents_Events_imgLogoIdToImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    Events_Events_imgPosterIdToImages?: EventsUncheckedUpdateManyWithoutImages_Events_imgPosterIdToImagesNestedInput
  }

  export type ImagesUpsertWithoutEvents_Events_imgPosterIdToImagesInput = {
    update: XOR<ImagesUpdateWithoutEvents_Events_imgPosterIdToImagesInput, ImagesUncheckedUpdateWithoutEvents_Events_imgPosterIdToImagesInput>
    create: XOR<ImagesCreateWithoutEvents_Events_imgPosterIdToImagesInput, ImagesUncheckedCreateWithoutEvents_Events_imgPosterIdToImagesInput>
    where?: ImagesWhereInput
  }

  export type ImagesUpdateToOneWithWhereWithoutEvents_Events_imgPosterIdToImagesInput = {
    where?: ImagesWhereInput
    data: XOR<ImagesUpdateWithoutEvents_Events_imgPosterIdToImagesInput, ImagesUncheckedUpdateWithoutEvents_Events_imgPosterIdToImagesInput>
  }

  export type ImagesUpdateWithoutEvents_Events_imgPosterIdToImagesInput = {
    imageUrl?: StringFieldUpdateOperationsInput | string
    Events_Events_imgLogoIdToImages?: EventsUpdateManyWithoutImages_Events_imgLogoIdToImagesNestedInput
  }

  export type ImagesUncheckedUpdateWithoutEvents_Events_imgPosterIdToImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    Events_Events_imgLogoIdToImages?: EventsUncheckedUpdateManyWithoutImages_Events_imgLogoIdToImagesNestedInput
  }

  export type locationsUpsertWithoutEventsInput = {
    update: XOR<locationsUpdateWithoutEventsInput, locationsUncheckedUpdateWithoutEventsInput>
    create: XOR<locationsCreateWithoutEventsInput, locationsUncheckedCreateWithoutEventsInput>
    where?: locationsWhereInput
  }

  export type locationsUpdateToOneWithWhereWithoutEventsInput = {
    where?: locationsWhereInput
    data: XOR<locationsUpdateWithoutEventsInput, locationsUncheckedUpdateWithoutEventsInput>
  }

  export type locationsUpdateWithoutEventsInput = {
    street?: StringFieldUpdateOperationsInput | string
    ward?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    districts?: districtsUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type locationsUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    ward?: StringFieldUpdateOperationsInput | string
    districtId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutEventsInput = {
    update: XOR<UserUpdateWithoutEventsInput, UserUncheckedUpdateWithoutEventsInput>
    create: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventsInput, UserUncheckedUpdateWithoutEventsInput>
  }

  export type UserUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    userProvince?: UserProvinceUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    userProvince?: UserProvinceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ShowingUpsertWithWhereUniqueWithoutEventsInput = {
    where: ShowingWhereUniqueInput
    update: XOR<ShowingUpdateWithoutEventsInput, ShowingUncheckedUpdateWithoutEventsInput>
    create: XOR<ShowingCreateWithoutEventsInput, ShowingUncheckedCreateWithoutEventsInput>
  }

  export type ShowingUpdateWithWhereUniqueWithoutEventsInput = {
    where: ShowingWhereUniqueInput
    data: XOR<ShowingUpdateWithoutEventsInput, ShowingUncheckedUpdateWithoutEventsInput>
  }

  export type ShowingUpdateManyWithWhereWithoutEventsInput = {
    where: ShowingScalarWhereInput
    data: XOR<ShowingUpdateManyMutationInput, ShowingUncheckedUpdateManyWithoutEventsInput>
  }

  export type ShowingScalarWhereInput = {
    AND?: ShowingScalarWhereInput | ShowingScalarWhereInput[]
    OR?: ShowingScalarWhereInput[]
    NOT?: ShowingScalarWhereInput | ShowingScalarWhereInput[]
    id?: StringFilter<"Showing"> | string
    eventId?: IntFilter<"Showing"> | number
    status?: StringFilter<"Showing"> | string
    isFree?: BoolFilter<"Showing"> | boolean
    isSalable?: BoolFilter<"Showing"> | boolean
    isPresale?: BoolFilter<"Showing"> | boolean
    seatMapId?: IntFilter<"Showing"> | number
    startTime?: DateTimeFilter<"Showing"> | Date | string
    endTime?: DateTimeFilter<"Showing"> | Date | string
    isEnabledQueueWaiting?: BoolFilter<"Showing"> | boolean
    showAllSeats?: BoolFilter<"Showing"> | boolean
  }

  export type EventsCreateWithoutImages_Events_imgLogoIdToImagesInput = {
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status: string
    venue?: string | null
    createdAt?: Date | string
    minTicketPrice?: number
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore: Decimal | DecimalJsLike | number | string
    totalClicks?: number
    weekClicks?: number
    EventCategories?: EventCategoriesCreateNestedManyWithoutEventsInput
    Images_Events_imgPosterIdToImages?: ImagesCreateNestedOneWithoutEvents_Events_imgPosterIdToImagesInput
    locations: locationsCreateNestedOneWithoutEventsInput
    users?: UserCreateNestedOneWithoutEventsInput
    Showing?: ShowingCreateNestedManyWithoutEventsInput
  }

  export type EventsUncheckedCreateWithoutImages_Events_imgLogoIdToImagesInput = {
    id?: number
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    organizerId?: string | null
    status: string
    locationId: number
    venue?: string | null
    imgPosterId?: number | null
    createdAt?: Date | string
    minTicketPrice?: number
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore: Decimal | DecimalJsLike | number | string
    totalClicks?: number
    weekClicks?: number
    EventCategories?: EventCategoriesUncheckedCreateNestedManyWithoutEventsInput
    Showing?: ShowingUncheckedCreateNestedManyWithoutEventsInput
  }

  export type EventsCreateOrConnectWithoutImages_Events_imgLogoIdToImagesInput = {
    where: EventsWhereUniqueInput
    create: XOR<EventsCreateWithoutImages_Events_imgLogoIdToImagesInput, EventsUncheckedCreateWithoutImages_Events_imgLogoIdToImagesInput>
  }

  export type EventsCreateManyImages_Events_imgLogoIdToImagesInputEnvelope = {
    data: EventsCreateManyImages_Events_imgLogoIdToImagesInput | EventsCreateManyImages_Events_imgLogoIdToImagesInput[]
    skipDuplicates?: boolean
  }

  export type EventsCreateWithoutImages_Events_imgPosterIdToImagesInput = {
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status: string
    venue?: string | null
    createdAt?: Date | string
    minTicketPrice?: number
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore: Decimal | DecimalJsLike | number | string
    totalClicks?: number
    weekClicks?: number
    EventCategories?: EventCategoriesCreateNestedManyWithoutEventsInput
    Images_Events_imgLogoIdToImages?: ImagesCreateNestedOneWithoutEvents_Events_imgLogoIdToImagesInput
    locations: locationsCreateNestedOneWithoutEventsInput
    users?: UserCreateNestedOneWithoutEventsInput
    Showing?: ShowingCreateNestedManyWithoutEventsInput
  }

  export type EventsUncheckedCreateWithoutImages_Events_imgPosterIdToImagesInput = {
    id?: number
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    organizerId?: string | null
    status: string
    locationId: number
    venue?: string | null
    imgLogoId?: number | null
    createdAt?: Date | string
    minTicketPrice?: number
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore: Decimal | DecimalJsLike | number | string
    totalClicks?: number
    weekClicks?: number
    EventCategories?: EventCategoriesUncheckedCreateNestedManyWithoutEventsInput
    Showing?: ShowingUncheckedCreateNestedManyWithoutEventsInput
  }

  export type EventsCreateOrConnectWithoutImages_Events_imgPosterIdToImagesInput = {
    where: EventsWhereUniqueInput
    create: XOR<EventsCreateWithoutImages_Events_imgPosterIdToImagesInput, EventsUncheckedCreateWithoutImages_Events_imgPosterIdToImagesInput>
  }

  export type EventsCreateManyImages_Events_imgPosterIdToImagesInputEnvelope = {
    data: EventsCreateManyImages_Events_imgPosterIdToImagesInput | EventsCreateManyImages_Events_imgPosterIdToImagesInput[]
    skipDuplicates?: boolean
  }

  export type EventsUpsertWithWhereUniqueWithoutImages_Events_imgLogoIdToImagesInput = {
    where: EventsWhereUniqueInput
    update: XOR<EventsUpdateWithoutImages_Events_imgLogoIdToImagesInput, EventsUncheckedUpdateWithoutImages_Events_imgLogoIdToImagesInput>
    create: XOR<EventsCreateWithoutImages_Events_imgLogoIdToImagesInput, EventsUncheckedCreateWithoutImages_Events_imgLogoIdToImagesInput>
  }

  export type EventsUpdateWithWhereUniqueWithoutImages_Events_imgLogoIdToImagesInput = {
    where: EventsWhereUniqueInput
    data: XOR<EventsUpdateWithoutImages_Events_imgLogoIdToImagesInput, EventsUncheckedUpdateWithoutImages_Events_imgLogoIdToImagesInput>
  }

  export type EventsUpdateManyWithWhereWithoutImages_Events_imgLogoIdToImagesInput = {
    where: EventsScalarWhereInput
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyWithoutImages_Events_imgLogoIdToImagesInput>
  }

  export type EventsUpsertWithWhereUniqueWithoutImages_Events_imgPosterIdToImagesInput = {
    where: EventsWhereUniqueInput
    update: XOR<EventsUpdateWithoutImages_Events_imgPosterIdToImagesInput, EventsUncheckedUpdateWithoutImages_Events_imgPosterIdToImagesInput>
    create: XOR<EventsCreateWithoutImages_Events_imgPosterIdToImagesInput, EventsUncheckedCreateWithoutImages_Events_imgPosterIdToImagesInput>
  }

  export type EventsUpdateWithWhereUniqueWithoutImages_Events_imgPosterIdToImagesInput = {
    where: EventsWhereUniqueInput
    data: XOR<EventsUpdateWithoutImages_Events_imgPosterIdToImagesInput, EventsUncheckedUpdateWithoutImages_Events_imgPosterIdToImagesInput>
  }

  export type EventsUpdateManyWithWhereWithoutImages_Events_imgPosterIdToImagesInput = {
    where: EventsScalarWhereInput
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyWithoutImages_Events_imgPosterIdToImagesInput>
  }

  export type ProvinceCreateWithoutDistrictsInput = {
    name: string
    created_at?: Date | string
    userProvince?: UserProvinceCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateWithoutDistrictsInput = {
    id?: number
    name: string
    created_at?: Date | string
    userProvince?: UserProvinceUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceCreateOrConnectWithoutDistrictsInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutDistrictsInput, ProvinceUncheckedCreateWithoutDistrictsInput>
  }

  export type locationsCreateWithoutDistrictsInput = {
    street: string
    ward: string
    createdAt?: Date | string
    Events?: EventsCreateNestedManyWithoutLocationsInput
  }

  export type locationsUncheckedCreateWithoutDistrictsInput = {
    id?: number
    street: string
    ward: string
    createdAt?: Date | string
    Events?: EventsUncheckedCreateNestedManyWithoutLocationsInput
  }

  export type locationsCreateOrConnectWithoutDistrictsInput = {
    where: locationsWhereUniqueInput
    create: XOR<locationsCreateWithoutDistrictsInput, locationsUncheckedCreateWithoutDistrictsInput>
  }

  export type locationsCreateManyDistrictsInputEnvelope = {
    data: locationsCreateManyDistrictsInput | locationsCreateManyDistrictsInput[]
    skipDuplicates?: boolean
  }

  export type ProvinceUpsertWithoutDistrictsInput = {
    update: XOR<ProvinceUpdateWithoutDistrictsInput, ProvinceUncheckedUpdateWithoutDistrictsInput>
    create: XOR<ProvinceCreateWithoutDistrictsInput, ProvinceUncheckedCreateWithoutDistrictsInput>
    where?: ProvinceWhereInput
  }

  export type ProvinceUpdateToOneWithWhereWithoutDistrictsInput = {
    where?: ProvinceWhereInput
    data: XOR<ProvinceUpdateWithoutDistrictsInput, ProvinceUncheckedUpdateWithoutDistrictsInput>
  }

  export type ProvinceUpdateWithoutDistrictsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userProvince?: UserProvinceUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceUncheckedUpdateWithoutDistrictsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userProvince?: UserProvinceUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type locationsUpsertWithWhereUniqueWithoutDistrictsInput = {
    where: locationsWhereUniqueInput
    update: XOR<locationsUpdateWithoutDistrictsInput, locationsUncheckedUpdateWithoutDistrictsInput>
    create: XOR<locationsCreateWithoutDistrictsInput, locationsUncheckedCreateWithoutDistrictsInput>
  }

  export type locationsUpdateWithWhereUniqueWithoutDistrictsInput = {
    where: locationsWhereUniqueInput
    data: XOR<locationsUpdateWithoutDistrictsInput, locationsUncheckedUpdateWithoutDistrictsInput>
  }

  export type locationsUpdateManyWithWhereWithoutDistrictsInput = {
    where: locationsScalarWhereInput
    data: XOR<locationsUpdateManyMutationInput, locationsUncheckedUpdateManyWithoutDistrictsInput>
  }

  export type locationsScalarWhereInput = {
    AND?: locationsScalarWhereInput | locationsScalarWhereInput[]
    OR?: locationsScalarWhereInput[]
    NOT?: locationsScalarWhereInput | locationsScalarWhereInput[]
    id?: IntFilter<"locations"> | number
    street?: StringFilter<"locations"> | string
    ward?: StringFilter<"locations"> | string
    districtId?: IntFilter<"locations"> | number
    createdAt?: DateTimeFilter<"locations"> | Date | string
  }

  export type EventsCreateWithoutLocationsInput = {
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status: string
    venue?: string | null
    createdAt?: Date | string
    minTicketPrice?: number
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore: Decimal | DecimalJsLike | number | string
    totalClicks?: number
    weekClicks?: number
    EventCategories?: EventCategoriesCreateNestedManyWithoutEventsInput
    Images_Events_imgLogoIdToImages?: ImagesCreateNestedOneWithoutEvents_Events_imgLogoIdToImagesInput
    Images_Events_imgPosterIdToImages?: ImagesCreateNestedOneWithoutEvents_Events_imgPosterIdToImagesInput
    users?: UserCreateNestedOneWithoutEventsInput
    Showing?: ShowingCreateNestedManyWithoutEventsInput
  }

  export type EventsUncheckedCreateWithoutLocationsInput = {
    id?: number
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    organizerId?: string | null
    status: string
    venue?: string | null
    imgLogoId?: number | null
    imgPosterId?: number | null
    createdAt?: Date | string
    minTicketPrice?: number
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore: Decimal | DecimalJsLike | number | string
    totalClicks?: number
    weekClicks?: number
    EventCategories?: EventCategoriesUncheckedCreateNestedManyWithoutEventsInput
    Showing?: ShowingUncheckedCreateNestedManyWithoutEventsInput
  }

  export type EventsCreateOrConnectWithoutLocationsInput = {
    where: EventsWhereUniqueInput
    create: XOR<EventsCreateWithoutLocationsInput, EventsUncheckedCreateWithoutLocationsInput>
  }

  export type EventsCreateManyLocationsInputEnvelope = {
    data: EventsCreateManyLocationsInput | EventsCreateManyLocationsInput[]
    skipDuplicates?: boolean
  }

  export type districtsCreateWithoutLocationsInput = {
    name: string
    createdAt?: Date | string
    province: ProvinceCreateNestedOneWithoutDistrictsInput
  }

  export type districtsUncheckedCreateWithoutLocationsInput = {
    id?: number
    name: string
    provinceId: number
    createdAt?: Date | string
  }

  export type districtsCreateOrConnectWithoutLocationsInput = {
    where: districtsWhereUniqueInput
    create: XOR<districtsCreateWithoutLocationsInput, districtsUncheckedCreateWithoutLocationsInput>
  }

  export type EventsUpsertWithWhereUniqueWithoutLocationsInput = {
    where: EventsWhereUniqueInput
    update: XOR<EventsUpdateWithoutLocationsInput, EventsUncheckedUpdateWithoutLocationsInput>
    create: XOR<EventsCreateWithoutLocationsInput, EventsUncheckedCreateWithoutLocationsInput>
  }

  export type EventsUpdateWithWhereUniqueWithoutLocationsInput = {
    where: EventsWhereUniqueInput
    data: XOR<EventsUpdateWithoutLocationsInput, EventsUncheckedUpdateWithoutLocationsInput>
  }

  export type EventsUpdateManyWithWhereWithoutLocationsInput = {
    where: EventsScalarWhereInput
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyWithoutLocationsInput>
  }

  export type districtsUpsertWithoutLocationsInput = {
    update: XOR<districtsUpdateWithoutLocationsInput, districtsUncheckedUpdateWithoutLocationsInput>
    create: XOR<districtsCreateWithoutLocationsInput, districtsUncheckedCreateWithoutLocationsInput>
    where?: districtsWhereInput
  }

  export type districtsUpdateToOneWithWhereWithoutLocationsInput = {
    where?: districtsWhereInput
    data: XOR<districtsUpdateWithoutLocationsInput, districtsUncheckedUpdateWithoutLocationsInput>
  }

  export type districtsUpdateWithoutLocationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutDistrictsNestedInput
  }

  export type districtsUncheckedUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    provinceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionCreateWithoutRowInput = {
    name: string
    isStage: boolean
    element: JsonNullValueInput | InputJsonValue
    attribute: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    ticketTypeId: string
    Seatmap: SeatmapCreateNestedOneWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutRowInput = {
    id?: number
    name: string
    seatmapId: number
    isStage: boolean
    element: JsonNullValueInput | InputJsonValue
    attribute: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    ticketTypeId: string
  }

  export type SectionCreateOrConnectWithoutRowInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutRowInput, SectionUncheckedCreateWithoutRowInput>
  }

  export type SeatCreateWithoutRowInput = {
    name: string
    positionX: number
    positionY: number
    createdAt?: Date | string
    position: number
    Ticket?: TicketCreateNestedManyWithoutSeatInput
  }

  export type SeatUncheckedCreateWithoutRowInput = {
    id?: number
    name: string
    positionX: number
    positionY: number
    createdAt?: Date | string
    position: number
    Ticket?: TicketUncheckedCreateNestedManyWithoutSeatInput
  }

  export type SeatCreateOrConnectWithoutRowInput = {
    where: SeatWhereUniqueInput
    create: XOR<SeatCreateWithoutRowInput, SeatUncheckedCreateWithoutRowInput>
  }

  export type SeatCreateManyRowInputEnvelope = {
    data: SeatCreateManyRowInput | SeatCreateManyRowInput[]
    skipDuplicates?: boolean
  }

  export type SectionUpsertWithoutRowInput = {
    update: XOR<SectionUpdateWithoutRowInput, SectionUncheckedUpdateWithoutRowInput>
    create: XOR<SectionCreateWithoutRowInput, SectionUncheckedCreateWithoutRowInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutRowInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutRowInput, SectionUncheckedUpdateWithoutRowInput>
  }

  export type SectionUpdateWithoutRowInput = {
    name?: StringFieldUpdateOperationsInput | string
    isStage?: BoolFieldUpdateOperationsInput | boolean
    element?: JsonNullValueInput | InputJsonValue
    attribute?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketTypeId?: StringFieldUpdateOperationsInput | string
    Seatmap?: SeatmapUpdateOneRequiredWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutRowInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    seatmapId?: IntFieldUpdateOperationsInput | number
    isStage?: BoolFieldUpdateOperationsInput | boolean
    element?: JsonNullValueInput | InputJsonValue
    attribute?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type SeatUpsertWithWhereUniqueWithoutRowInput = {
    where: SeatWhereUniqueInput
    update: XOR<SeatUpdateWithoutRowInput, SeatUncheckedUpdateWithoutRowInput>
    create: XOR<SeatCreateWithoutRowInput, SeatUncheckedCreateWithoutRowInput>
  }

  export type SeatUpdateWithWhereUniqueWithoutRowInput = {
    where: SeatWhereUniqueInput
    data: XOR<SeatUpdateWithoutRowInput, SeatUncheckedUpdateWithoutRowInput>
  }

  export type SeatUpdateManyWithWhereWithoutRowInput = {
    where: SeatScalarWhereInput
    data: XOR<SeatUpdateManyMutationInput, SeatUncheckedUpdateManyWithoutRowInput>
  }

  export type SeatScalarWhereInput = {
    AND?: SeatScalarWhereInput | SeatScalarWhereInput[]
    OR?: SeatScalarWhereInput[]
    NOT?: SeatScalarWhereInput | SeatScalarWhereInput[]
    id?: IntFilter<"Seat"> | number
    name?: StringFilter<"Seat"> | string
    rowId?: IntFilter<"Seat"> | number
    positionX?: FloatFilter<"Seat"> | number
    positionY?: FloatFilter<"Seat"> | number
    createdAt?: DateTimeFilter<"Seat"> | Date | string
    position?: IntFilter<"Seat"> | number
  }

  export type RowCreateWithoutSeatInput = {
    name: string
    createdAt?: Date | string
    Section: SectionCreateNestedOneWithoutRowInput
  }

  export type RowUncheckedCreateWithoutSeatInput = {
    id?: number
    name: string
    sectionId: number
    createdAt?: Date | string
  }

  export type RowCreateOrConnectWithoutSeatInput = {
    where: RowWhereUniqueInput
    create: XOR<RowCreateWithoutSeatInput, RowUncheckedCreateWithoutSeatInput>
  }

  export type TicketCreateWithoutSeatInput = {
    id?: string
    status: number
    price: number
    userId?: number | null
    purchasedAt?: Date | string | null
    qrCode?: string | null
    Showing: ShowingCreateNestedOneWithoutTicketInput
    TicketType: TicketTypeCreateNestedOneWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutSeatInput = {
    id?: string
    showingId: string
    ticketTypeId: string
    status: number
    price: number
    userId?: number | null
    purchasedAt?: Date | string | null
    qrCode?: string | null
  }

  export type TicketCreateOrConnectWithoutSeatInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutSeatInput, TicketUncheckedCreateWithoutSeatInput>
  }

  export type TicketCreateManySeatInputEnvelope = {
    data: TicketCreateManySeatInput | TicketCreateManySeatInput[]
    skipDuplicates?: boolean
  }

  export type RowUpsertWithoutSeatInput = {
    update: XOR<RowUpdateWithoutSeatInput, RowUncheckedUpdateWithoutSeatInput>
    create: XOR<RowCreateWithoutSeatInput, RowUncheckedCreateWithoutSeatInput>
    where?: RowWhereInput
  }

  export type RowUpdateToOneWithWhereWithoutSeatInput = {
    where?: RowWhereInput
    data: XOR<RowUpdateWithoutSeatInput, RowUncheckedUpdateWithoutSeatInput>
  }

  export type RowUpdateWithoutSeatInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Section?: SectionUpdateOneRequiredWithoutRowNestedInput
  }

  export type RowUncheckedUpdateWithoutSeatInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    sectionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpsertWithWhereUniqueWithoutSeatInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutSeatInput, TicketUncheckedUpdateWithoutSeatInput>
    create: XOR<TicketCreateWithoutSeatInput, TicketUncheckedCreateWithoutSeatInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutSeatInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutSeatInput, TicketUncheckedUpdateWithoutSeatInput>
  }

  export type TicketUpdateManyWithWhereWithoutSeatInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutSeatInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: StringFilter<"Ticket"> | string
    seatId?: IntFilter<"Ticket"> | number
    showingId?: StringFilter<"Ticket"> | string
    ticketTypeId?: StringFilter<"Ticket"> | string
    status?: IntFilter<"Ticket"> | number
    price?: IntFilter<"Ticket"> | number
    userId?: IntNullableFilter<"Ticket"> | number | null
    purchasedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    qrCode?: StringNullableFilter<"Ticket"> | string | null
  }

  export type SectionCreateWithoutSeatmapInput = {
    name: string
    isStage: boolean
    element: JsonNullValueInput | InputJsonValue
    attribute: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    ticketTypeId: string
    Row?: RowCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutSeatmapInput = {
    id?: number
    name: string
    isStage: boolean
    element: JsonNullValueInput | InputJsonValue
    attribute: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    ticketTypeId: string
    Row?: RowUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutSeatmapInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutSeatmapInput, SectionUncheckedCreateWithoutSeatmapInput>
  }

  export type SectionCreateManySeatmapInputEnvelope = {
    data: SectionCreateManySeatmapInput | SectionCreateManySeatmapInput[]
    skipDuplicates?: boolean
  }

  export type ShowingCreateWithoutSeatmapInput = {
    id: string
    status: string
    isFree: boolean
    isSalable: boolean
    isPresale: boolean
    startTime: Date | string
    endTime: Date | string
    isEnabledQueueWaiting: boolean
    showAllSeats: boolean
    Events: EventsCreateNestedOneWithoutShowingInput
    Ticket?: TicketCreateNestedManyWithoutShowingInput
    TicketType?: TicketTypeCreateNestedManyWithoutShowingInput
  }

  export type ShowingUncheckedCreateWithoutSeatmapInput = {
    id: string
    eventId: number
    status: string
    isFree: boolean
    isSalable: boolean
    isPresale: boolean
    startTime: Date | string
    endTime: Date | string
    isEnabledQueueWaiting: boolean
    showAllSeats: boolean
    Ticket?: TicketUncheckedCreateNestedManyWithoutShowingInput
    TicketType?: TicketTypeUncheckedCreateNestedManyWithoutShowingInput
  }

  export type ShowingCreateOrConnectWithoutSeatmapInput = {
    where: ShowingWhereUniqueInput
    create: XOR<ShowingCreateWithoutSeatmapInput, ShowingUncheckedCreateWithoutSeatmapInput>
  }

  export type ShowingCreateManySeatmapInputEnvelope = {
    data: ShowingCreateManySeatmapInput | ShowingCreateManySeatmapInput[]
    skipDuplicates?: boolean
  }

  export type SectionUpsertWithWhereUniqueWithoutSeatmapInput = {
    where: SectionWhereUniqueInput
    update: XOR<SectionUpdateWithoutSeatmapInput, SectionUncheckedUpdateWithoutSeatmapInput>
    create: XOR<SectionCreateWithoutSeatmapInput, SectionUncheckedCreateWithoutSeatmapInput>
  }

  export type SectionUpdateWithWhereUniqueWithoutSeatmapInput = {
    where: SectionWhereUniqueInput
    data: XOR<SectionUpdateWithoutSeatmapInput, SectionUncheckedUpdateWithoutSeatmapInput>
  }

  export type SectionUpdateManyWithWhereWithoutSeatmapInput = {
    where: SectionScalarWhereInput
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyWithoutSeatmapInput>
  }

  export type SectionScalarWhereInput = {
    AND?: SectionScalarWhereInput | SectionScalarWhereInput[]
    OR?: SectionScalarWhereInput[]
    NOT?: SectionScalarWhereInput | SectionScalarWhereInput[]
    id?: IntFilter<"Section"> | number
    name?: StringFilter<"Section"> | string
    seatmapId?: IntFilter<"Section"> | number
    isStage?: BoolFilter<"Section"> | boolean
    element?: JsonFilter<"Section">
    attribute?: JsonFilter<"Section">
    createdAt?: DateTimeFilter<"Section"> | Date | string
    ticketTypeId?: StringFilter<"Section"> | string
  }

  export type ShowingUpsertWithWhereUniqueWithoutSeatmapInput = {
    where: ShowingWhereUniqueInput
    update: XOR<ShowingUpdateWithoutSeatmapInput, ShowingUncheckedUpdateWithoutSeatmapInput>
    create: XOR<ShowingCreateWithoutSeatmapInput, ShowingUncheckedCreateWithoutSeatmapInput>
  }

  export type ShowingUpdateWithWhereUniqueWithoutSeatmapInput = {
    where: ShowingWhereUniqueInput
    data: XOR<ShowingUpdateWithoutSeatmapInput, ShowingUncheckedUpdateWithoutSeatmapInput>
  }

  export type ShowingUpdateManyWithWhereWithoutSeatmapInput = {
    where: ShowingScalarWhereInput
    data: XOR<ShowingUpdateManyMutationInput, ShowingUncheckedUpdateManyWithoutSeatmapInput>
  }

  export type RowCreateWithoutSectionInput = {
    name: string
    createdAt?: Date | string
    Seat?: SeatCreateNestedManyWithoutRowInput
  }

  export type RowUncheckedCreateWithoutSectionInput = {
    id?: number
    name: string
    createdAt?: Date | string
    Seat?: SeatUncheckedCreateNestedManyWithoutRowInput
  }

  export type RowCreateOrConnectWithoutSectionInput = {
    where: RowWhereUniqueInput
    create: XOR<RowCreateWithoutSectionInput, RowUncheckedCreateWithoutSectionInput>
  }

  export type RowCreateManySectionInputEnvelope = {
    data: RowCreateManySectionInput | RowCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type SeatmapCreateWithoutSectionInput = {
    name: string
    createdAt?: Date | string
    viewBox: string
    status: number
    Showing?: ShowingCreateNestedManyWithoutSeatmapInput
  }

  export type SeatmapUncheckedCreateWithoutSectionInput = {
    id?: number
    name: string
    createdAt?: Date | string
    viewBox: string
    status: number
    Showing?: ShowingUncheckedCreateNestedManyWithoutSeatmapInput
  }

  export type SeatmapCreateOrConnectWithoutSectionInput = {
    where: SeatmapWhereUniqueInput
    create: XOR<SeatmapCreateWithoutSectionInput, SeatmapUncheckedCreateWithoutSectionInput>
  }

  export type RowUpsertWithWhereUniqueWithoutSectionInput = {
    where: RowWhereUniqueInput
    update: XOR<RowUpdateWithoutSectionInput, RowUncheckedUpdateWithoutSectionInput>
    create: XOR<RowCreateWithoutSectionInput, RowUncheckedCreateWithoutSectionInput>
  }

  export type RowUpdateWithWhereUniqueWithoutSectionInput = {
    where: RowWhereUniqueInput
    data: XOR<RowUpdateWithoutSectionInput, RowUncheckedUpdateWithoutSectionInput>
  }

  export type RowUpdateManyWithWhereWithoutSectionInput = {
    where: RowScalarWhereInput
    data: XOR<RowUpdateManyMutationInput, RowUncheckedUpdateManyWithoutSectionInput>
  }

  export type RowScalarWhereInput = {
    AND?: RowScalarWhereInput | RowScalarWhereInput[]
    OR?: RowScalarWhereInput[]
    NOT?: RowScalarWhereInput | RowScalarWhereInput[]
    id?: IntFilter<"Row"> | number
    name?: StringFilter<"Row"> | string
    sectionId?: IntFilter<"Row"> | number
    createdAt?: DateTimeFilter<"Row"> | Date | string
  }

  export type SeatmapUpsertWithoutSectionInput = {
    update: XOR<SeatmapUpdateWithoutSectionInput, SeatmapUncheckedUpdateWithoutSectionInput>
    create: XOR<SeatmapCreateWithoutSectionInput, SeatmapUncheckedCreateWithoutSectionInput>
    where?: SeatmapWhereInput
  }

  export type SeatmapUpdateToOneWithWhereWithoutSectionInput = {
    where?: SeatmapWhereInput
    data: XOR<SeatmapUpdateWithoutSectionInput, SeatmapUncheckedUpdateWithoutSectionInput>
  }

  export type SeatmapUpdateWithoutSectionInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewBox?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    Showing?: ShowingUpdateManyWithoutSeatmapNestedInput
  }

  export type SeatmapUncheckedUpdateWithoutSectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewBox?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    Showing?: ShowingUncheckedUpdateManyWithoutSeatmapNestedInput
  }

  export type EventsCreateWithoutShowingInput = {
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status: string
    venue?: string | null
    createdAt?: Date | string
    minTicketPrice?: number
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore: Decimal | DecimalJsLike | number | string
    totalClicks?: number
    weekClicks?: number
    EventCategories?: EventCategoriesCreateNestedManyWithoutEventsInput
    Images_Events_imgLogoIdToImages?: ImagesCreateNestedOneWithoutEvents_Events_imgLogoIdToImagesInput
    Images_Events_imgPosterIdToImages?: ImagesCreateNestedOneWithoutEvents_Events_imgPosterIdToImagesInput
    locations: locationsCreateNestedOneWithoutEventsInput
    users?: UserCreateNestedOneWithoutEventsInput
  }

  export type EventsUncheckedCreateWithoutShowingInput = {
    id?: number
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    organizerId?: string | null
    status: string
    locationId: number
    venue?: string | null
    imgLogoId?: number | null
    imgPosterId?: number | null
    createdAt?: Date | string
    minTicketPrice?: number
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore: Decimal | DecimalJsLike | number | string
    totalClicks?: number
    weekClicks?: number
    EventCategories?: EventCategoriesUncheckedCreateNestedManyWithoutEventsInput
  }

  export type EventsCreateOrConnectWithoutShowingInput = {
    where: EventsWhereUniqueInput
    create: XOR<EventsCreateWithoutShowingInput, EventsUncheckedCreateWithoutShowingInput>
  }

  export type SeatmapCreateWithoutShowingInput = {
    name: string
    createdAt?: Date | string
    viewBox: string
    status: number
    Section?: SectionCreateNestedManyWithoutSeatmapInput
  }

  export type SeatmapUncheckedCreateWithoutShowingInput = {
    id?: number
    name: string
    createdAt?: Date | string
    viewBox: string
    status: number
    Section?: SectionUncheckedCreateNestedManyWithoutSeatmapInput
  }

  export type SeatmapCreateOrConnectWithoutShowingInput = {
    where: SeatmapWhereUniqueInput
    create: XOR<SeatmapCreateWithoutShowingInput, SeatmapUncheckedCreateWithoutShowingInput>
  }

  export type TicketCreateWithoutShowingInput = {
    id?: string
    status: number
    price: number
    userId?: number | null
    purchasedAt?: Date | string | null
    qrCode?: string | null
    Seat: SeatCreateNestedOneWithoutTicketInput
    TicketType: TicketTypeCreateNestedOneWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutShowingInput = {
    id?: string
    seatId: number
    ticketTypeId: string
    status: number
    price: number
    userId?: number | null
    purchasedAt?: Date | string | null
    qrCode?: string | null
  }

  export type TicketCreateOrConnectWithoutShowingInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutShowingInput, TicketUncheckedCreateWithoutShowingInput>
  }

  export type TicketCreateManyShowingInputEnvelope = {
    data: TicketCreateManyShowingInput | TicketCreateManyShowingInput[]
    skipDuplicates?: boolean
  }

  export type TicketTypeCreateWithoutShowingInput = {
    id: string
    name: string
    description: string
    color: string
    isFree: boolean
    price: number
    originalPrice: number
    maxQtyPerOrder: number
    minQtyPerOrder: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    position: number
    status: string
    imageUrl: string
    isHidden?: boolean
    Ticket?: TicketCreateNestedManyWithoutTicketTypeInput
  }

  export type TicketTypeUncheckedCreateWithoutShowingInput = {
    id: string
    name: string
    description: string
    color: string
    isFree: boolean
    price: number
    originalPrice: number
    maxQtyPerOrder: number
    minQtyPerOrder: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    position: number
    status: string
    imageUrl: string
    isHidden?: boolean
    Ticket?: TicketUncheckedCreateNestedManyWithoutTicketTypeInput
  }

  export type TicketTypeCreateOrConnectWithoutShowingInput = {
    where: TicketTypeWhereUniqueInput
    create: XOR<TicketTypeCreateWithoutShowingInput, TicketTypeUncheckedCreateWithoutShowingInput>
  }

  export type TicketTypeCreateManyShowingInputEnvelope = {
    data: TicketTypeCreateManyShowingInput | TicketTypeCreateManyShowingInput[]
    skipDuplicates?: boolean
  }

  export type EventsUpsertWithoutShowingInput = {
    update: XOR<EventsUpdateWithoutShowingInput, EventsUncheckedUpdateWithoutShowingInput>
    create: XOR<EventsCreateWithoutShowingInput, EventsUncheckedCreateWithoutShowingInput>
    where?: EventsWhereInput
  }

  export type EventsUpdateToOneWithWhereWithoutShowingInput = {
    where?: EventsWhereInput
    data: XOR<EventsUpdateWithoutShowingInput, EventsUncheckedUpdateWithoutShowingInput>
  }

  export type EventsUpdateWithoutShowingInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minTicketPrice?: IntFieldUpdateOperationsInput | number
    isOnlyOnEve?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    lastScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFieldUpdateOperationsInput | number
    weekClicks?: IntFieldUpdateOperationsInput | number
    EventCategories?: EventCategoriesUpdateManyWithoutEventsNestedInput
    Images_Events_imgLogoIdToImages?: ImagesUpdateOneWithoutEvents_Events_imgLogoIdToImagesNestedInput
    Images_Events_imgPosterIdToImages?: ImagesUpdateOneWithoutEvents_Events_imgPosterIdToImagesNestedInput
    locations?: locationsUpdateOneRequiredWithoutEventsNestedInput
    users?: UserUpdateOneWithoutEventsNestedInput
  }

  export type EventsUncheckedUpdateWithoutShowingInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    organizerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    imgLogoId?: NullableIntFieldUpdateOperationsInput | number | null
    imgPosterId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minTicketPrice?: IntFieldUpdateOperationsInput | number
    isOnlyOnEve?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    lastScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFieldUpdateOperationsInput | number
    weekClicks?: IntFieldUpdateOperationsInput | number
    EventCategories?: EventCategoriesUncheckedUpdateManyWithoutEventsNestedInput
  }

  export type SeatmapUpsertWithoutShowingInput = {
    update: XOR<SeatmapUpdateWithoutShowingInput, SeatmapUncheckedUpdateWithoutShowingInput>
    create: XOR<SeatmapCreateWithoutShowingInput, SeatmapUncheckedCreateWithoutShowingInput>
    where?: SeatmapWhereInput
  }

  export type SeatmapUpdateToOneWithWhereWithoutShowingInput = {
    where?: SeatmapWhereInput
    data: XOR<SeatmapUpdateWithoutShowingInput, SeatmapUncheckedUpdateWithoutShowingInput>
  }

  export type SeatmapUpdateWithoutShowingInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewBox?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    Section?: SectionUpdateManyWithoutSeatmapNestedInput
  }

  export type SeatmapUncheckedUpdateWithoutShowingInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewBox?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    Section?: SectionUncheckedUpdateManyWithoutSeatmapNestedInput
  }

  export type TicketUpsertWithWhereUniqueWithoutShowingInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutShowingInput, TicketUncheckedUpdateWithoutShowingInput>
    create: XOR<TicketCreateWithoutShowingInput, TicketUncheckedCreateWithoutShowingInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutShowingInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutShowingInput, TicketUncheckedUpdateWithoutShowingInput>
  }

  export type TicketUpdateManyWithWhereWithoutShowingInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutShowingInput>
  }

  export type TicketTypeUpsertWithWhereUniqueWithoutShowingInput = {
    where: TicketTypeWhereUniqueInput
    update: XOR<TicketTypeUpdateWithoutShowingInput, TicketTypeUncheckedUpdateWithoutShowingInput>
    create: XOR<TicketTypeCreateWithoutShowingInput, TicketTypeUncheckedCreateWithoutShowingInput>
  }

  export type TicketTypeUpdateWithWhereUniqueWithoutShowingInput = {
    where: TicketTypeWhereUniqueInput
    data: XOR<TicketTypeUpdateWithoutShowingInput, TicketTypeUncheckedUpdateWithoutShowingInput>
  }

  export type TicketTypeUpdateManyWithWhereWithoutShowingInput = {
    where: TicketTypeScalarWhereInput
    data: XOR<TicketTypeUpdateManyMutationInput, TicketTypeUncheckedUpdateManyWithoutShowingInput>
  }

  export type TicketTypeScalarWhereInput = {
    AND?: TicketTypeScalarWhereInput | TicketTypeScalarWhereInput[]
    OR?: TicketTypeScalarWhereInput[]
    NOT?: TicketTypeScalarWhereInput | TicketTypeScalarWhereInput[]
    id?: StringFilter<"TicketType"> | string
    showingId?: StringFilter<"TicketType"> | string
    name?: StringFilter<"TicketType"> | string
    description?: StringFilter<"TicketType"> | string
    color?: StringFilter<"TicketType"> | string
    isFree?: BoolFilter<"TicketType"> | boolean
    price?: IntFilter<"TicketType"> | number
    originalPrice?: IntFilter<"TicketType"> | number
    maxQtyPerOrder?: IntFilter<"TicketType"> | number
    minQtyPerOrder?: IntFilter<"TicketType"> | number
    effectiveFrom?: DateTimeFilter<"TicketType"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"TicketType"> | Date | string | null
    position?: IntFilter<"TicketType"> | number
    status?: StringFilter<"TicketType"> | string
    imageUrl?: StringFilter<"TicketType"> | string
    isHidden?: BoolFilter<"TicketType"> | boolean
  }

  export type SeatCreateWithoutTicketInput = {
    name: string
    positionX: number
    positionY: number
    createdAt?: Date | string
    position: number
    Row: RowCreateNestedOneWithoutSeatInput
  }

  export type SeatUncheckedCreateWithoutTicketInput = {
    id?: number
    name: string
    rowId: number
    positionX: number
    positionY: number
    createdAt?: Date | string
    position: number
  }

  export type SeatCreateOrConnectWithoutTicketInput = {
    where: SeatWhereUniqueInput
    create: XOR<SeatCreateWithoutTicketInput, SeatUncheckedCreateWithoutTicketInput>
  }

  export type ShowingCreateWithoutTicketInput = {
    id: string
    status: string
    isFree: boolean
    isSalable: boolean
    isPresale: boolean
    startTime: Date | string
    endTime: Date | string
    isEnabledQueueWaiting: boolean
    showAllSeats: boolean
    Events: EventsCreateNestedOneWithoutShowingInput
    Seatmap: SeatmapCreateNestedOneWithoutShowingInput
    TicketType?: TicketTypeCreateNestedManyWithoutShowingInput
  }

  export type ShowingUncheckedCreateWithoutTicketInput = {
    id: string
    eventId: number
    status: string
    isFree: boolean
    isSalable: boolean
    isPresale: boolean
    seatMapId: number
    startTime: Date | string
    endTime: Date | string
    isEnabledQueueWaiting: boolean
    showAllSeats: boolean
    TicketType?: TicketTypeUncheckedCreateNestedManyWithoutShowingInput
  }

  export type ShowingCreateOrConnectWithoutTicketInput = {
    where: ShowingWhereUniqueInput
    create: XOR<ShowingCreateWithoutTicketInput, ShowingUncheckedCreateWithoutTicketInput>
  }

  export type TicketTypeCreateWithoutTicketInput = {
    id: string
    name: string
    description: string
    color: string
    isFree: boolean
    price: number
    originalPrice: number
    maxQtyPerOrder: number
    minQtyPerOrder: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    position: number
    status: string
    imageUrl: string
    isHidden?: boolean
    Showing: ShowingCreateNestedOneWithoutTicketTypeInput
  }

  export type TicketTypeUncheckedCreateWithoutTicketInput = {
    id: string
    showingId: string
    name: string
    description: string
    color: string
    isFree: boolean
    price: number
    originalPrice: number
    maxQtyPerOrder: number
    minQtyPerOrder: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    position: number
    status: string
    imageUrl: string
    isHidden?: boolean
  }

  export type TicketTypeCreateOrConnectWithoutTicketInput = {
    where: TicketTypeWhereUniqueInput
    create: XOR<TicketTypeCreateWithoutTicketInput, TicketTypeUncheckedCreateWithoutTicketInput>
  }

  export type SeatUpsertWithoutTicketInput = {
    update: XOR<SeatUpdateWithoutTicketInput, SeatUncheckedUpdateWithoutTicketInput>
    create: XOR<SeatCreateWithoutTicketInput, SeatUncheckedCreateWithoutTicketInput>
    where?: SeatWhereInput
  }

  export type SeatUpdateToOneWithWhereWithoutTicketInput = {
    where?: SeatWhereInput
    data: XOR<SeatUpdateWithoutTicketInput, SeatUncheckedUpdateWithoutTicketInput>
  }

  export type SeatUpdateWithoutTicketInput = {
    name?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: IntFieldUpdateOperationsInput | number
    Row?: RowUpdateOneRequiredWithoutSeatNestedInput
  }

  export type SeatUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rowId?: IntFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ShowingUpsertWithoutTicketInput = {
    update: XOR<ShowingUpdateWithoutTicketInput, ShowingUncheckedUpdateWithoutTicketInput>
    create: XOR<ShowingCreateWithoutTicketInput, ShowingUncheckedCreateWithoutTicketInput>
    where?: ShowingWhereInput
  }

  export type ShowingUpdateToOneWithWhereWithoutTicketInput = {
    where?: ShowingWhereInput
    data: XOR<ShowingUpdateWithoutTicketInput, ShowingUncheckedUpdateWithoutTicketInput>
  }

  export type ShowingUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    isSalable?: BoolFieldUpdateOperationsInput | boolean
    isPresale?: BoolFieldUpdateOperationsInput | boolean
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnabledQueueWaiting?: BoolFieldUpdateOperationsInput | boolean
    showAllSeats?: BoolFieldUpdateOperationsInput | boolean
    Events?: EventsUpdateOneRequiredWithoutShowingNestedInput
    Seatmap?: SeatmapUpdateOneRequiredWithoutShowingNestedInput
    TicketType?: TicketTypeUpdateManyWithoutShowingNestedInput
  }

  export type ShowingUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    isSalable?: BoolFieldUpdateOperationsInput | boolean
    isPresale?: BoolFieldUpdateOperationsInput | boolean
    seatMapId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnabledQueueWaiting?: BoolFieldUpdateOperationsInput | boolean
    showAllSeats?: BoolFieldUpdateOperationsInput | boolean
    TicketType?: TicketTypeUncheckedUpdateManyWithoutShowingNestedInput
  }

  export type TicketTypeUpsertWithoutTicketInput = {
    update: XOR<TicketTypeUpdateWithoutTicketInput, TicketTypeUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketTypeCreateWithoutTicketInput, TicketTypeUncheckedCreateWithoutTicketInput>
    where?: TicketTypeWhereInput
  }

  export type TicketTypeUpdateToOneWithWhereWithoutTicketInput = {
    where?: TicketTypeWhereInput
    data: XOR<TicketTypeUpdateWithoutTicketInput, TicketTypeUncheckedUpdateWithoutTicketInput>
  }

  export type TicketTypeUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: IntFieldUpdateOperationsInput | number
    maxQtyPerOrder?: IntFieldUpdateOperationsInput | number
    minQtyPerOrder?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    Showing?: ShowingUpdateOneRequiredWithoutTicketTypeNestedInput
  }

  export type TicketTypeUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    showingId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: IntFieldUpdateOperationsInput | number
    maxQtyPerOrder?: IntFieldUpdateOperationsInput | number
    minQtyPerOrder?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TicketCreateWithoutTicketTypeInput = {
    id?: string
    status: number
    price: number
    userId?: number | null
    purchasedAt?: Date | string | null
    qrCode?: string | null
    Seat: SeatCreateNestedOneWithoutTicketInput
    Showing: ShowingCreateNestedOneWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutTicketTypeInput = {
    id?: string
    seatId: number
    showingId: string
    status: number
    price: number
    userId?: number | null
    purchasedAt?: Date | string | null
    qrCode?: string | null
  }

  export type TicketCreateOrConnectWithoutTicketTypeInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutTicketTypeInput, TicketUncheckedCreateWithoutTicketTypeInput>
  }

  export type TicketCreateManyTicketTypeInputEnvelope = {
    data: TicketCreateManyTicketTypeInput | TicketCreateManyTicketTypeInput[]
    skipDuplicates?: boolean
  }

  export type ShowingCreateWithoutTicketTypeInput = {
    id: string
    status: string
    isFree: boolean
    isSalable: boolean
    isPresale: boolean
    startTime: Date | string
    endTime: Date | string
    isEnabledQueueWaiting: boolean
    showAllSeats: boolean
    Events: EventsCreateNestedOneWithoutShowingInput
    Seatmap: SeatmapCreateNestedOneWithoutShowingInput
    Ticket?: TicketCreateNestedManyWithoutShowingInput
  }

  export type ShowingUncheckedCreateWithoutTicketTypeInput = {
    id: string
    eventId: number
    status: string
    isFree: boolean
    isSalable: boolean
    isPresale: boolean
    seatMapId: number
    startTime: Date | string
    endTime: Date | string
    isEnabledQueueWaiting: boolean
    showAllSeats: boolean
    Ticket?: TicketUncheckedCreateNestedManyWithoutShowingInput
  }

  export type ShowingCreateOrConnectWithoutTicketTypeInput = {
    where: ShowingWhereUniqueInput
    create: XOR<ShowingCreateWithoutTicketTypeInput, ShowingUncheckedCreateWithoutTicketTypeInput>
  }

  export type TicketUpsertWithWhereUniqueWithoutTicketTypeInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutTicketTypeInput, TicketUncheckedUpdateWithoutTicketTypeInput>
    create: XOR<TicketCreateWithoutTicketTypeInput, TicketUncheckedCreateWithoutTicketTypeInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutTicketTypeInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutTicketTypeInput, TicketUncheckedUpdateWithoutTicketTypeInput>
  }

  export type TicketUpdateManyWithWhereWithoutTicketTypeInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutTicketTypeInput>
  }

  export type ShowingUpsertWithoutTicketTypeInput = {
    update: XOR<ShowingUpdateWithoutTicketTypeInput, ShowingUncheckedUpdateWithoutTicketTypeInput>
    create: XOR<ShowingCreateWithoutTicketTypeInput, ShowingUncheckedCreateWithoutTicketTypeInput>
    where?: ShowingWhereInput
  }

  export type ShowingUpdateToOneWithWhereWithoutTicketTypeInput = {
    where?: ShowingWhereInput
    data: XOR<ShowingUpdateWithoutTicketTypeInput, ShowingUncheckedUpdateWithoutTicketTypeInput>
  }

  export type ShowingUpdateWithoutTicketTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    isSalable?: BoolFieldUpdateOperationsInput | boolean
    isPresale?: BoolFieldUpdateOperationsInput | boolean
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnabledQueueWaiting?: BoolFieldUpdateOperationsInput | boolean
    showAllSeats?: BoolFieldUpdateOperationsInput | boolean
    Events?: EventsUpdateOneRequiredWithoutShowingNestedInput
    Seatmap?: SeatmapUpdateOneRequiredWithoutShowingNestedInput
    Ticket?: TicketUpdateManyWithoutShowingNestedInput
  }

  export type ShowingUncheckedUpdateWithoutTicketTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    isSalable?: BoolFieldUpdateOperationsInput | boolean
    isPresale?: BoolFieldUpdateOperationsInput | boolean
    seatMapId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnabledQueueWaiting?: BoolFieldUpdateOperationsInput | boolean
    showAllSeats?: BoolFieldUpdateOperationsInput | boolean
    Ticket?: TicketUncheckedUpdateManyWithoutShowingNestedInput
  }

  export type EventsCreateManyUsersInput = {
    id?: number
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status: string
    locationId: number
    venue?: string | null
    imgLogoId?: number | null
    imgPosterId?: number | null
    createdAt?: Date | string
    minTicketPrice?: number
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore: Decimal | DecimalJsLike | number | string
    totalClicks?: number
    weekClicks?: number
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: number
    token: string
    revoked?: boolean
    expiresAt: Date | string
  }

  export type UserProvinceCreateManyUserInput = {
    provinceId: number
  }

  export type EventsUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minTicketPrice?: IntFieldUpdateOperationsInput | number
    isOnlyOnEve?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    lastScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFieldUpdateOperationsInput | number
    weekClicks?: IntFieldUpdateOperationsInput | number
    EventCategories?: EventCategoriesUpdateManyWithoutEventsNestedInput
    Images_Events_imgLogoIdToImages?: ImagesUpdateOneWithoutEvents_Events_imgLogoIdToImagesNestedInput
    Images_Events_imgPosterIdToImages?: ImagesUpdateOneWithoutEvents_Events_imgPosterIdToImagesNestedInput
    locations?: locationsUpdateOneRequiredWithoutEventsNestedInput
    Showing?: ShowingUpdateManyWithoutEventsNestedInput
  }

  export type EventsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    imgLogoId?: NullableIntFieldUpdateOperationsInput | number | null
    imgPosterId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minTicketPrice?: IntFieldUpdateOperationsInput | number
    isOnlyOnEve?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    lastScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFieldUpdateOperationsInput | number
    weekClicks?: IntFieldUpdateOperationsInput | number
    EventCategories?: EventCategoriesUncheckedUpdateManyWithoutEventsNestedInput
    Showing?: ShowingUncheckedUpdateManyWithoutEventsNestedInput
  }

  export type EventsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    imgLogoId?: NullableIntFieldUpdateOperationsInput | number | null
    imgPosterId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minTicketPrice?: IntFieldUpdateOperationsInput | number
    isOnlyOnEve?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    lastScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFieldUpdateOperationsInput | number
    weekClicks?: IntFieldUpdateOperationsInput | number
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProvinceUpdateWithoutUserInput = {
    province?: ProvinceUpdateOneRequiredWithoutUserProvinceNestedInput
  }

  export type UserProvinceUncheckedUpdateWithoutUserInput = {
    provinceId?: IntFieldUpdateOperationsInput | number
  }

  export type UserProvinceUncheckedUpdateManyWithoutUserInput = {
    provinceId?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateManyRoleInput = {
    id: string
    name: string
    email: string
    phone: string
    password: string
    created_at?: Date | string
  }

  export type UserUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Events?: EventsUpdateManyWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    userProvince?: UserProvinceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Events?: EventsUncheckedUpdateManyWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    userProvince?: UserProvinceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type districtsCreateManyProvinceInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type UserProvinceCreateManyProvinceInput = {
    userId: string
  }

  export type districtsUpdateWithoutProvinceInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: locationsUpdateManyWithoutDistrictsNestedInput
  }

  export type districtsUncheckedUpdateWithoutProvinceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: locationsUncheckedUpdateManyWithoutDistrictsNestedInput
  }

  export type districtsUncheckedUpdateManyWithoutProvinceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProvinceUpdateWithoutProvinceInput = {
    user?: UserUpdateOneRequiredWithoutUserProvinceNestedInput
  }

  export type UserProvinceUncheckedUpdateWithoutProvinceInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserProvinceUncheckedUpdateManyWithoutProvinceInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type EventCategoriesCreateManyCategoriesInput = {
    id?: number
    eventId: number
    isSpecial?: boolean
  }

  export type EventCategoriesUpdateWithoutCategoriesInput = {
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    Events?: EventsUpdateOneRequiredWithoutEventCategoriesNestedInput
  }

  export type EventCategoriesUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventId?: IntFieldUpdateOperationsInput | number
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventCategoriesUncheckedUpdateManyWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventId?: IntFieldUpdateOperationsInput | number
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventCategoriesCreateManyEventsInput = {
    id?: number
    categoryId: number
    isSpecial?: boolean
  }

  export type ShowingCreateManyEventsInput = {
    id: string
    status: string
    isFree: boolean
    isSalable: boolean
    isPresale: boolean
    seatMapId: number
    startTime: Date | string
    endTime: Date | string
    isEnabledQueueWaiting: boolean
    showAllSeats: boolean
  }

  export type EventCategoriesUpdateWithoutEventsInput = {
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    Categories?: CategoriesUpdateOneRequiredWithoutEventCategoriesNestedInput
  }

  export type EventCategoriesUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventCategoriesUncheckedUpdateManyWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ShowingUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    isSalable?: BoolFieldUpdateOperationsInput | boolean
    isPresale?: BoolFieldUpdateOperationsInput | boolean
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnabledQueueWaiting?: BoolFieldUpdateOperationsInput | boolean
    showAllSeats?: BoolFieldUpdateOperationsInput | boolean
    Seatmap?: SeatmapUpdateOneRequiredWithoutShowingNestedInput
    Ticket?: TicketUpdateManyWithoutShowingNestedInput
    TicketType?: TicketTypeUpdateManyWithoutShowingNestedInput
  }

  export type ShowingUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    isSalable?: BoolFieldUpdateOperationsInput | boolean
    isPresale?: BoolFieldUpdateOperationsInput | boolean
    seatMapId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnabledQueueWaiting?: BoolFieldUpdateOperationsInput | boolean
    showAllSeats?: BoolFieldUpdateOperationsInput | boolean
    Ticket?: TicketUncheckedUpdateManyWithoutShowingNestedInput
    TicketType?: TicketTypeUncheckedUpdateManyWithoutShowingNestedInput
  }

  export type ShowingUncheckedUpdateManyWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    isSalable?: BoolFieldUpdateOperationsInput | boolean
    isPresale?: BoolFieldUpdateOperationsInput | boolean
    seatMapId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnabledQueueWaiting?: BoolFieldUpdateOperationsInput | boolean
    showAllSeats?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventsCreateManyImages_Events_imgLogoIdToImagesInput = {
    id?: number
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    organizerId?: string | null
    status: string
    locationId: number
    venue?: string | null
    imgPosterId?: number | null
    createdAt?: Date | string
    minTicketPrice?: number
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore: Decimal | DecimalJsLike | number | string
    totalClicks?: number
    weekClicks?: number
  }

  export type EventsCreateManyImages_Events_imgPosterIdToImagesInput = {
    id?: number
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    organizerId?: string | null
    status: string
    locationId: number
    venue?: string | null
    imgLogoId?: number | null
    createdAt?: Date | string
    minTicketPrice?: number
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore: Decimal | DecimalJsLike | number | string
    totalClicks?: number
    weekClicks?: number
  }

  export type EventsUpdateWithoutImages_Events_imgLogoIdToImagesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minTicketPrice?: IntFieldUpdateOperationsInput | number
    isOnlyOnEve?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    lastScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFieldUpdateOperationsInput | number
    weekClicks?: IntFieldUpdateOperationsInput | number
    EventCategories?: EventCategoriesUpdateManyWithoutEventsNestedInput
    Images_Events_imgPosterIdToImages?: ImagesUpdateOneWithoutEvents_Events_imgPosterIdToImagesNestedInput
    locations?: locationsUpdateOneRequiredWithoutEventsNestedInput
    users?: UserUpdateOneWithoutEventsNestedInput
    Showing?: ShowingUpdateManyWithoutEventsNestedInput
  }

  export type EventsUncheckedUpdateWithoutImages_Events_imgLogoIdToImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    organizerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    imgPosterId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minTicketPrice?: IntFieldUpdateOperationsInput | number
    isOnlyOnEve?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    lastScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFieldUpdateOperationsInput | number
    weekClicks?: IntFieldUpdateOperationsInput | number
    EventCategories?: EventCategoriesUncheckedUpdateManyWithoutEventsNestedInput
    Showing?: ShowingUncheckedUpdateManyWithoutEventsNestedInput
  }

  export type EventsUncheckedUpdateManyWithoutImages_Events_imgLogoIdToImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    organizerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    imgPosterId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minTicketPrice?: IntFieldUpdateOperationsInput | number
    isOnlyOnEve?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    lastScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFieldUpdateOperationsInput | number
    weekClicks?: IntFieldUpdateOperationsInput | number
  }

  export type EventsUpdateWithoutImages_Events_imgPosterIdToImagesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minTicketPrice?: IntFieldUpdateOperationsInput | number
    isOnlyOnEve?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    lastScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFieldUpdateOperationsInput | number
    weekClicks?: IntFieldUpdateOperationsInput | number
    EventCategories?: EventCategoriesUpdateManyWithoutEventsNestedInput
    Images_Events_imgLogoIdToImages?: ImagesUpdateOneWithoutEvents_Events_imgLogoIdToImagesNestedInput
    locations?: locationsUpdateOneRequiredWithoutEventsNestedInput
    users?: UserUpdateOneWithoutEventsNestedInput
    Showing?: ShowingUpdateManyWithoutEventsNestedInput
  }

  export type EventsUncheckedUpdateWithoutImages_Events_imgPosterIdToImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    organizerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    imgLogoId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minTicketPrice?: IntFieldUpdateOperationsInput | number
    isOnlyOnEve?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    lastScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFieldUpdateOperationsInput | number
    weekClicks?: IntFieldUpdateOperationsInput | number
    EventCategories?: EventCategoriesUncheckedUpdateManyWithoutEventsNestedInput
    Showing?: ShowingUncheckedUpdateManyWithoutEventsNestedInput
  }

  export type EventsUncheckedUpdateManyWithoutImages_Events_imgPosterIdToImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    organizerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    imgLogoId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minTicketPrice?: IntFieldUpdateOperationsInput | number
    isOnlyOnEve?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    lastScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFieldUpdateOperationsInput | number
    weekClicks?: IntFieldUpdateOperationsInput | number
  }

  export type locationsCreateManyDistrictsInput = {
    id?: number
    street: string
    ward: string
    createdAt?: Date | string
  }

  export type locationsUpdateWithoutDistrictsInput = {
    street?: StringFieldUpdateOperationsInput | string
    ward?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Events?: EventsUpdateManyWithoutLocationsNestedInput
  }

  export type locationsUncheckedUpdateWithoutDistrictsInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    ward?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Events?: EventsUncheckedUpdateManyWithoutLocationsNestedInput
  }

  export type locationsUncheckedUpdateManyWithoutDistrictsInput = {
    id?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    ward?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsCreateManyLocationsInput = {
    id?: number
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    organizerId?: string | null
    status: string
    venue?: string | null
    imgLogoId?: number | null
    imgPosterId?: number | null
    createdAt?: Date | string
    minTicketPrice?: number
    isOnlyOnEve?: boolean
    isSpecial?: boolean
    lastScore: Decimal | DecimalJsLike | number | string
    totalClicks?: number
    weekClicks?: number
  }

  export type EventsUpdateWithoutLocationsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minTicketPrice?: IntFieldUpdateOperationsInput | number
    isOnlyOnEve?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    lastScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFieldUpdateOperationsInput | number
    weekClicks?: IntFieldUpdateOperationsInput | number
    EventCategories?: EventCategoriesUpdateManyWithoutEventsNestedInput
    Images_Events_imgLogoIdToImages?: ImagesUpdateOneWithoutEvents_Events_imgLogoIdToImagesNestedInput
    Images_Events_imgPosterIdToImages?: ImagesUpdateOneWithoutEvents_Events_imgPosterIdToImagesNestedInput
    users?: UserUpdateOneWithoutEventsNestedInput
    Showing?: ShowingUpdateManyWithoutEventsNestedInput
  }

  export type EventsUncheckedUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    organizerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    imgLogoId?: NullableIntFieldUpdateOperationsInput | number | null
    imgPosterId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minTicketPrice?: IntFieldUpdateOperationsInput | number
    isOnlyOnEve?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    lastScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFieldUpdateOperationsInput | number
    weekClicks?: IntFieldUpdateOperationsInput | number
    EventCategories?: EventCategoriesUncheckedUpdateManyWithoutEventsNestedInput
    Showing?: ShowingUncheckedUpdateManyWithoutEventsNestedInput
  }

  export type EventsUncheckedUpdateManyWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    organizerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    imgLogoId?: NullableIntFieldUpdateOperationsInput | number | null
    imgPosterId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    minTicketPrice?: IntFieldUpdateOperationsInput | number
    isOnlyOnEve?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    lastScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalClicks?: IntFieldUpdateOperationsInput | number
    weekClicks?: IntFieldUpdateOperationsInput | number
  }

  export type SeatCreateManyRowInput = {
    id?: number
    name: string
    positionX: number
    positionY: number
    createdAt?: Date | string
    position: number
  }

  export type SeatUpdateWithoutRowInput = {
    name?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: IntFieldUpdateOperationsInput | number
    Ticket?: TicketUpdateManyWithoutSeatNestedInput
  }

  export type SeatUncheckedUpdateWithoutRowInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: IntFieldUpdateOperationsInput | number
    Ticket?: TicketUncheckedUpdateManyWithoutSeatNestedInput
  }

  export type SeatUncheckedUpdateManyWithoutRowInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type TicketCreateManySeatInput = {
    id?: string
    showingId: string
    ticketTypeId: string
    status: number
    price: number
    userId?: number | null
    purchasedAt?: Date | string | null
    qrCode?: string | null
  }

  export type TicketUpdateWithoutSeatInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    Showing?: ShowingUpdateOneRequiredWithoutTicketNestedInput
    TicketType?: TicketTypeUpdateOneRequiredWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutSeatInput = {
    id?: StringFieldUpdateOperationsInput | string
    showingId?: StringFieldUpdateOperationsInput | string
    ticketTypeId?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketUncheckedUpdateManyWithoutSeatInput = {
    id?: StringFieldUpdateOperationsInput | string
    showingId?: StringFieldUpdateOperationsInput | string
    ticketTypeId?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SectionCreateManySeatmapInput = {
    id?: number
    name: string
    isStage: boolean
    element: JsonNullValueInput | InputJsonValue
    attribute: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    ticketTypeId: string
  }

  export type ShowingCreateManySeatmapInput = {
    id: string
    eventId: number
    status: string
    isFree: boolean
    isSalable: boolean
    isPresale: boolean
    startTime: Date | string
    endTime: Date | string
    isEnabledQueueWaiting: boolean
    showAllSeats: boolean
  }

  export type SectionUpdateWithoutSeatmapInput = {
    name?: StringFieldUpdateOperationsInput | string
    isStage?: BoolFieldUpdateOperationsInput | boolean
    element?: JsonNullValueInput | InputJsonValue
    attribute?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketTypeId?: StringFieldUpdateOperationsInput | string
    Row?: RowUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutSeatmapInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isStage?: BoolFieldUpdateOperationsInput | boolean
    element?: JsonNullValueInput | InputJsonValue
    attribute?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketTypeId?: StringFieldUpdateOperationsInput | string
    Row?: RowUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateManyWithoutSeatmapInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isStage?: BoolFieldUpdateOperationsInput | boolean
    element?: JsonNullValueInput | InputJsonValue
    attribute?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type ShowingUpdateWithoutSeatmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    isSalable?: BoolFieldUpdateOperationsInput | boolean
    isPresale?: BoolFieldUpdateOperationsInput | boolean
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnabledQueueWaiting?: BoolFieldUpdateOperationsInput | boolean
    showAllSeats?: BoolFieldUpdateOperationsInput | boolean
    Events?: EventsUpdateOneRequiredWithoutShowingNestedInput
    Ticket?: TicketUpdateManyWithoutShowingNestedInput
    TicketType?: TicketTypeUpdateManyWithoutShowingNestedInput
  }

  export type ShowingUncheckedUpdateWithoutSeatmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    isSalable?: BoolFieldUpdateOperationsInput | boolean
    isPresale?: BoolFieldUpdateOperationsInput | boolean
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnabledQueueWaiting?: BoolFieldUpdateOperationsInput | boolean
    showAllSeats?: BoolFieldUpdateOperationsInput | boolean
    Ticket?: TicketUncheckedUpdateManyWithoutShowingNestedInput
    TicketType?: TicketTypeUncheckedUpdateManyWithoutShowingNestedInput
  }

  export type ShowingUncheckedUpdateManyWithoutSeatmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    isSalable?: BoolFieldUpdateOperationsInput | boolean
    isPresale?: BoolFieldUpdateOperationsInput | boolean
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isEnabledQueueWaiting?: BoolFieldUpdateOperationsInput | boolean
    showAllSeats?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RowCreateManySectionInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type RowUpdateWithoutSectionInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Seat?: SeatUpdateManyWithoutRowNestedInput
  }

  export type RowUncheckedUpdateWithoutSectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Seat?: SeatUncheckedUpdateManyWithoutRowNestedInput
  }

  export type RowUncheckedUpdateManyWithoutSectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateManyShowingInput = {
    id?: string
    seatId: number
    ticketTypeId: string
    status: number
    price: number
    userId?: number | null
    purchasedAt?: Date | string | null
    qrCode?: string | null
  }

  export type TicketTypeCreateManyShowingInput = {
    id: string
    name: string
    description: string
    color: string
    isFree: boolean
    price: number
    originalPrice: number
    maxQtyPerOrder: number
    minQtyPerOrder: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    position: number
    status: string
    imageUrl: string
    isHidden?: boolean
  }

  export type TicketUpdateWithoutShowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    Seat?: SeatUpdateOneRequiredWithoutTicketNestedInput
    TicketType?: TicketTypeUpdateOneRequiredWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutShowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatId?: IntFieldUpdateOperationsInput | number
    ticketTypeId?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketUncheckedUpdateManyWithoutShowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatId?: IntFieldUpdateOperationsInput | number
    ticketTypeId?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketTypeUpdateWithoutShowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: IntFieldUpdateOperationsInput | number
    maxQtyPerOrder?: IntFieldUpdateOperationsInput | number
    minQtyPerOrder?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    Ticket?: TicketUpdateManyWithoutTicketTypeNestedInput
  }

  export type TicketTypeUncheckedUpdateWithoutShowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: IntFieldUpdateOperationsInput | number
    maxQtyPerOrder?: IntFieldUpdateOperationsInput | number
    minQtyPerOrder?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    Ticket?: TicketUncheckedUpdateManyWithoutTicketTypeNestedInput
  }

  export type TicketTypeUncheckedUpdateManyWithoutShowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isFree?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    originalPrice?: IntFieldUpdateOperationsInput | number
    maxQtyPerOrder?: IntFieldUpdateOperationsInput | number
    minQtyPerOrder?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TicketCreateManyTicketTypeInput = {
    id?: string
    seatId: number
    showingId: string
    status: number
    price: number
    userId?: number | null
    purchasedAt?: Date | string | null
    qrCode?: string | null
  }

  export type TicketUpdateWithoutTicketTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    Seat?: SeatUpdateOneRequiredWithoutTicketNestedInput
    Showing?: ShowingUpdateOneRequiredWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutTicketTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatId?: IntFieldUpdateOperationsInput | number
    showingId?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketUncheckedUpdateManyWithoutTicketTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatId?: IntFieldUpdateOperationsInput | number
    showingId?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    purchasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}